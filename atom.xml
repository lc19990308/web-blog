<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bug制造者</title>
  
  
  <link href="http://yaru722.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://yaru722.gitee.io/"/>
  <updated>2022-06-08T10:56:01.853Z</updated>
  <id>http://yaru722.gitee.io/</id>
  
  <author>
    <name>lc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于JavaScript的严格模式那些事</title>
    <link href="http://yaru722.gitee.io/2022/06/08/JavaScript%E5%BD%93%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yaru722.gitee.io/2022/06/08/JavaScript%E5%BD%93%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-08T10:54:30.539Z</published>
    <updated>2022-06-08T10:56:01.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript通常情况下隐式运行在正常模式-“Sloppy Mode”，ES5及其版本之后，javaScript可以显示运行在严格模式-“Strict Mode”！在严格模式下。可以减少我们编写不安全的JavaScript代码，获得更加清大的错误检查机制。为了向后兼容，严格模式需要我们手动开启！</p></blockquote><ol><li>变量必须先声明后使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">console.log(&quot;🚀 ~ file: index.js ~ line 4 ~ a&quot;, a)</span><br><span class="line">a = 11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>函数型参不允许重复</li></ol><p>bad</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(x, y, y) &#123;</span><br><span class="line">   return x + y + y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(1, 2, 1));//Uncaught SyntaxError: Duplicate parameter name not allowed in this context (at index.js:4:21)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>good</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(x, y, z) &#123;</span><br><span class="line">   return x + y + z;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(1, 2, 1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>函数的arguments 在严格模式和非严格模式下也有区别。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">   console.dir(arguments)</span><br><span class="line">   console.log(arguments.callee, arguments.caller);</span><br><span class="line">   /**</span><br><span class="line">    * @非严格模式</span><br><span class="line">   0: (4) [1, 2, 3, 4]</span><br><span class="line">   callee: ƒ test()</span><br><span class="line">   length: 1</span><br><span class="line">   Symbol(Symbol.iterator): ƒ values()</span><br><span class="line">   [[Prototype]]: Object</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @严格模式</span><br><span class="line">    * 0: (4) [1, 2, 3, 4]</span><br><span class="line">      callee: [Exception: TypeError: &#x27;caller&#x27;, &#x27;callee&#x27;, and &#x27;arguments&#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them at Arguments.s (&lt;anonymous&gt;:1:83)]</span><br><span class="line">      length: 1</span><br><span class="line">      Symbol(Symbol.iterator): ƒ values()</span><br><span class="line">      get callee: ƒ ()</span><br><span class="line">      set callee: ƒ ()</span><br><span class="line">      [[Prototype]]: Object</span><br><span class="line">   */</span><br><span class="line">&#125;</span><br><span class="line">test([1, 2, 3, 4]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>严格模式下的arguments消失了。</p><p>arguments.callee, arguments.caller</p><h4 id="width不可用"><a href="#width不可用" class="headerlink" title="width不可用"></a>width不可用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">   name: &#x27;使用with读取对象属性&#x27;</span><br><span class="line">&#125;</span><br><span class="line">with (obj) &#123;//严格模式下将禁用with关键字</span><br><span class="line">   console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="八进制数不可用"><a href="#八进制数不可用" class="headerlink" title="八进制数不可用"></a>八进制数不可用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">console.log(010 === 8)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="严格模式下的this指向"><a href="#严格模式下的this指向" class="headerlink" title="严格模式下的this指向"></a>严格模式下的this指向</h4><p>请注意：这里的函数时非方法函数！因为方法与对象挂钩，有具体的this!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line">function foo() &#123;</span><br><span class="line">   console.log(this)//undefined</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结</p><ul><li>js严格模式下 必须要显式声明变量才允许使用</li><li>width 方法不可用</li><li>arguments少了一些东西</li><li>八进制不可用</li><li>非方法函数this指向undefined</li><li>形参不允许 重复定义</li></ul>]]></content>
    
    
    <summary type="html">严格模式是什么，为什么要有严格模式，都有哪些限制</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="严格模式" scheme="http://yaru722.gitee.io/tags/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的去console</title>
    <link href="http://yaru722.gitee.io/2022/06/08/%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8Cconsole/"/>
    <id>http://yaru722.gitee.io/2022/06/08/%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8Cconsole/</id>
    <published>2022-06-08T10:52:01.196Z</published>
    <updated>2022-06-08T10:53:44.747Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不要再去console一把梭了。"><a href="#不要再去console一把梭了。" class="headerlink" title="不要再去console一把梭了。"></a>不要再去console一把梭了。</h4><h5 id="使用console-time-console-timeEnd"><a href="#使用console-time-console-timeEnd" class="headerlink" title="使用console.time,console.timeEnd"></a>使用console.time,console.timeEnd</h5><p>可以获取到代码的执行时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.time(1);</span><br><span class="line">console.timeEnd(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Console-assert-如果结果是true-就不会打印出来。"><a href="#Console-assert-如果结果是true-就不会打印出来。" class="headerlink" title="Console.assert()如果结果是true 就不会打印出来。"></a>Console.assert()如果结果是true 就不会打印出来。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let len = 10;</span><br><span class="line">console.assert(len !== 10, &#x27;失败&#x27;);</span><br></pre></td></tr></table></figure><h5 id="console-trace对栈的追踪"><a href="#console-trace对栈的追踪" class="headerlink" title="console.trace对栈的追踪"></a>console.trace对栈的追踪</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.trace(test)</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="console-table-打印出来一个表格，比较适合对-引用类型的数据"><a href="#console-table-打印出来一个表格，比较适合对-引用类型的数据" class="headerlink" title="console.table 打印出来一个表格，比较适合对 引用类型的数据"></a>console.table 打印出来一个表格，比较适合对 引用类型的数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let tableData = [&#123;</span><br><span class="line">    date: &#x27;2016-05-02&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1518 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-04&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1517 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-01&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1519 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-03&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1516 弄&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">console.table(tableData)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据的展示会更加直观。。</p><h5 id="对log进行分级"><a href="#对log进行分级" class="headerlink" title="对log进行分级"></a>对log进行分级</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">console.info(1);</span><br><span class="line">console.debug(1);</span><br><span class="line">console.warn(1);</span><br><span class="line">console.error(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>像百度一样骚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;每一个星球都有一个驱动核心，\n每一种思想都有影响力的种子。\n感受世界的温度，\n年轻的你也能成为改变世界的动力，\n百度珍惜你所有的潜力。\n你的潜力，是改变世界的动力！\n\n&quot;), console.log(&quot;%c百度2022校园招聘简历投递：https://talent.baidu.com/external/baidu/campus.html&quot;, &quot;color:red&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">求求，不要再去console.log一把梭了。</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="console" scheme="http://yaru722.gitee.io/tags/console/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标签页通讯问题</title>
    <link href="http://yaru722.gitee.io/2022/06/08/js%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF/"/>
    <id>http://yaru722.gitee.io/2022/06/08/js%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF/</id>
    <published>2022-06-08T10:49:36.039Z</published>
    <updated>2022-06-08T10:51:27.238Z</updated>
    
    <content type="html"><![CDATA[<h4 id="浏览器中的标签页如何通讯"><a href="#浏览器中的标签页如何通讯" class="headerlink" title="浏览器中的标签页如何通讯"></a>浏览器中的标签页如何通讯</h4><ol><li>标签页必须是同源的页面，必须是同源的页面。</li><li>使用BroadcastChannel。</li></ol><p>例子如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let channel = new BroadcastChannel(&#x27;test&#x27;);</span><br><span class="line">channel.postMessage(&#x27;hello,word&#x27;)</span><br><span class="line">channel.onmessage = (res =&gt; &#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">&#125;)</span><br><span class="line">channel.onmessageerror = (err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例话BroadcastChannel<br>postMessage方法发送数据</p><p>onmessageerror 监听错误信息<br>onmessage 获取消息</p>]]></content>
    
    
    <summary type="html">浏览器标签页进行通讯（同源）</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的Promise</title>
    <link href="http://yaru722.gitee.io/2022/05/30/%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yaru722.gitee.io/2022/05/30/%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</id>
    <published>2022-05-30T14:13:38.581Z</published>
    <updated>2022-05-30T14:16:14.941Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>关于ES6中<strong>promise</strong>的使用，我已经熟练掌握了不少。至少能顺顺利利的写上一个异步方法。<br>但是对promise的理解使用 并没有得到提高。</p><p>比如，有这么一个场景，我需要发送5个接口。拿到5个接口里面的数据，且必须五个接口全部请求完毕，有结果了，我才能拿到。因为接口的响应时间不一样的，而且这个业务里面不想，a接口好了，去请求b接口。而是abcde5个接口一起请求。</p><p>这就是我，重新细读promsie的原因。</p><h5 id="关于promise的特点。"><a href="#关于promise的特点。" class="headerlink" title="关于promise的特点。"></a>关于promise的特点。</h5><ol><li><p>promise有3个状态， pending（进行中），和fulfilled（已成功），和rejected（已失败）。只有异步操作才能决定promise当前是哪一种状态，任何操作都无法改变</p></li><li><p>promsie的状态一旦改变就不可能逆转。比如从pending状态，到rejected状态。这个状态，就会凝固，不会再改变了，这个就称为resolved（已定型）。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">primise-&gt;&gt;fulfilled或rejected:异步操作才能决定promise当前的状态。</span><br><span class="line">fulfilled或rejected-&gt;&gt;primise:状态处于resolved状态凝固不可改变。</span><br></pre></td></tr></table></figure><h5 id="关于promise的一些缺点。"><a href="#关于promise的一些缺点。" class="headerlink" title="关于promise的一些缺点。"></a>关于promise的一些缺点。</h5><ul><li>promise一旦建立就无法取消。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;11&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码里面的log会立刻执行。</p><ul><li>promise异步执行的时候，我们无法知道他在哪一步。</li></ul><h5 id="promise的then"><a href="#promise的then" class="headerlink" title="promise的then"></a>promise的then</h5><p>primise的then方法，能够接受2个回调函数做参数使用。第一个是，当pending状态改变为，fulfilled调用，另一个是pending状态改变为，reject调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(11);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(function (res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="promise-catch-只能接受一个回调函数做参数使用。"><a href="#promise-catch-只能接受一个回调函数做参数使用。" class="headerlink" title="promise catch 只能接受一个回调函数做参数使用。"></a>promise catch 只能接受一个回调函数做参数使用。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(11);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(function (res) &#123;</span><br><span class="line">    console.log(res);//没有打印结果</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="如果promise里面有同步执行的代码呢？？？"><a href="#如果promise里面有同步执行的代码呢？？？" class="headerlink" title="如果promise里面有同步执行的代码呢？？？"></a>如果promise里面有同步执行的代码呢？？？</h5><p>我们可以来看一段代码的执行顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function promise(time) &#123;</span><br><span class="line">    console.log(&#x27;预计执行时间:&#x27;, time / 1000);</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;欢迎来到promise:&#x27;);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;promise结果:resolve&#x27;);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;codeing&#x27;);</span><br><span class="line">promise(3000).then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;执行结束&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正确的执行顺序应该是：</p><ol><li>codeing</li><li>预计执行时间</li><li>欢迎来到promise</li><li>promise结果</li><li>执行结束。</li></ol><p>promise异步操作执行的时候，除了pending 状态发生改变之前，都是同步的代码。<br>当定时器结束，异步操作的状态改变。我们通过then 或者catch来回调promise的结果。</p><p>使用promise异步加载图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function imgaeLoad(src) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let image = new Image();</span><br><span class="line">        image.src = src;</span><br><span class="line">        image.onload = function () &#123;</span><br><span class="line">            resolve(&#x27;succss&#x27;);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = function () &#123;</span><br><span class="line">            reject(&#x27;error&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">imgaeLoad(&#x27;https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/04/26/6267bb50cad26.jpeg&#x27;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="关于promise的异步操作的结果是返回另一个异步操作"><a href="#关于promise的异步操作的结果是返回另一个异步操作" class="headerlink" title="关于promise的异步操作的结果是返回另一个异步操作"></a>关于promise的异步操作的结果是返回另一个异步操作</h5><p>如果调用resolve或者reject函数带有参数，那么参数会被传递到回调函数。<br>reeject通常的参数是new Error的参数实例，无论reslove，还是reject来说，都有可能接受一个promise实例作为参数。</p><p>比如下面这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        reject(new Error(&#x27;fail&#x27;))</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(p1)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>p2的resolve的方法，将p1作为参数，即一个异步操作的结果返回另一个异步操作。</p><p>这个时候p1的状态就会传递给p2，如果p1，在pending，那么p2会等待。直到p1的状态从pending改变到resolved，或者rejectd，这个时候。p2的回调函数会马上执行。。</p><p>白话文就是，如果p2的异步操作把p1作为参数的话。那么p2的回调函数的状态就由p1异步操作来决定。</p><p>再浅一点，p2的异步操作如果把p1作为参数的话。那么p1的异步操作会执行，且他的状态影响着p2回调函数的状态。又或者说p1的状态结果就是p2的。</p><p>对于promise 方法来说，一旦状态从resolved 到 rejectd后。接下来的操作，直接在then，和catch里面操作就行了。</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段方法会导致，即便是promise 状态已经改变了，log方法也还是执行了。所以一旦状态从resolved 到 rejectd后，一定要return出去。</p><h5 id="关于promise的链式调用。"><a href="#关于promise的链式调用。" class="headerlink" title="关于promise的链式调用。"></a>关于promise的链式调用。</h5><p>曾经做过微信服务商入驻哪一块。需要调上传接口，上传图片，然后在上传给图片给微信，然后再去给后端。</p><p>要发送4个请求，其中错了一个之后，就算失败。<br>于是代码就成了这个样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">promiseA().then(()=&gt;&#123;</span><br><span class="line">    promiseB().then(()=&gt;&#123;</span><br><span class="line">            promiseC().then(()=&gt;&#123;</span><br><span class="line">                 promiseD().then(()=&gt;&#123;</span><br><span class="line">        </span><br><span class="line">                &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是promise 是可以使用链式调用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结其他来是，链式调用可以避免回调地狱的产生，你需要then下去就好了。<br>无非就promiseA好了那就去调用promiseB。如果失败了直接在catch捕捉就可以了。</p><p>当然如果promiseA失败了，catch捕捉到的肯定是，promiseA的catch。</p><p>我们只需要在第五个then下面，进行操作就可以了。</p><p>好处是。catch捕捉一次就够了。</p><h5 id="关于promise的catch"><a href="#关于promise的catch" class="headerlink" title="关于promise的catch"></a>关于promise的catch</h5><ol><li>promise的catch具有冒泡性。</li></ol><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段方法会导致，即便是promise 状态已经改变了，log方法也还是执行了。所以一旦状态从resolved 到 rejectd后，一定要return出去。</p><h5 id="关于promise的链式调用。-1"><a href="#关于promise的链式调用。-1" class="headerlink" title="关于promise的链式调用。"></a>关于promise的链式调用。</h5><p>曾经做过微信服务商入驻哪一块。需要调上传接口，上传图片，然后在上传给图片给微信，然后再去给后端。</p><p>要发送4个请求，其中错了一个之后，就算失败。<br>于是代码就成了这个样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">promiseA().then(()=&gt;&#123;</span><br><span class="line">    promiseB().then(()=&gt;&#123;</span><br><span class="line">            promiseC().then(()=&gt;&#123;</span><br><span class="line">                 promiseD().then(()=&gt;&#123;</span><br><span class="line">        </span><br><span class="line">                &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是promise 是可以使用链式调用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不管是say1 到say5promise方法，只要有一个错误都会被catch捕捉到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>且尽可能不要尝试在then方法里面捕捉，错误信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say1().then(function (value) &#123;</span><br><span class="line">    console.log(&#x27;succss&#x27;);</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // failure</span><br><span class="line">    console.log(&#x27;error&#x27;);</span><br><span class="line">&#125;)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>promise方法的任何报错都会导致，promise进入rejected状态，被catch捕捉到错误信息。</p><p>比如我们人为制造一些报错信息。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">        let a;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say1().then(succss =&gt; &#123;</span><br><span class="line">    console.log(succss);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本身promise应该是resolved的。因为报错信息，导致变成rejected，然后被catch捕捉。</p><p>promise 会把报错信息给吞掉。</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function () &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        // 下面一行会报错，因为x没有声明</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">someAsyncThing().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">&#125;, 2000)//11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在promise中如果没有使用catch函数去接受捕捉错误信息的话，promsie对象抛出错误，不会传递到外层的代码。也不会有任何反应。</p><p>在看下个例子，当promise已经结束了，下轮事件循环再抛出错误，这个时候，promise已经执行完毕了，所以这个错误是promise函数体外抛出的，会冒泡到最外层。导致无法捕获该错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let test = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&#x27;succss&#x27;);</span><br><span class="line">    setTimeout(function () &#123; throw new Error(&#x27;test&#x27;) &#125;, 0)</span><br><span class="line">&#125;)</span><br><span class="line">test.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>promise 可以运行catch函数方法，再去运行，then函数方法。如果没有报错会绕过catch，运行then方法指定的回调函数。。</p><p>如果存在报错，catch捕捉错误后继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;errors:&#x27;, error);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    alert(&#x27;11&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>没有报错，catch被绕过，直接执行then。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function p1(x = 1) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;errors:&#x27;, error);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>catch内部也会报错。如果catch报错了，在后面再写一个catch捕获错误信息就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return p1();</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    y + 2;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="promise-finally方法。"><a href="#promise-finally方法。" class="headerlink" title="promise finally方法。"></a>promise finally方法。</h5><p>不管promise的状态如何，他都会执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(0);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;).finally(e =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>then回调函数与finally函数，分别console.log出来了，0和1</p><h5 id="promise-all"><a href="#promise-all" class="headerlink" title="promise all"></a>promise all</h5><p>假设，我是说假设，我们有3个promise方法，p1，p2，p3。<br>让p1，p2，p3，几乎同时发送，p1，p2，p3全部是resloved，那就then回调函数捕获。不然就使用，catch捕获。。</p><p>我们该怎么去写呢。</p><p>这个时候就可以使用promise all来处理。</p><p>例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            resolve(&#x27;p3成功&#x27;);</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1(), p2(), p3()]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise.all（）把p1-p3函数全部放入。</p><p>等到p1-p3函数的promise状态全部都为resovled 或者rejected的话。promise.all的状态是rejected或者resovled</p><p>promise.all的成员可以不是数组，但是必须具有Iterator，且每个成员都是返回了promise实例。</p><p>如果primise.all内的promise实例，catch捕获了错误信息，那么promise.all，的状态不会受rejected的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            reject(new Error(&#x27;p3失败&#x27;));</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1(), p2(), p3().catch(err =&gt; &#123; console.log(err); &#125;)]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//因为p3函数使用catch函数捕获了，报错信息。所以promise.all的 没有捕获到错误，导致还是then回调函数正常使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="promise的race方法。"><a href="#promise的race方法。" class="headerlink" title="promise的race方法。"></a>promise的race方法。</h5><p>promise.race 函数的特点是，假设，我们拥有，p1-p3多个promise函数，如果p2promise方法，状态首先改变了，那么会改变promise.race的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            reject(new Error(12121));</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.race([p1(), p2(), p3()]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和promise.all不同，里面的成员必须是promise实例。promise.race，成员什么参数都可以接收。。</p><p>并且，promise.race()的成员里非primise实例的成员，会立马，触发promise.race的then回调函数。</p><h5 id="promise-race，all的区别。"><a href="#promise-race，all的区别。" class="headerlink" title="promise race，all的区别。"></a>promise race，all的区别。</h5><p>promise all，p1-p4….promise方法，同时执行，全部成功了，会成功，一个失败，那就是失败咯，all方法的成员不一定非得是数组，但是一定要有，有Iterator接口。</p><p>promise race，p1-p4…..promise方法，promis.race的实例的状态是，p1-p4promise函数中那个函数的结果改变了，那么改变的状态就是promise.race的状态。</p><h5 id="promise-allSettled方法。"><a href="#promise-allSettled方法。" class="headerlink" title="promise allSettled方法。"></a>promise allSettled方法。</h5><p>假设，我们有p1-p4，4个promise实例，不管成功与否，我都想让他走完，又或者（等待所有的promise实例，全部结束），再去做一些操作。</p><p>promise.all的前提是，p1-p4实例，必须要走完，才能进行操作，如果但凡有个失败，那就直接报错，不管另外的promise是否结束。。</p><p>alisettled不是这样的，promise多个实例，都会执行，并且全部执行结束了promise.allsettled的promise状态才改变，并且then回调函数下面，我们会拿到所有promise的结果，以对象的形式</p><h5 id="关于promise的any"><a href="#关于promise的any" class="headerlink" title="关于promise的any"></a>关于promise的any</h5><p>与promise，reac函数不同的是，reac，在promise实例当中，找到最快响应的实例，</p><p>promise，any，找到最快响应的实例，必须得是，resovled，状态的。</p><p>p1-p4，4个promise实例，是promise，any的成员。<br>p1-p4，最快执行完毕，且实例本身，是resolved的，成为any的状态。<br>假设p1-p4全部rejected的话，那么，就得使用catch去捕获异常。。</p><p>p1-p4，只要有一个resolved，那就算成功了。</p><h5 id="关于promise-try"><a href="#关于promise-try" class="headerlink" title="关于promise try"></a>关于promise try</h5><p>关于promise的执行顺序。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(0);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印的顺序居然是，1 0；</p><p>因为promise是异步函数，除非你给他做一个匿名立即执行函数。绕过去。不然的话。</p><p>可是我们即想要使用，promise函数，但也没有什么，异步操作。。。</p><p>这个时候，promise，try就诞生了。</p><p>promise try文档不全，最新还没有进行适配。后面补上。。</p><h5 id="关于promise-resolve。"><a href="#关于promise-resolve。" class="headerlink" title="关于promise resolve。"></a>关于promise resolve。</h5><ol><li>primise resolve，可以将一个对象转换为，promise方法。</li></ol><p>promise.resolve等于 new prmise((resolve,reject)=&gt;{});</p><p>例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let object = &#123;</span><br><span class="line">    name: 111,</span><br><span class="line">    age: &#x27;12&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Promise.resolve(object);</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res.name)//111</span><br><span class="line">&#125;)</span><br><span class="line">console.log(p1)//Promise &#123;&lt;fulfilled&gt;: &#123;…&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功的把一个promise例子转换为，真实的例子。</p><p>primise.resolve()的参数有四种。</p><p>resolve()的参数是一个promise实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(12121);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Promise.resolve(p3())</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//12121</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>promise.resolve参数返回的还是promise实例。。</p><p>resolve(),thenable，参数。<br>thenable对象，指的是具有，then方法的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(&#123;</span><br><span class="line">    then: () =&gt; &#123;</span><br><span class="line">        console.log(11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//11</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>resolve,then对象调用执行后，对象p1的状态就回变为resolved。</p><p>参数不是具有then()方法的对象，或根本就不是对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(&#x27;11&#x27;)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//11</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为hello不属于一步操作，返回promise的实例状态从医生称就是resloved，所以回调函数立即执行。<br>同时会传给回调函数。。</p><p>如果promise.resolved,不带参数。那么直接返回resolved状态的promise对象。</p><p>立即执行的promise对象，是在本轮事件循环结束时执行，而不是在下一轮事件循环开始时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(0)</span><br><span class="line">let p1 = Promise.resolve(1)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;, 0)</span><br><span class="line">// 0 1 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="promise-reject"><a href="#promise-reject" class="headerlink" title="promise.reject(),"></a>promise.reject(),</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">p1.catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">/**</span><br><span class="line"> * Promise.reject(&#x27;出错了&#x27;) === new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line"> * reject</span><br><span class="line"> * &#125;)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">今天总算耐着性子吧，阮一峰大佬的ES6的Promise认认真真的过了一遍，有些心得体会</summary>
    
    
    
    <category term="ES6" scheme="http://yaru722.gitee.io/categories/ES6/"/>
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>js中的包管理器</title>
    <link href="http://yaru722.gitee.io/2022/04/14/%E5%85%B3%E4%BA%8Enpm%E4%B8%8Eyran%E5%92%8Ccnpm%E5%8C%85%E6%8B%ACpnpm%E3%80%82/"/>
    <id>http://yaru722.gitee.io/2022/04/14/%E5%85%B3%E4%BA%8Enpm%E4%B8%8Eyran%E5%92%8Ccnpm%E5%8C%85%E6%8B%ACpnpm%E3%80%82/</id>
    <published>2022-04-14T06:41:25.017Z</published>
    <updated>2022-04-14T06:42:43.945Z</updated>
    
    <content type="html"><![CDATA[<ol><li>npm早起pages.json来确定node_modules依赖树关系，而且众所周知的原因，慢。v5版本之后多了，package-lock.json文件，锁定了依赖的版本，保证我们每次都能下到正确版本的依赖。</li><li>yran性能好，体积会小一些。早起的时候npm没有package-look.json。</li><li>pnpm超级快，体积小，掘金社区，说依赖少一些，不稳定。没有声明使用的依赖，好想存在一些问题。观望。</li><li>前端项目当中，一定要保持node版本，和包管理器的版本一致。</li></ol>]]></content>
    
    
    <summary type="html">js中的包管理器</summary>
    
    
    
    <category term="js" scheme="http://yaru722.gitee.io/categories/js/"/>
    
    
    <category term="js" scheme="http://yaru722.gitee.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript闭包（Closure）</title>
    <link href="http://yaru722.gitee.io/2022/04/14/%E5%AD%A6%E4%B9%A0Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/"/>
    <id>http://yaru722.gitee.io/2022/04/14/%E5%AD%A6%E4%B9%A0Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/</id>
    <published>2022-04-14T06:38:37.809Z</published>
    <updated>2022-04-14T06:40:45.499Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。"><a href="#在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。" class="headerlink" title="在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。"></a>在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。</h5><p>不bb上代码！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = 0;</span><br><span class="line">function parent() &#123;</span><br><span class="line">    var b = 1;</span><br><span class="line">    console.log(a, b);</span><br><span class="line">    function son() &#123;</span><br><span class="line">        var c = 2;</span><br><span class="line">        console.log(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">parent();</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><ol><li>我们可以在任何地方访问变量，全局变量a。</li><li>局部变量，b，c，parent函数，只能访问到局部变量，b。son函数的作用域变量，parent无法访问。</li><li>son函数，访问，a，b，c变量的过程就是一个完整的作用域链。是一个向上的过程。</li></ol><p>通俗的语言表达，son作用域就是一个鱼缸，parent作用域是一个池塘。son可以通过吸管来抽取parent作用域的水（变量）;</p><h5 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h5><p>闭包问题，让池塘拿出吸管来抽取鱼缸的水（变量）的过程。</p><p><strong>所以，如何在外部访问函数内部的变量呢？</strong></p><p>看个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line">let val = parent();</span><br><span class="line">console.log(val);//0</span><br></pre></td></tr></table></figure><p>这里我们把parent函数直接return出去，就拿到了内部变量了，吗？</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    ++num;</span><br><span class="line">    console.log(num);</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line">parent();//1</span><br><span class="line">parent();//1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们执行了，2次parent函数，log打印出来的只有1，1。<br>函数的内部变量为什么只做了一次自增就就没有了呢？？？？</p><p>这里不得不谈的js的执行机制问题。</p><p>太复杂的不想谈，parnt方法执行完毕之后，整个方法，连变量都被回收了，num变量值只拿到了自增一次后的，parnt函数的返回值。</p><p>可以把js执行理解为一个机器，parent执行，回收掉。返回值1，parent执行，回收掉返回值1。</p><h5 id="如何得到一个闭包呢？"><a href="#如何得到一个闭包呢？" class="headerlink" title="如何得到一个闭包呢？"></a>如何得到一个闭包呢？</h5><p>我们可以看看闭包需要达成的条件。</p><ol><li>外部函数能够访问，内部函数的变量。</li><li>内部的变量可以一直存在内存里面，不会被js的垃圾回收机制回收掉。</li></ol><h6 id="如何在外部访问部分的函数变量。"><a href="#如何在外部访问部分的函数变量。" class="headerlink" title="如何在外部访问部分的函数变量。"></a>如何在外部访问部分的函数变量。</h6><p>在函数内部在创建一个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    son();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>son有权利访问，parent内部的所有变量。那么我们如果把son函数当作返回值，在外部不就能拿到，函数内部的变量了吗。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">val();//0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这个例子，只能证明，外部函数可以访问得到parent函数的内部。可是函数内部的变量，有没有被垃圾回收，下面这个例子就能证明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    add = function () &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    minus = function () &#123;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">minus();</span><br><span class="line">val();//2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在函数内部，声明了2个全局变量方法。一个做自增，一个做自减。</p><p>还有一个例子也能证明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        num: 0</span><br><span class="line">    &#125;;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">var c1 = val();</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">console.log(c1.num, val());//6,6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cl.num 与函数内部的变量完全相等。<br>son函数就是 闭包。在parent函数内部，通过return，与外部函数建立一条通道。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>闭包就是外部函数访问内部函数变量，且函数内部的变量一直在内存里得到保留，不会被垃圾回收。</p><p>产生闭包的原因是，因为，外部函数引用了函数内部的函数，导致不会进行垃圾回收，变量得到了保留。</p><p>这就是函数内部建立函数，return函数内部给外部函数的原因。</p><h5 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h5><ol><li>因为闭包函数内部的变量不会被垃圾回收，需要小心内存泄漏。</li><li>闭包让我们有了访问函数内部变量的权利，但是不要轻易去修改函数内部的值。</li></ol><h5 id="阮一峰大佬的思考题"><a href="#阮一峰大佬的思考题" class="headerlink" title="阮一峰大佬的思考题"></a>阮一峰大佬的思考题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">　　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that = this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一个结果是，The Window”原因是因为，this的指向问题，return funtion是一个匿名函数，匿名函数默认指向window。</p><p>第二个结果是，My Object”原因是因为，getNameFunc，在obect下面，this自然而然就指向object。这个时候把this指针所谓变量，给了匿名函数。return的时候，this自然而然指向了objet，所以访问到name。</p>]]></content>
    
    
    <summary type="html">把js中的闭包搞清楚</summary>
    
    
    
    <category term="css" scheme="http://yaru722.gitee.io/categories/css/"/>
    
    
    <category term="九宫格" scheme="http://yaru722.gitee.io/tags/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>js中的new操作符</title>
    <link href="http://yaru722.gitee.io/2022/01/23/javascript%E4%B8%AD%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yaru722.gitee.io/2022/01/23/javascript%E4%B8%AD%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/</id>
    <published>2022-01-23T10:29:42.593Z</published>
    <updated>2022-04-14T06:45:30.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new操作符有什么用？"><a href="#new操作符有什么用？" class="headerlink" title="new操作符有什么用？"></a>new操作符有什么用？</h4><h5 id="试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。"><a href="#试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。" class="headerlink" title="试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。"></a>试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(&#123;</span><br><span class="line">        id: index,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">        run: function () &#123;</span><br><span class="line">            console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">arr[0].run();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>100个士兵，我们生成了，但是，这样这样，既不优雅，对性能也是一种极大的浪费。</p><h5 id="可不可以再优雅一点。"><a href="#可不可以再优雅一点。" class="headerlink" title="可不可以再优雅一点。"></a>可不可以再优雅一点。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//士兵原型</span><br><span class="line">var model = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    //创建一个临时对象</span><br><span class="line">    let object = &#123;</span><br><span class="line">        id: index,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">    &#125;</span><br><span class="line">    object.__proto__ = model;</span><br><span class="line">    arr.push(object)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr[0].run();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们创建了一个原型对象 通过object的proto指向士兵的原型。</p><h5 id="还能不能更优雅一点，原型与对象在2个地方。"><a href="#还能不能更优雅一点，原型与对象在2个地方。" class="headerlink" title="还能不能更优雅一点，原型与对象在2个地方。"></a>还能不能更优雅一点，原型与对象在2个地方。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//士兵原型</span><br><span class="line">var model = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//更优雅的方式</span><br><span class="line"></span><br><span class="line">function Cat(id) &#123;</span><br><span class="line">    let object = &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">    &#125;</span><br><span class="line">    object.__proto__ = model;</span><br><span class="line">    return object;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(Cat(index))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr, arr[0].run());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/75NzLt"><img src="https://s4.ax1x.com/2022/01/23/75NzLt.jpg" alt="代码演示.jpg"></a></p><p>使用 new来实现一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//士兵们</span><br><span class="line">let arr = [];</span><br><span class="line">function Soldier(id) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.hp = Math.floor(Math.random() * (100 - 0)) + 0;</span><br><span class="line">&#125;</span><br><span class="line">Soldier.prototype.run = function () &#123;</span><br><span class="line">    console.log(`$&#123;this.id&#125;号士兵在逃跑`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实例化</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(new Soldier(index))</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr, arr[80].run());</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先实例化过程中创建了一个对象。</li><li>给对象添加proto，然后new自动找到了构造函数的原型并且把原型链接到了对象proto。</li><li>this做实例化的对象的上下文。</li><li>如果该函数没有返回对象，返回this。</li></ul><p>这就是new操作符的作用。<br><a href="https://zhuanlan.zhihu.com/p/23987456">参考文章</a></p>]]></content>
    
    
    <summary type="html">new操作符做干了什么</summary>
    
    
    
    <category term="js" scheme="http://yaru722.gitee.io/categories/js/"/>
    
    
    <category term="js" scheme="http://yaru722.gitee.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于js中的apply bind call的使用</title>
    <link href="http://yaru722.gitee.io/2022/01/20/%E5%85%B3%E4%BA%8Ethis%E7%9A%84call%EF%BC%8Capply%EF%BC%8Cbind%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yaru722.gitee.io/2022/01/20/%E5%85%B3%E4%BA%8Ethis%E7%9A%84call%EF%BC%8Capply%EF%BC%8Cbind%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-20T14:08:20.453Z</published>
    <updated>2022-01-20T14:11:54.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="this到底指向哪里。"><a href="#this到底指向哪里。" class="headerlink" title="this到底指向哪里。"></a>this到底指向哪里。</h4><p>事实上，this基本上指向最后调用他的对象。谁最后调用了this，this最终就指向哪里。（虽然会存在着，隐式调用的时候，this就变成了默认）</p><h4 id="而apply-call-与-bind-，可以改变this的指向。"><a href="#而apply-call-与-bind-，可以改变this的指向。" class="headerlink" title="而apply call 与 bind ，可以改变this的指向。"></a>而apply call 与 bind ，可以改变this的指向。</h4><p>例子如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi();//芳芳</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>我们需要让sayHi方法的this指向parson</strong></p><p>例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi.call(parson)//李四</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用apply 也可以改变指向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi.apply(parson)//李四</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="apply-与-call-的区别。"><a href="#apply-与-call-的区别。" class="headerlink" title="apply 与 call 的区别。"></a>apply 与 call 的区别。</h5><p>apply 和call的第一个参数都是，制定this的指向。第二次参数都是要传递进入的参数。不同的是 apply方法必须要制定一个数组作为参数传入，而，call则不是。</p><p>例子如下，，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi(a, b) &#123;</span><br><span class="line">    console.log(this.val + a + b);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    val: 10,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sayHi.call(parson, 1, 2);</span><br><span class="line">sayHi.apply(parson, [1, 2,]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不管是apply 与call 方法都指向了 parson，且，只不过apply参数传递必须是个数组。</p><p>bind 与 apply 和call不同的地方在于。</p><table><thead><tr><th>属性</th><th>执行</th><th>返回</th></tr></thead><tbody><tr><td>apply</td><td>改变函数的this上下文后马上执行函数</td><td>返回fun的执行结果</td></tr><tr><td>bind</td><td>返回函数改变了上下文的函数不马上执行</td><td>返回fun的拷贝，并指定了this的指向，保存函数的参数。</td></tr></tbody></table><p>关于apply 的一些妙用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 21, 21, 31, 32, 32, 12121, 21];</span><br><span class="line">let max = Math.max.apply(Math, arr);</span><br><span class="line">let min = Math.min.apply(Math, arr)</span><br><span class="line">console.log(max, min);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于如果显式的绑定this</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="改变this的指向" scheme="http://yaru722.gitee.io/tags/%E6%94%B9%E5%8F%98this%E7%9A%84%E6%8C%87%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>reduce解决商品sku算法问题</title>
    <link href="http://yaru722.gitee.io/2022/01/10/reduce%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81sku%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/"/>
    <id>http://yaru722.gitee.io/2022/01/10/reduce%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81sku%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-10T11:15:02.487Z</published>
    <updated>2022-01-10T11:17:13.864Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sku问题。"><a href="#sku问题。" class="headerlink" title="sku问题。"></a>sku问题。</h4><p>找到了一个数组方法 特别适合计算sku。</p><p>就是js中的reduce方法。</p><p>关于reduce方法的四个参数。<br>Accumulator (acc) (累计器)<br>Current Value (cur) (当前值)<br>Current Index (idx) (当前索引)<br>Source Array (src) (源数组)<br>initialValue（初始值）</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>accmulator</td><td>累加器（如果设置有初始值的话，第一次是初始值的参数，没有初始值，返回上次回调函数的结果）</td></tr><tr><td>Current Value</td><td>当前的值</td></tr><tr><td>Current Index</td><td>当前下标</td></tr><tr><td>Source Array</td><td>源数组</td></tr><tr><td>initialValue</td><td>默认值</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var arr = [[&#x27;s&#x27;, &#x27;m&#x27;, &#x27;x&#x27;, &#x27;l&#x27;, &#x27;xl&#x27;], [&#x27; T恤&#x27;, &#x27;裤子&#x27;, &#x27;裙子&#x27;], [&#x27;蓝色&#x27;, &#x27;白色&#x27;], [&#x27;nike&#x27;, &#x27;安踏&#x27;, &#x27;李宁&#x27;]];</span><br><span class="line">console.log(...arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    pre.forEach(item =&gt; &#123;</span><br><span class="line">        cur.forEach(items =&gt; &#123;</span><br><span class="line">            res.push(item.concat(items));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;, [[]]));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码需要理解的地方在于，第一遍的时候因为设置了默认值，[[]],所以第一次遍历到的是一个空数组。第二次再去遍历的时候 <strong>此时</strong>，当前值已经T恤xxx什么的了，所以第二次，我们遍历pre数组，合并cur数组就可以了。</p><p>reduce方法。。</p><p>这样sku问题就解决了</p><h5 id="reduce其他妙用。"><a href="#reduce其他妙用。" class="headerlink" title="reduce其他妙用。"></a>reduce其他妙用。</h5><h6 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr = [12, 3, 31, 21, 21, , 31, 31];</span><br><span class="line"></span><br><span class="line">console.log(arr.reduce((per, cur) =&gt; &#123;</span><br><span class="line">    return per + cur</span><br><span class="line">&#125;));//150</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="reduce-计算数组中每个元素出现的次数"><a href="#reduce-计算数组中每个元素出现的次数" class="headerlink" title="reduce 计算数组中每个元素出现的次数"></a>reduce 计算数组中每个元素出现的次数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Tiff&#x27;, &#x27;Bruce&#x27;, &#x27;Alice&#x27;];</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    return names.reduce((allNames, name) =&gt; &#123;</span><br><span class="line">        if (name in allNames) &#123;</span><br><span class="line">            allNames[name]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            allNames[name] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return allNames;</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(names));</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">商品规格sku算法问题</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="http://yaru722.gitee.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>includes</title>
    <link href="http://yaru722.gitee.io/2022/01/10/includes/"/>
    <id>http://yaru722.gitee.io/2022/01/10/includes/</id>
    <published>2022-01-10T11:11:35.014Z</published>
    <updated>2022-01-10T11:18:28.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于ES6-include的使用方法。"><a href="#关于ES6-include的使用方法。" class="headerlink" title="关于ES6-include的使用方法。"></a>关于ES6-include的使用方法。</h4><p>场景，和后端同学调试接口的时候，后端同学很喜欢返回我，status，或者type来给我判断。但是，，，如果状态多的话，那么判断可能是这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let status = 0;</span><br><span class="line"></span><br><span class="line">if (status == 1 || status == 2 || status == 3) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说实话这样写一点都不优雅。但是还能接受。毕竟 1 2 3，还好判断。</p><p>场景，后端同学又过来，接口要改，status可能要多判断2个值，4，5。4是进行中，5是已售后，或者叫啥都行。</p><p><a href="https://imgtu.com/i/7VEMdI"><img src="https://s4.ax1x.com/2022/01/10/7VEMdI.jpg" alt="7VEMdI.jpg"></a></p><p>接下来，我们的代码就是这样。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let status = 5;</span><br><span class="line"></span><br><span class="line">if (status == 1 || status == 2 || status == 3 || status == 4 || status == 5) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即便后端哥们不再过来改接口，添加状态。你也觉得这段代码不妥了把。</p><p>includes方法就可以完美解决这个问题。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let status = 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5];</span><br><span class="line">if (arr.includes(status)) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>includes</strong>会找数组的成员，找到了就是true，找不到就是false。</p><p>可可可，有indexof，呀。为什么要使用includes。</p><p>的确。indexof能实现这个问题。。</p><p>可是，如果数组里面存在NaN呢。indexof是否还能找得到？</p><p>例子如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let status = NaN;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, NaN, null];</span><br><span class="line">if (arr.indexOf(status) != -1) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>alert 出来到是 no。</p><p>而，includes就不会存在这样到问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let status = NaN;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, NaN, null];</span><br><span class="line">if (arr.includes(status)) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>indexof 无法在数组内定位到，NaN的位置。</p><p>结论如下，NaN无敌可能会存在数组的情况下，使用includes。</p>]]></content>
    
    
    <summary type="html">关于ES6，includes</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="http://yaru722.gitee.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>阅读红宝书js中的变量</title>
    <link href="http://yaru722.gitee.io/2021/11/25/%E9%98%85%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%8F%98%E9%87%8F/"/>
    <id>http://yaru722.gitee.io/2021/11/25/%E9%98%85%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%8F%98%E9%87%8F/</id>
    <published>2021-11-25T01:19:27.680Z</published>
    <updated>2021-11-25T01:20:30.315Z</updated>
    
    <content type="html"><![CDATA[<h5 id="var是什么。"><a href="#var是什么。" class="headerlink" title="var是什么。"></a>var是什么。</h5><p>1.js中的操作符，声明一个函数级的变量。<br>2.会存在变量提升的情况。</p><h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">var a = 11;//undefined</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为，变量提升到了最上面，所以虽然没有声明变量a，但是a变量被提到了最前面。</p><p>小知识，声明未使用的变量，默刃值是undefined。</p><h6 id="例子2，在函数里面"><a href="#例子2，在函数里面" class="headerlink" title="例子2，在函数里面"></a>例子2，在函数里面</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a;//undefined</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样也是变量被声明了。</p><p>我在变量提升上面的理解走错了路。声明变量，变量的默认中undefined，所谓的变量提升，就是声明的变量提升。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 11;</span><br><span class="line">代码等于 </span><br><span class="line">var a;</span><br><span class="line">a = 11;</span><br></pre></td></tr></table></figure><h6 id="let，块级作用域"><a href="#let，块级作用域" class="headerlink" title="let，块级作用域"></a>let，块级作用域</h6><p>1.何谓块级作用域啊。<br><code>&#123;&#125;</code><br>指的是只在代码块里有效。</p><p>2.最大的特点是没有变量提升。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * error  index.js:20 Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br><span class="line">    at index.js:20</span><br><span class="line"> * </span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">let a = 11;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不可以先使用！后声明变量。必须得先声明。因为没有变量提升！！！<br>因为let 声明执行的瞬间会存在一个暂缓性死区，不允许先使用后声明。</p><h6 id="3-可否重复声明？？"><a href="#3-可否重复声明？？" class="headerlink" title="3.可否重复声明？？"></a>3.可否重复声明？？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var a = 11;</span><br><span class="line">var a = 12;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//众所周知，var变量的缺点是提升，与重复声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a = 11;</span><br><span class="line">let a = 12;</span><br><span class="line">console.log(a);//error Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let 在同一作用域下,不允许重复声明。</p><h6 id="关于全局声明。"><a href="#关于全局声明。" class="headerlink" title="关于全局声明。"></a>关于全局声明。</h6><p>var 声明的变量会成为window对象的属性。但是let在全局声明则不然。  </p><p>举个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//全局声明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let a = 11;</span><br><span class="line">console.log(window.a);undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="let-是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。"><a href="#let-是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。" class="headerlink" title="let 是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。"></a>let 是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。</h5><p>举个例子。</p><p>a.js文件里面的代码</p><p>`<br>let a = 11;</p><p>`<br>b.js文件的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// let a = 12;</span><br><span class="line">//条件声明不是一个好的方式。</span><br><span class="line">if (typeof (a) == &#x27;number&#x27;) &#123;</span><br><span class="line">    // 块级作用域下的let 声明的变量a ，无法检测前面有没有同名的变量。也无法在没有什么声明之前使用a。</span><br><span class="line">    let a = 12;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">//此处变量a，是a.js文件下声明的变量a，因为这个变量a是在全局作用域声明的变量。</span><br><span class="line">a = 13;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于js为什么做模块化的。就是因为上面的代码太乱了，都在一个html页面下，依赖于上下关系，而且能够很轻松的访问到全局作用域洗面的全局变量。所以很容易出现变量泄漏的问题。</p><p>且很难理清楚代码的关系。</p><h5 id="在for循环中声明let。"><a href="#在for循环中声明let。" class="headerlink" title="在for循环中声明let。"></a>在for循环中声明let。</h5><p>举个例子，因为for循环中，var 声明的变量会渗透出去。所以let声明的变量只会在代码块中存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt; 3; ++i) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//在这里我们能轻松访问到i</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//如果使用let声明的话则不会。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">for (let i = 1; i &lt; 3; ++i) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//index.js:6 Uncaught ReferenceError: i is not definedat index.js:6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//陷入的误区。</p><p>因为之前习惯使用 var来声明变量，搞不清楚为什么for循环后，var声明的变量比，<br>之前的代码多了1。</p><p>我tm就是脑子不好使，是个傻逼。let是块级作用域当然没这个问题了。</p><p>在js的for循环中只有失败了，才会停止。</p><p>总结，var会变量提升，在for循环中会导致变量渗透。var可以多次被声明，var 任何版本都可以使用。变量都默认值数undefined。<br>var 在windows作为属性。</p><p>let 没有变量提升，因为声明瞬间会暂缓性死区，let必须先声明后使用，在同块级作用域下let 变量不能重复声明。lef使用for循环不会泄漏变量。别使用条件声明let 同名变量。let不在window作为属性。</p><p>for循环只有失败都时候会终止。</p><p>最重要的知识点是弄清楚了for循环失败结束，太蠢了我。和上古时期的前端开发者的苦恼，没有模块化之前很容易全局变量污染。不易维护。</p><p>感同身受。</p>]]></content>
    
    
    <summary type="html">关键字 var let const</summary>
    
    
    
    <category term="css" scheme="http://yaru722.gitee.io/categories/css/"/>
    
    
    <category term="九宫格" scheme="http://yaru722.gitee.io/tags/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>2021年11月22日日报</title>
    <link href="http://yaru722.gitee.io/2021/11/23/2021%E5%B9%B411%E6%9C%8822%E6%97%A5%E6%97%A5%E6%8A%A5/"/>
    <id>http://yaru722.gitee.io/2021/11/23/2021%E5%B9%B411%E6%9C%8822%E6%97%A5%E6%97%A5%E6%8A%A5/</id>
    <published>2021-11-23T12:58:53.124Z</published>
    <updated>2021-11-23T12:59:29.201Z</updated>
    
    <content type="html"><![CDATA[<h4 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h4><h5 id="看js的红宝书"><a href="#看js的红宝书" class="headerlink" title="看js的红宝书"></a>看js的红宝书</h5><p>标识符<br>js中的标识符指的是，变量，属性，方法。最好使用小驼峰写法（首字母小写），标识符开头必须是字母或者_下划线，或者美元符号$来表示。</p><p>语句<br>{}来表示代码块，那怕就一句，;号表示语句的结束，如果不写分号也许。只不过js引擎会解析都时候带上，对性能不好。<br>最好使用控制语句来控制代码块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(true)</span><br><span class="line">log(&#x27;坏的写法&#x27;)</span><br><span class="line"></span><br><span class="line">if(ture)&#123;</span><br><span class="line">    log(&#x27;好的写法&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>es6之后才加了let 与const，任何版本变量都可以使用var 声明。<br>var 自带变量提升。</p><p>关键字是js中定义好的东西，不可以声明为标识符。保留字是不是关键字的关键字。下个版本也许就是关键字了。</p><h5 id="商城项目"><a href="#商城项目" class="headerlink" title="商城项目"></a>商城项目</h5><p>瀑布流的数据push入数组里面，这个时候转成josn字符串再转出来。</p><p>uniapp编译的时候存在问题。（猜测）</p><p>写分页的时候，上拉加载的时候就做判断。</p><h5 id="催宋哥工厂图"><a href="#催宋哥工厂图" class="headerlink" title="催宋哥工厂图"></a>催宋哥工厂图</h5><h4 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h4><p>尽快结束商城<br>给爸爸打电话<br>找媳妇聊天。<br>恢复状态<br>减肥。</p><h5 id="心得。"><a href="#心得。" class="headerlink" title="心得。"></a>心得。</h5><p>调整状态，多学习。经验。勤为径。</p>]]></content>
    
    
    <summary type="html">巩固印象</summary>
    
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端常用的单位和计算说明</title>
    <link href="http://yaru722.gitee.io/2021/10/24/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E4%BD%8D%E5%92%8C%E8%AE%A1%E7%AE%97%E8%AF%B4%E6%98%8E/"/>
    <id>http://yaru722.gitee.io/2021/10/24/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E4%BD%8D%E5%92%8C%E8%AE%A1%E7%AE%97%E8%AF%B4%E6%98%8E/</id>
    <published>2021-10-24T11:13:02.000Z</published>
    <updated>2021-10-24T11:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>单位</th><th>特性</th></tr></thead><tbody><tr><td>px</td><td>相对长度单位</td></tr><tr><td>pt</td><td>绝对单位</td></tr><tr><td>rem</td><td>相对单位</td></tr><tr><td>em</td><td>相对单位</td></tr><tr><td>upx</td><td>uniapp主动放弃了</td></tr><tr><td>rpx</td><td>相对单位-动态宽度单位</td></tr><tr><td>vw</td><td>相对单位</td></tr><tr><td>vh</td><td>相对单位</td></tr><tr><td>vmin</td><td>相对单位，屏幕宽高相对较小的那个。</td></tr><tr><td>vmax</td><td>相对单位，屏幕宽高相对较大的那个。</td></tr></tbody></table><h4 id="关于px"><a href="#关于px" class="headerlink" title="关于px"></a>关于px</h4><p>1.px,是一块屏幕能展示能显示最小的像素点。<br>2.px是一个相对的绝对单位。相对指的是 都是屏幕,但是1px在不同屏幕上可能展示的大小不一样。  A屏幕的1px的长度也许会大于B屏幕的1px。</p><p>3.但是在网页设计中，A屏幕分辨率 300x300px  B屏幕 600x600px，各设一个width 2px，height 2px的盒子。他们大小会是一样的。</p><p>因为浏览器，在A屏幕是 1px 也许只是1个像素点。但是 B屏幕这样的高清屏幕，1px也许就是 2个像素点来表示1px。所以就是屏幕像素密度存在差异，但是会在浏览器会经过逻辑计算。这就是绝对。</p><h4 id="关于pt"><a href="#关于pt" class="headerlink" title="关于pt"></a>关于pt</h4><p>印刷行业表示字体的单位， 1/72英寸。绝对单位。<br>计算公式等于 100px * 4/3</p><h4 id="关于rem单位。"><a href="#关于rem单位。" class="headerlink" title="关于rem单位。"></a>关于rem单位。</h4><p>htlm根元素字体大小。 1rem 等于16px</p><h4 id="关于em-单位"><a href="#关于em-单位" class="headerlink" title="关于em 单位"></a>关于em 单位</h4><p>我对em单位超级超级陌生。培训班大师兄跟我说 国外喜欢用em作为字体大小来使用。<br>但是国内没必要，选择rem或者px就行了。</p><p>今天写这篇博客的时候，看到这篇文章<a href="https://jorux.com/archives/95-websites-of-china-need-to-rewrite-css/">。95%的中国网站需要重写CSS</a></p><p>由于ie浏览器的内核不支持调整网站px字体的大小。所以国外都使用了em作为web网站的字体单位。</p><p>但是国内没有这样去做。以至于今天，ie已经成为会议了。</p><p>那么em单位是什么呢。</p><p>em的值不是固定的，em会继承父级字体的大小。</p><h4 id="rpx单位。"><a href="#rpx单位。" class="headerlink" title="rpx单位。"></a>rpx单位。</h4><p>uniapp 针对屏幕的宽度会动态调整的单位。<br>计算规则如下，2px == 4rpx</p><p>设计稿 * A元素的px / 750 就是rpx。</p><p>设计稿 * 页面测试的元素宽度 / 设计稿基准宽度。</p><p>通常1px 等于2rpx</p><h4 id="vw-和-vh单位。"><a href="#vw-和-vh单位。" class="headerlink" title="vw 和 vh单位。"></a>vw 和 vh单位。</h4><p>vw 是视口的宽度 vh是视口的高度</p><p>vw 等于 视口的1%。<br>也是相对单位</p><p>1920 * 1080 1vw 等于 1920 / 100% 19.2px。</p><h4 id="vmax-与vmin。"><a href="#vmax-与vmin。" class="headerlink" title="vmax 与vmin。"></a>vmax 与vmin。</h4><p>vmax vmin 针对与我们字体 比如，我们手机从竖屏来到横屏。vw 和vh会发生变化。</p><p>vmax vmin 一个是取vw 和vh 最大的值，一个是取最小的值。</p><p>ps：写此篇博客是为了和ui撕逼。</p>]]></content>
    
    
    <summary type="html">ui图,750pt,我直呼好家伙,ui我跟你拼了。对前端常用的单位扫盲</summary>
    
    
    
    <category term="css" scheme="http://yaru722.gitee.io/categories/css/"/>
    
    
    <category term="css常用单位" scheme="http://yaru722.gitee.io/tags/css%E5%B8%B8%E7%94%A8%E5%8D%95%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>2021年9月7日日报</title>
    <link href="http://yaru722.gitee.io/2021/09/07/2021%E5%B9%B49%E6%9C%887%E6%97%A5%E6%97%A5%E6%8A%A5/"/>
    <id>http://yaru722.gitee.io/2021/09/07/2021%E5%B9%B49%E6%9C%887%E6%97%A5%E6%97%A5%E6%8A%A5/</id>
    <published>2021-09-07T13:21:22.000Z</published>
    <updated>2021-09-07T13:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><p>1.写秒杀专区。<br>2.找春鹏对接。<br>3.帮樊解决上传的问题。  </p><h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><p>1.秒杀专区欠支付成功页面。<br>2.小程序导航栏。<br>3.开碰头会。  </p><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1.使用vuex，不顺手。<br>2.父组件的子组件的组件库组件的样式不能在子组件修改。<br>3.上传formdata。</p><h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><p>1.父组件的子组件的组件库组件的样式不能在子组件修改<br>解决方法。在父组件 /deep/.子组件.ui库组件。</p><p>这一块需要在看看。</p><p>2.vuex的使用。和组件的运用。</p><h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ol><li>给家人打电话。</li><li>减肥</li><li>焦躁</li></ol>]]></content>
    
    
    <summary type="html">巩固印象</summary>
    
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git团队协作</title>
    <link href="http://yaru722.gitee.io/2021/09/02/git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    <id>http://yaru722.gitee.io/2021/09/02/git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</id>
    <published>2021-09-02T13:03:42.000Z</published>
    <updated>2021-09-02T13:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>客驾到的时候，我使用了breach，来进行分支管控。<br>dev分支用来开发。master用来合并。</p><p>如果我和A君一起开发的话，我俩一起在一个dev分支下进行开发。然后去master进行合并。<br>春鹏告诉我，我们可以一人一个分支去玩的。一起往master上面合并。我意识到我对breach 的使用略显不足，所以补充一下我的理解。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>客驾到项目中，我想的更多的是 ，想通过分支来做一个<strong>沙盒</strong>。进行<strong>隔绝</strong>。<br>去进行<strong>区分</strong>。</p><p>但是，分支给我带来的体验并不好，因为2个人使用一个分支，我与A君，我们两个人之间，没有沙盒。</p><p>如果这个时候 B君也参与了进来，我们三个人，使用一个dev分支。超级容易打架。</p><h4 id="多分支开发。"><a href="#多分支开发。" class="headerlink" title="多分支开发。"></a>多分支开发。</h4><p>标准团队协作模式下进行开发。</p><p>应该有这样的分支。</p><p><strong>master</strong>  <strong>hotfix</strong> <strong>develop</strong> <strong>feature</strong> <strong>release</strong></p><table><thead><tr><th>分支名</th><th>用途</th></tr></thead><tbody><tr><td>master</td><td>主分支，随时都得处于发布状态。</td></tr><tr><td>hotfix</td><td>修复线上的bug</td></tr><tr><td>develop</td><td>开发分支</td></tr><tr><td>feature</td><td>开发功能分支。</td></tr><tr><td>release</td><td>预发布分支。</td></tr></tbody></table><p>首先咱们先从 master分支下 创建 develop<br>develop 下创建 feature分支，用来开发功能。<br>功能开发结束，develop合并feature的功能。<br>然后从develop签出一条 release分支。用来准备发布。<br>出现bug，release修复bug，修复结束，同步给develop，与matser分支。</p><p>master分支 出现bug。</p><p>建立hotfix分支。修复bug。修复成功同步给master 与develop。</p><p>主要还是围绕着master 与 develop来展开的。</p><p>这就是标准的 git团队协作。</p>]]></content>
    
    
    <summary type="html">如何进行git团队协作，使用git遇到的坑儿</summary>
    
    
    
    <category term="git" scheme="http://yaru722.gitee.io/categories/git/"/>
    
    
    <category term="git" scheme="http://yaru722.gitee.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>2021年8月14日日报</title>
    <link href="http://yaru722.gitee.io/2021/08/14/2021%E5%B9%B48%E6%9C%8814%E6%97%A5%E6%97%A5%E6%8A%A5/"/>
    <id>http://yaru722.gitee.io/2021/08/14/2021%E5%B9%B48%E6%9C%8814%E6%97%A5%E6%97%A5%E6%8A%A5/</id>
    <published>2021-08-14T11:55:50.000Z</published>
    <updated>2021-08-14T11:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><ol><li>看webview与iframe</li><li>对着html进行查漏补缺</li><li>gitee，实名</li><li>看naive ui</li><li>uniapp，阅读了一下入门知识</li><li>html语义化规范</li></ol><h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><ul><li>递归算法</li><li>nuxt</li><li>uniapp router权限控制</li></ul><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><ul><li><p>webview是什么。  </p><blockquote><ol><li>浏览器专门针对像java啊，ios 安卓这样原生语言来设计的</li><li>原生应用就像一个孤岛。需要使用webview来接入web服务端的内容。</li><li>webview更像一个浏览器的渲染引擎。</li><li>通过webview，JavaScript可以调用原生的api，原生也可以加载web端的信息。</li></ol></blockquote></li><li><p>iframe是什么。</p><blockquote><p>1.html标签<br>2.加载网页。<br>3.上古时期的前端开发者用它来轮询。<br>4.自带一个沙盒机制。与页面代码互不打扰。<br>5.网页广告情况泛滥。<br>6.因为不知道别人有没有拿你的页面iframe，你会不会拿别人的页面iframe 所以不安全。</p></blockquote></li><li><p>html 标签查漏补缺。</p><blockquote><p>1.里面有个details标签。<br>2.meter 标签很有意思。<br>3.做好语义化。</p></blockquote></li></ul><h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><ul><li>html语义化与html常用标签。</li><li>webview与iframe</li></ul><h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ul><li>效率低下</li><li>今天没有使用番茄钟</li></ul>]]></content>
    
    
    <summary type="html">巩固印象</summary>
    
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>html查漏补缺</title>
    <link href="http://yaru722.gitee.io/2021/08/14/%E9%87%8D%E6%96%B0%E5%A4%8D%E4%B9%A0html/"/>
    <id>http://yaru722.gitee.io/2021/08/14/%E9%87%8D%E6%96%B0%E5%A4%8D%E4%B9%A0html/</id>
    <published>2021-08-14T11:30:20.000Z</published>
    <updated>2021-08-14T11:30:20.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h5><p>一个优秀的前端开发者，一定不是靠着一手所谓的<div><p>标签一把梭的。</p><p>即使html是一个超文本标记语言。JavaScript一直以来才是web开发者中的重中之重。</p><h5 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h5><ol><li><code>&lt;article&gt;&lt;/article&gt;</code>标签</li></ol><blockquote><p>w3cschool 是这样描述它的。article元素规定独立的自包含内容。  </p><article>元素的应用场景是 论坛，博客，新闻。</blockquote><p>独立的自包含内容，指的是，article标签，内部可以设置header，footer各种标签。来展示一篇独立的文章内容。</p><ol start="2"><li><code>&lt;aside&gt;&lt;/aside&gt;</code></li></ol><blockquote><p>aside标签2种用法。<br>要么文章标题的补充部分。<br>要么就是侧边栏。<br>与div差不多，但是html5 推行语义化标签的结果。</p></blockquote><ol start="3"><li><code>&lt;bdi&gt;&lt;bdi&gt;</code></li></ol><blockquote><p>我感觉 bdi标签没啥卵用。<br>标签允许您设置一段文本，使其脱离其父元素的文本方向设置。在发布用户评论或其他您无法完全控制的内容时</p></blockquote><blockquote><p>文档上是这么说。</p></blockquote><blockquote><p>但是在我眼里，这标签只会把 所谓的文字 如果是数字的话 改变一些排列的方向而已。</p></blockquote><ol start="4"><li><code>&lt;details&gt;&lt;/details&gt;与, &lt;summary&gt;&lt;summary/&gt;    </code></li></ol><blockquote><p>details是用于描述文档的细节。<br>summary details的标题。</p></blockquote><p>上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;details draggable=&quot;true&quot;&gt;</span><br><span class="line">    &lt;summary&gt;详情菜单&lt;/summary&gt;</span><br><span class="line">    &lt;div&gt;详情内容&lt;/div&gt;</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li><code>&lt;dialog&gt;&lt;/dialog&gt;</code></li></ol><blockquote><p>一个对话框，弹窗标签。open 打开关闭与否。<br>能和form配合使用。</p></blockquote><ol start="6"><li><code>&lt;figure&gt;&lt;/figure&gt;   &lt;figcaption&gt;&lt;/figcaption&gt;</code></li></ol><blockquote><p>用作文档中插图的图像，带有一个标题：figcaption。使用场景语焉不详</p></blockquote><ol start="7"><li><code>&lt;main&gt;&lt;/main&gt;</code></li></ol><blockquote><p>main标签对于文档来说 应该是唯一的。<br>文档最重要的内容。<br>不能嵌套hader footer等。应该保持平级。</p></blockquote><ol start="8"><li><code>&lt;mark&gt;&lt;/mark&gt;</code></li></ol><blockquote><p>定义重要或强调的内容。</p></blockquote><ol start="9"><li><code>&lt;meter&gt;&lt;/meter&gt;</code></li></ol><blockquote><p>它进度条<progress>的标签不一样的是，它更适合在磁盘用量，手机电量的展示上面。</p></blockquote><p>上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meter value=&quot;0.2&quot; max=&quot;1&quot; min=&quot;0&quot; low=&quot;0.1&quot; high=&quot;0.2&quot; optimum=&quot;1&quot; &gt;&lt;/meter&gt;</span><br><span class="line">/**</span><br><span class="line">   * max 最大的值</span><br><span class="line">   * min 最小的值</span><br><span class="line">   * high 被规定高的范围</span><br><span class="line">   * low 被规定低的范围</span><br><span class="line">   * optimum 规定度量的优化值。</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="10"><li><code>&lt;nav&gt;&lt;/nav&gt;</code></li></ol><blockquote><nav> 标签定义导航链接的部分。</blockquote><ol start="11"><li><code>&lt;progress&gt;&lt;/progress&gt;</code></li></ol><blockquote><p>进度条 无需多言。</p></blockquote><ol start="12"><li><code>&lt;section&gt;&lt;/section&gt;</code></li></ol><blockquote><p>表示文档中的一个章节。</p></blockquote><ol start="13"><li><code>&lt;&lt;wbr&gt;</code></li></ol><blockquote><p>在合适的位置换行，如果文字一行排放不完的话。wbr换行，让文本没那么割裂。</p></blockquote><p>14.<code>base </code></p><blockquote><p>是要设置在 heade标签里面了。规定了所有的超链接，该如何跳转。<br>当前页还是新开一个页面。</p></blockquote><p>举个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html lang=&quot;zh&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;刘超的demo&lt;/title&gt;</span><br><span class="line">    &lt;!--设置base target 来保证所有的超链接都该怎么样跳转--&gt;</span><br><span class="line">    &lt;base target=&quot;_blank&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/index.css&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="15"><li><code>blockquote</code></li></ol><blockquote><p>标记长的引用。比如一个段落。</p></blockquote><ol start="16"><li><code>datalist</code></li></ol><blockquote><p>datalist，input的可能选项列表。来定义input可能出现的值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;myCar&quot; list=&quot;cars&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;cars&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;BMW&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Ford&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Volvo&quot;&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="17"><li><code> &lt;optgroup&gt; &lt;/optgroup&gt;</code></li></ol><blockquote><p>把select一些相关的选项组合在一起</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;optgroup label=&quot;Swedish Cars&quot;&gt;</span><br><span class="line">    &lt;option value =&quot;volvo&quot;&gt;Volvo&lt;/option&gt;</span><br><span class="line">    &lt;option value =&quot;saab&quot;&gt;Saab&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt;</span><br><span class="line"></span><br><span class="line">  &lt;optgroup label=&quot;German Cars&quot;&gt;</span><br><span class="line">    &lt;option value =&quot;mercedes&quot;&gt;Mercedes&lt;/option&gt;</span><br><span class="line">    &lt;option value =&quot;audi&quot;&gt;Audi&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="18"><li><code>&lt;picture&gt;&lt;/picture&gt;</code></li></ol><blockquote><p>picture标签 不同的尺寸下展示不同的图片。</p></blockquote>]]></content>
    
    
    <summary type="html">复习html的一些知识点，查漏补缺。</summary>
    
    
    
    <category term="css" scheme="http://yaru722.gitee.io/categories/css/"/>
    
    
    <category term="九宫格" scheme="http://yaru722.gitee.io/tags/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>2021年8月13日日报</title>
    <link href="http://yaru722.gitee.io/2021/08/13/2021%E5%B9%B48%E6%9C%8813%E6%97%A5%E6%97%A5%E6%8A%A5/"/>
    <id>http://yaru722.gitee.io/2021/08/13/2021%E5%B9%B48%E6%9C%8813%E6%97%A5%E6%97%A5%E6%8A%A5/</id>
    <published>2021-08-13T12:53:52.000Z</published>
    <updated>2021-08-13T12:53:52.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><ol><li>智喔喔调试bug。</li><li>部署nuxt打包。</li><li>指定番茄钟。</li><li>扫了一眼rust。</li><li>三元表达式里面使用匿名函数。</li></ol><h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><ol><li>智喔喔安卓调试</li><li>商城等待开工</li><li>uniapp文章待看</li></ol><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1.nuxt打包问题。</p><p>nuxt的打包模式分为 build，和generate。<br>其中build里面打包，需要后端配置node，并且，但是需不需要做转发不得而知。</p><p>好像generate打包的是静态文件。但是却也可以使用。为了准确尽快出活。我没有细究。</p><p>2.跨域问题</p><p>我总感觉，nuxt就好像不需要跨域一样。待测试。</p><p>3.三元表达式-结合匿名函数一起使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var state = true;</span><br><span class="line">state ? (()=&gt;&#123;alert(11)&#125;)():(function b()&#123;alert(22)&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写完匿名函数之后，咱们需要多加个括号，表示是一个代码块。后面跟一个括号。</p><p>4.看春鹏的代码，了解了一些关于代码的规范。</p><p>比如，这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * description：刘超的代码</span><br><span class="line"> * author：刘超</span><br><span class="line"> * signa：只争朝夕</span><br><span class="line"> * timer：20点42分</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.nuxt更改布局页面。<br>nuxt在layouts，指定了多种布局方式，包括报错页面。与我们的视图。可以互相配合。互不干扰。</p><p>比如我不需要login加载导航栏。那就专门针对login。加载一个布局方式。</p><p>6.我们只需要在 vue文件下面layout:’指定的布局’</p><p>7.rust，具体印象，前端中后端语言，速度比c，c++快。</p><h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><ol><li>指定优秀的学习计划。</li><li>多看一些东西。</li><li>多像春鹏学习</li><li>nuxt的打包。</li></ol><h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ol><li>少说话</li><li>三思而行</li></ol>]]></content>
    
    
    <summary type="html">开发日记，巩固印象</summary>
    
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>臭德行的热血青年</title>
    <link href="http://yaru722.gitee.io/2021/07/10/%E8%87%AD%E5%BE%B7%E8%A1%8C%E7%9A%84%E7%83%AD%E8%A1%80%E9%9D%92%E5%B9%B4/"/>
    <id>http://yaru722.gitee.io/2021/07/10/%E8%87%AD%E5%BE%B7%E8%A1%8C%E7%9A%84%E7%83%AD%E8%A1%80%E9%9D%92%E5%B9%B4/</id>
    <published>2021-07-10T11:41:36.000Z</published>
    <updated>2021-07-10T11:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="臭德行的热血青年"><a href="#臭德行的热血青年" class="headerlink" title="臭德行的热血青年"></a>臭德行的热血青年</h2><p>一九七二年，我出生在吉林省和龙县龙门公社，那是我父母被下放的地方。据说他们是失手怀上了我，本来是想堕胎的，但是乡下的医疗卫生条件很差，出于安全的顾虑，他们才没有把我打掉。  </p><p>“你看你，多危险，龙门公社的医务所但凡靠谱一点儿，你就不能来到这世上了。”我稍稍大一点的时候，他们经常拿这样的话来逗我玩。在意识到生命苦乐参半之前，我无知地为此出过许多身冷汗，误以为能来到世间是一件格外值得庆幸的事情。</p><p>他们的玩笑有时候会使我对如果我没来会是什么样子的可能性遐想不已，钻牛角尖的时候，我会连续想上好几天。由于那时候我还不是一个无神论者，所以需要照顾到的可能性比现在多了很多倍。  </p><p>在我长大后看到很多反映类似“残酷青春”这样的主题的文艺作品之前，我还以为我的青少年时期过得还算顺利。我后来发现我经历过的很多真实事件，比如我小学的时候被几个人渣般的老师轮流摧残（一个老师派儿子来打我，另一个老师当着全班学生的面诬陷我是小偷），比如我在中学的时候很长的一段时间里定期被一群学校附近的大几岁的流氓无端羞辱和殴打，比如我离开校园之后跟一个女孩子热恋但她一直对我隐瞒着她的妓女身份等等，这些事情放到这些作品主人公的生命里，都会成为一个足以使他们杀人放火，或是彻底颓掉成为一个虚无主义者的充分条件，实际上，这些事情放在真实的生活里，对大多数人好像也是这样的结局。但是在我身上，这些好像只能让我扎扎实实地难过一段时间就过去了，甚至没有留下什么阴影。作为一个心理素质奇差、随便有点什么事情都会瞬间就紧张出一身冷汗的笨蛋，我又渐渐发现自己其实是一个内心强大、择善固执的好青年^_^  </p><p>坚定地选择做一个好人，让我在面对铺天盖地的流氓和道德感模糊的笨蛋的时候心理上充满自信和鄙视，但有些人给这种理直气壮的鄙视另外起了个名字叫道德优越感，不知道为什么，一件本来好像无比正当的事情因此又显得面目可疑了。  </p><p>和那个时代的很多傻男孩一样，我在很长的一段时间里一直都以为女人是对男人的长相全然不感冒的，所以二十来岁也没顾上让我的婴儿肥退下去，直到有一天自己的女朋友被一个帅哥勾走。二零零六年深夏，我看到深夏老师的文章“帅哥都是小甲鱼”，看得我老泪纵横，唏嘘不已，在王力宏的“爱你就等于爱自己”的背景音乐声中，一把鼻涕一把泪地做了深老师的铁杆粉丝。  </p><p>长得难看又打心眼里热爱妇女，为了亲近妇女，我想我应该是下意识地让自己练就了花言巧语的本事。由于这方面我天分好，态度又比较务实，所以基本上还很顺利。不过如果有得选，我还是宁可笨嘴笨舌，然后帅得气贯长虹。<br>有时候，你也会碰到在闪亮的人格和有思想的头脑面前兀自岿然不动的固执女孩。如果你同样固执地喜欢她，就不得不考虑快速减掉五十斤肥肉。  </p><p>回想起来好像无限漫长的青春期里，除了每个孩子都会感到迷茫的性问题之外，暴力问题也常常让我感到非常困惑。在我校某个同学被“敌校”的某些同学打伤后的报复行动的计划会上，我以我认为很正常的方式询问了受伤同学的受伤原因，结果换来的是一堆白眼和“这个节骨眼上，你还问这个有劲吗？”的表情。为了不被伙伴们孤立，我在心里不是很理解的情况下，以超出实际需要的积极性参与了群殴，换来了大家的谅解和尊重，然后我们得知我校同学挨打受伤的直接原因是他之前调戏了敌校打人同学的女朋友。  </p><p>让我继续困惑的是，那些不分青红皂白就打了人的同学中的大部分人这时候仍然纷纷表示“这不重要”。终于让我明白了他们只关注本帮还是外帮，本班还是外班、本校还是外校之后，他们给我造成的新的困惑是：他们看武侠小说的时候，竟然对小说中的人物的“武德”非常挑剔。（这帮精神分裂的家伙后来和我一样长大成人走进社会娶妻生子，在某些时期的晚上七点钟，他们会指着电视屏幕对老婆说，他们是我们的骨肉同胞，不过他们要是想分家我们就得杀过去干掉他们。然后看着孩子迷茫的脸爱怜地点点头说，对，会死人的，不过这是必须的，对分裂主义分子你决不能手软。）  </p><p>如果不幸生在一个这样的国家里的小地方，成长的时候基本上可以肯定没有人能在思想上给你很大的帮助，除非有奇迹。很多时候，不要说帮助，就连能互相理解和沟通的人也很难找。除了性和暴力，我在青春期的最主要的烦恼就是几乎找不到能畅快交流想法的人，总感觉身边的人好像不是笨蛋就是坏蛋。（好在我自己在很多方面也非常笨，所以也经常被他们嘲笑，于是大家心平气和）这样想来，那时候我把退学后的大部分时间用来读书或多或少也是一个必然的结果了。只是那时候我过于热爱文字了，以致于把琼瑶全集这样的都通读了一遍。我是我认识的男人里，唯一一个通读过琼瑶全集的奇男子。<br>我做了教师以后，有些和我一样生长在小地方的学生来信说，他们在身边找不到能沟通交流的朋友，感到很孤独。而且到处都是善意地摧残他们的长辈，整天打击他们拒绝同流合污的信念，搞得他们开始有点怀疑自己的坚持和这种坚持的价值了，问我如何保持饱满的情绪和旺盛的斗志。对于孤独的问题，我想限于条件，只能用读书的方式来解决，至于肯定自己的坚持和价值，我自己长大的时候自我调节的方式及过程大概是这样的：  </p><p>我不断听到那些在人品和能力上都让我由衷鄙视的长辈们对我说，你不要生气，中国的事儿就是这样，你生气也改变不了的，其实你到哪儿都一样，一定要学会适应环境，你不要太较真儿了，差不多就行了，你这样的态度到哪儿都吃不开……这种话听得多了，我就慢慢明白了，哦，原来我是一个正直的，对是非善恶感受强烈的，有理想，有追求，有原则的热血青年。  </p><p>过了些年，这些长辈们再次见到我的时候又惊讶地说，咦？你怎么和小的时候一模一样？一点都没变？奇怪，你还是这个臭德行怎么没被人搞死？嗯？听说你小子混得还挺好？我劝你还是小心点吧，你这么臭得瑟没什么好下场……这种话听得多了，我又渐渐明白了，哦，原来我是一个正直的，对是非善恶感受强烈的，有理想，有追求，有原则，有坚持的热血青年，并且还是个聪明的，有勇有谋的热血青年。</p>]]></content>
    
    
    <summary type="html">罗永浩的自传摘抄</summary>
    
    
    
    <category term="杂集" scheme="http://yaru722.gitee.io/categories/%E6%9D%82%E9%9B%86/"/>
    
    
    <category term="杂集" scheme="http://yaru722.gitee.io/tags/%E6%9D%82%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>vue路由组件传参</title>
    <link href="http://yaru722.gitee.io/2021/07/10/vue%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/"/>
    <id>http://yaru722.gitee.io/2021/07/10/vue%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/</id>
    <published>2021-07-10T11:24:50.000Z</published>
    <updated>2021-07-10T11:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于vue-router组件的传参"><a href="#关于vue-router组件的传参" class="headerlink" title="关于vue router组件的传参"></a>关于vue router组件的传参</h3><h5 id="提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？"><a href="#提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？" class="headerlink" title="提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？"></a>提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？</h5><ol><li> 比如vue 动态路由参数匹配？</li><li> 还是使用vue params，传参，比如通过router上的name，才能跳转，刷新一下参数就掉。</li><li> 还是比如query，参数拼接到字符串上？</li></ol><p>我们假设一个场景，我们在A页面到B页面，要传递一个object。是的，你一定要json一下，<br>在B页面接收都要做那些步骤。</p><ol><li>先写上一段，this.$route.query.object ….（我不说你也得觉得很长）</li><li>把拿到的参数josn化。</li><li>要把参数赋值到data，然后data再去使用。</li></ol><h5 id="发现的问题"><a href="#发现的问题" class="headerlink" title="发现的问题"></a>发现的问题</h5><h6 id="1-你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。"><a href="#1-你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。" class="headerlink" title="1. 你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。"></a>1. 你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。</h6><p>解决方案也简单，写个判断语句嘛。if，三元表达式，或者query，传递不同的标识符。这样页面C跳转B也没啥问题了。</p><h6 id="2-this-router-query-object-真的是一种很舒服的传参方式嘛，这么长。"><a href="#2-this-router-query-object-真的是一种很舒服的传参方式嘛，这么长。" class="headerlink" title="2. this.$router.query.object,真的是一种很舒服的传参方式嘛，这么长。"></a>2. this.$router.query.object,真的是一种很舒服的传参方式嘛，这么长。</h6><p>不是。</p><p>这就是我要讲vue router 组件传参的意义。</p><p>路由传参有三种模式</p><h6 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h6><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//router部分</span><br><span class="line">  &#123;</span><br><span class="line">    name:&#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props: true //直接开启布尔模式</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  //跳转</span><br><span class="line">&lt;router-link :to=&quot;&#123;name: &#x27;user&#x27;,params: &#123;name: &#x27;word&#x27;,  age: &#x27;11&#x27;&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">//页面取参数</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;name&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/div&gt;&lt;!--参数是word11--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: [&#x27;params&#x27;,&#x27;name&#x27;,&#x27;age&#x27;],</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>布尔模式下，props：true的情况下，params的参数会被设置为组件的props。</p><h6 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h6><p>例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//  router部分</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    name: &#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props: &#123;</span><br><span class="line">      name: &#x27;11&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">//跳转</span><br><span class="line">  &lt;router-link :to=&quot;&#123;name: &#x27;user&#x27;, params:&#123;name:&#x27;word&#x27;,age:&#x27;11&#x27;,&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  页面</span><br><span class="line">  </span><br><span class="line">    &lt;template&gt;</span><br><span class="line">         &lt;div&gt;user&#123;&#123; name &#125;&#125;&#123;&#123; age &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [ &quot;name&quot;, &quot;age&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象模式只适合给静态类型的数据。。routerlink 传递进去的数据 拿不到。</p><p>函数模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//router</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    name: &#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props:route=&gt;(&#123;//函数模式，把route的参数给解构了。</span><br><span class="line">      name:route.query.name,</span><br><span class="line">      age:route.query.age,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  //跳转</span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&#x27;/user&#x27;,query:&#123;name:&#x27;word&#x27;,age:&#x27;11&#x27;&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line">  </span><br><span class="line">//user页面接收参数</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;user&#123;&#123; name &#125;&#125;&#123;&#123; age &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;!--参数是word11--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;query&#x27;, &quot;name&quot;, &quot;age&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><table><thead><tr><th>模式</th><th>特性</th><th>优点</th></tr></thead><tbody><tr><td>布尔值模式</td><td>props，属性为true，route.params，自动绑定为属性</td><td>不支持query</td></tr><tr><td>对象模式</td><td>适合静态类型</td><td>不支持动态类型</td></tr><tr><td>函数模式</td><td>支持params，query</td><td>没啥毛病</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">vue路由组件传参，布尔值模式，对象模式，函数模式。</summary>
    
    
    
    <category term="vue" scheme="http://yaru722.gitee.io/categories/vue/"/>
    
    
    <category term="vue" scheme="http://yaru722.gitee.io/tags/vue/"/>
    
  </entry>
  
</feed>
