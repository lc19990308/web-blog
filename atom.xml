<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bug制造者</title>
  
  
  <link href="http://yaru722.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://yaru722.gitee.io/"/>
  <updated>2022-12-26T10:35:44.799Z</updated>
  <id>http://yaru722.gitee.io/</id>
  
  <author>
    <name>lc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习vue router</title>
    <link href="http://yaru722.gitee.io/2022/12/26/%E5%AD%A6%E4%B9%A0vue-router/"/>
    <id>http://yaru722.gitee.io/2022/12/26/%E5%AD%A6%E4%B9%A0vue-router/</id>
    <published>2022-12-26T10:32:39.583Z</published>
    <updated>2022-12-26T10:35:44.799Z</updated>
    
    <content type="html"><![CDATA[<p>一直都没老老实实的看过 vue router 的文档。</p><p>今天详细的过一遍 vue router 文档。</p><h4 id="router-当中的动态路由匹配"><a href="#router-当中的动态路由匹配" class="headerlink" title="router 当中的动态路由匹配"></a>router 当中的动态路由匹配</h4><p>假设我们有一个页面，需要传递参数。我们看一下动态路由如何进行匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView/:id&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/UserView.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;app-container&quot;&gt;</span><br><span class="line">  &lt;div&gt;user页面获取到的id:&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>使用 vue router 动态路由匹配的话，接收参数必须使用，<strong>route.params</strong>来接收参数。</p><p>vue 使用 $router.push(),跳转同一个页面会导致报错。</p><p>在 router 文件夹下面的 index.js 文件，添加一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const originalPush = VueRouter.prototype.push;</span><br><span class="line">VueRouter.prototype.push = function push(location) &#123;</span><br><span class="line">  return originalPush.call(this, location).catch((err) =&gt; err);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>跳转同一个页面就不会报错了。</p><p>捕捉 router 没有，匹配到 404 Not found 路由。</p><p>使用 router path 的通配符，可以匹配任何路径。</p><p>当然在这里之前，我们首先得有一个，所谓的 404 页面。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/404Page&quot;,</span><br><span class="line">  name: &quot;404&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/404Page.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>path 使用通配符，匹配没有被匹配到的路径，使用 redirect，把它给重定向到，/404Page 页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 会匹配所有路径</span><br><span class="line">  path: &quot;*&quot;,</span><br><span class="line">  redirect: &quot;/404Page&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="router-嵌套路由。"><a href="#router-嵌套路由。" class="headerlink" title="router 嵌套路由。"></a>router 嵌套路由。</h4><p>router-view，会渲染匹配到组件。一个渲染组件同样也可以包涵自己的 router-view 嵌套。。</p><p>路由嵌套，需要多个 router-view。顶层的 router-view 渲染出的是顶层，高级路由所匹配到的组件。高级路由所匹配到的组件，内部加载 router-view，渲染，router 嵌套所匹配到的组件。。</p><p>这个概念很绕。</p><p>假设以，A 组件，需要嵌套 B,C 组件。顶层的 router-view 渲染出的仅仅是，A 组件。A 组件的内部的 router-view，用来渲染，B,C 组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/user/UserView.vue&quot;),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;NavbarView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;FooterView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/FooterView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还是，A 组件嵌套 B,C 组件。B.C 组件。假设，我们跳转/A/B,再跳转到/A/C，那么，B,C 组件的生命周期是完整的。</p><p>可是，A 组件已然被复用了，不会在重复的执行生命周期了。。</p><p>那么，A 组件的路由，参数发生变动，A 组件的，created 生命周期，只会加载一次。如何拿到变动的，参数呢？</p><p>答案，是使用 watch 监听。router 的变动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  $route(to) &#123;</span><br><span class="line">    this.id = to.params.id;</span><br><span class="line">    // 对路由变化作出响应...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们跳转/A 的路由，A 组件内部的 router-view，没有匹配到组件，就不会渲染。。</p><p>如果跳转/A，A 组件内部的，router-view，我们想要渲染的话。咱们可以提高一个空的子路由。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">     &#123;</span><br><span class="line">       path: &quot;&quot;,</span><br><span class="line">       component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       path: &quot;NavbarView&quot;,</span><br><span class="line">       component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       path: &quot;FooterView&quot;,</span><br><span class="line">       component: () =&gt; import(&quot;../views/user/FooterView.vue&quot;),</span><br><span class="line">     &#125;,</span><br><span class="line">   ],</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者，也可以，进行重定向。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView/:id&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  redirect: &quot;/UserView/:id/NavbarView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/user/UserView.vue&quot;),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;NavbarView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;FooterView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/FooterView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="关于-vue-router-的命名路由。"><a href="#关于-vue-router-的命名路由。" class="headerlink" title="关于 vue router 的命名路由。"></a>关于 vue router 的命名路由。</h4><p>这里做个假设，假设，我要跳一个嵌套路由。是一个二级嵌套。。</p><p>那么，肯定是这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$router.push(&#123;path:&#x27;/a/b&#x27;&#125;)</span><br><span class="line">或者 &lt;router-link :to=&#123;path:&#x27;/a/b&#x27;&#125; /&gt;</span><br></pre></td></tr></table></figure><p>命名路由，就是给路由起一个名字。</p><p>例子如下，，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView/:id&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  redirect: &quot;/UserView/:id/NavbarView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/user/UserView.vue&quot;),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;UserView-NavbarView&quot;,</span><br><span class="line">      path: &quot;NavbarView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;FooterView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/FooterView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">    &lt;router-link :to=&quot;&#123; name: &#x27;UserView-NavbarView&#x27;, params: &#123; id: &#x27;11&#x27; &#125; &#125;&quot;</span><br><span class="line">      &gt;UserView/NavbarView&lt;/router-link</span><br><span class="line">    &gt;|</span><br></pre></td></tr></table></figure><p>router-link，使用 name 进行跳转，要简便多了。。</p><p>当然，缺陷就是，router，是一个匹配的关系。所以！！！<br>name 是唯一的。就像 id 一样。。不要乱跳！</p><p>params 传参的缺点就是，需要用动态路由。参数在路由上面定义。route.params 接收。。</p><p>query 接收参数，就是一段查询字符串。。</p><h4 id="关于命名视图"><a href="#关于命名视图" class="headerlink" title="关于命名视图."></a>关于命名视图.</h4><p>在 app.vue 里面的<router-view />是一个未命名的视图。router 只要匹配到了，就会把组件渲染到这里。。</p><p>可是，我们要完成一些复杂的布局。</p><p>例子，在 app.vue 里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;el-container&gt;</span><br><span class="line">    &lt;el-aside width=&quot;200px&quot;&gt;</span><br><span class="line">      &lt;transition name=&quot;slide&quot;&gt;</span><br><span class="line">        &lt;router-view name=&quot;aside&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/transition&gt;</span><br><span class="line">    &lt;/el-aside&gt;</span><br><span class="line">    &lt;el-main&gt;</span><br><span class="line">      &lt;transition name=&quot;slide&quot;&gt;</span><br><span class="line">        &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/transition&gt;</span><br><span class="line">    &lt;/el-main&gt;</span><br><span class="line">  &lt;/el-container&gt;</span><br><span class="line">  &lt;transition name=&quot;slide&quot;&gt;</span><br><span class="line">    &lt;router-view /&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们对 router-view 的 name 进行了命名。</p><p>因为我们要在同级嵌套 视图。</p><p>router 挂载组件的时候。就不能使用，component 了，需要使用 components。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/LayoutIndex&quot;,</span><br><span class="line">  name: &quot;LayoutIndex&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    default: () =&gt; import(&quot;../layout/LayoutIndex.vue&quot;),</span><br><span class="line">    main: () =&gt; import(&quot;../layout/MainView.vue&quot;),</span><br><span class="line">    aside: () =&gt; import(&quot;../layout/AsideView.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们使用 router 跳转到 LayoutIndex 页面时，命名路由会得到匹配。。</p><p>那么嵌套路由如果是嵌套路由命名视图呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/UserView.vue&quot;),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;DefaultView&quot;,</span><br><span class="line">      name: &quot;DefaultView&quot;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        default: () =&gt; import(&quot;../views/user/DefaultView.vue&quot;),</span><br><span class="line">        header: () =&gt; import(&quot;../views/user/HeaderView.vue&quot;),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>嵌套命名视图。就是把命名视图藏入，要嵌套的页面里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--&lt;router-view /&gt;</span><br><span class="line">    &lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt; --&gt;</span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">      &lt;el-aside width=&quot;200px&quot;&gt;</span><br><span class="line">        &lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;, &#x27;3&#x27;]&quot;&gt;</span><br><span class="line">          &lt;el-submenu index=&quot;1&quot;&gt;</span><br><span class="line">            &lt;template slot=&quot;title&quot;</span><br><span class="line">              &gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;导航一&lt;/template</span><br><span class="line">            &gt;</span><br><span class="line">            &lt;el-menu-item-group&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item-group title=&quot;分组2&quot;&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-submenu index=&quot;1-4&quot;&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;1-4-1&quot;&gt;选项4-1&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">          &lt;/el-submenu&gt;</span><br><span class="line">          &lt;el-submenu index=&quot;2&quot;&gt;</span><br><span class="line">            &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;导航二&lt;/template&gt;</span><br><span class="line">            &lt;el-menu-item-group&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;2-1&quot;&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;2-2&quot;&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item-group title=&quot;分组2&quot;&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;2-3&quot;&gt;选项3&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-submenu index=&quot;2-4&quot;&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;2-4-1&quot;&gt;选项4-1&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">          &lt;/el-submenu&gt;</span><br><span class="line">          &lt;el-submenu index=&quot;3&quot;&gt;</span><br><span class="line">            &lt;template slot=&quot;title&quot;</span><br><span class="line">              &gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;导航三&lt;/template</span><br><span class="line">            &gt;</span><br><span class="line">            &lt;el-menu-item-group&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;3-1&quot;&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;3-2&quot;&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item-group title=&quot;分组2&quot;&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;3-3&quot;&gt;选项3&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-submenu index=&quot;3-4&quot;&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;3-4-1&quot;&gt;选项4-1&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">          &lt;/el-submenu&gt;</span><br><span class="line">        &lt;/el-menu&gt;</span><br><span class="line">      &lt;/el-aside&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-header&gt;</span><br><span class="line">          &lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/el-header&gt;</span><br><span class="line">        &lt;el-main&gt;</span><br><span class="line">          &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/el-main&gt;</span><br><span class="line">      &lt;/el-container&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重定向与别名"><a href="#重定向与别名" class="headerlink" title="重定向与别名"></a>重定向与别名</h4><p>比如，我们要访问 home 页面，但是 home 页面没有被 router 所匹配到，那么使用，router 的 redirect，把它给重定向到 404 页面。</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 会匹配所有路径</span><br><span class="line">  path: &quot;*&quot;,</span><br><span class="line">  redirect: &quot;/404Page&quot;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>router 中的别名，alias，比如我们访问首页，path 是 “/”，这个时候，我们如果使用，router，跳转到/index，页面。就会匹配到 404 页面。</p><p>这个时候，我们设置别名，path：“/”的，alias：“/index”，这样的话，router.push 跳转到 /，/index，都会匹配到首页。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/&quot;,</span><br><span class="line">  name: &quot;home&quot;,</span><br><span class="line">  alias: &quot;/index&quot;,</span><br><span class="line">  component: HomeView,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="router-路由组件传参"><a href="#router-路由组件传参" class="headerlink" title="router 路由组件传参"></a>router 路由组件传参</h4><p>每次 url 传递的参数，都在 route.params，里面拿到。组件与 router 之间会存在高度耦合性。</p><p>我们可以使用，组件当中的 props 来降低解耦。</p><p>布尔模式下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: &quot;/about/:id&quot;,</span><br><span class="line">  name: &quot;about&quot;,</span><br><span class="line">  props: true,</span><br><span class="line">  component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>props 为 true，router 上的 params，会自动绑定到组件的 props，上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;HomeNavbar&quot;&gt;组件:&#123;&#123; id &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;id&quot;],</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$route.params);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.HomeNavbar &#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象模式，如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。</p><p>静态指的是，route.params,和，route.query 的参数都无法传递到，props 上面去。</p><p>参数被定义在 router 上写死了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: &quot;/about&quot;,</span><br><span class="line">  name: &quot;about&quot;,</span><br><span class="line">  props: &#123; id: 1212121, name: &quot;章三&quot; &#125;,</span><br><span class="line">  // props: (route) =&gt; (&#123; ...route.query &#125;),</span><br><span class="line">  component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数模式，我们可以创建一个函数返回 props，这样可以把静态的值，路由的值结合到一起。。</p><p>比如，我们要把 route.query 的值，返回到 props，上。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/about&quot;,</span><br><span class="line">    name: &quot;about&quot;,</span><br><span class="line">    props: (route) =&gt; (&#123; ...route.query &#125;),</span><br><span class="line">    component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;about&quot;&gt;</span><br><span class="line">    &lt;h1&gt;This is an about page&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;id=&gt; &#123;&#123; id &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;name=&gt; &#123;&#123; name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;id&quot;, &quot;name&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="router-当中的路由守卫"><a href="#router-当中的路由守卫" class="headerlink" title="router 当中的路由守卫"></a>router 当中的路由守卫</h4><p>使用全局路由守卫来，来判断 token 是否存在。不存在就去登录页。</p><p>beforeEach,有三个参数，to，from，next。<br>to，从哪来来，from，要到哪里去。</p><p>next，是否同意。。</p><p>next 写的一定要符合逻辑。确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import router from &quot;@/router/index&quot;;</span><br><span class="line">const whiteList = [&quot;/login&quot;];</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  const Token = localStorage.getItem(&quot;Token&quot;);</span><br><span class="line">  if (Token) &#123;</span><br><span class="line">    if (to.path === &quot;/login&quot;) &#123;</span><br><span class="line">      next(&quot;/&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (whiteList.includes(to.path)) &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(`/login?redirect=$&#123;to.fullPath&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局后置钩子，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局后置钩子，没有，next 方法。只有 to，from</p><p>路由独享的守卫</p><p>比如，我有一个特殊的页面，权限只针对这个页面。那么在页面的钩子函数里面，处理不够优雅。在全局守卫里面，处理有小题大做。。</p><p>例子如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/about&quot;,</span><br><span class="line">  name: &quot;about&quot;,</span><br><span class="line">  props: (route) =&gt; (&#123; ...route.query &#125;),</span><br><span class="line">  beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">    if (localStorage.getItem(&quot;Token&quot;)) &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(`/login?redirect=$&#123;to.fullPath&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>beforeEntaer,路由上的守卫就特别好使。</p><p>组件内也有路由守卫给我们使用。<br>分别是，beforeRouteEnter<br>beforeRouteUpdate (2.2 新增)<br>beforeRouteLeave</p><p>我们把在 router 上的，beforEnter，守卫拿掉。</p><p>例子如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">  // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">  // 不！能！获取组件实例 `this`</span><br><span class="line">  // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  if (localStorage.getItem(&quot;Token&quot;)) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(`/login?redirect=$&#123;to.fullPath&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当页面被复用的时候。beforeRouteUpdate 守卫会被触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate(to, from) &#123;</span><br><span class="line">  // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line">  console.log(to.path, from.path);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>beforeRouteLeave 路由守卫，更像一个全局后置守卫，但是他有 next 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">  // 导航离开该组件的对应路由时调用</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="路由的元信息"><a href="#路由的元信息" class="headerlink" title="路由的元信息"></a>路由的元信息</h4><p>我们可以在路由上定义 mate 字段，存储一些路由信息，比如是否要身份验证…</p><p>router.js，路由元信息添加到，router 里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/404Page&quot;,</span><br><span class="line">    name: &quot;404&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&quot;../views/404Page.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/&quot;,</span><br><span class="line">    name: &quot;home&quot;,</span><br><span class="line">    alias: &quot;/index&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&quot;../views/HomeView.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/about&quot;,</span><br><span class="line">    name: &quot;about&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    props: (route) =&gt; (&#123; ...route.query &#125;),</span><br><span class="line">    component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/LayoutIndex&quot;,</span><br><span class="line">    name: &quot;LayoutIndex&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      default: () =&gt; import(&quot;../layout/LayoutIndex.vue&quot;),</span><br><span class="line">      main: () =&gt; import(&quot;../layout/MainView.vue&quot;),</span><br><span class="line">      aside: () =&gt; import(&quot;../layout/AsideView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/login&quot;,</span><br><span class="line">    name: &quot;login&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&quot;../views/LoginPage.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/UserView&quot;,</span><br><span class="line">    name: &quot;UserView&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      default: () =&gt; import(&quot;../views/UserView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &quot;DefaultView&quot;,</span><br><span class="line">        name: &quot;DefaultView&quot;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          authentication: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">          default: () =&gt; import(&quot;../views/user/DefaultView.vue&quot;),</span><br><span class="line">          header: () =&gt; import(&quot;../views/user/HeaderView.vue&quot;),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    // 会匹配所有路径</span><br><span class="line">    path: &quot;*&quot;,</span><br><span class="line">    redirect: &quot;/404Page&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br><span class="line">const originalPush = VueRouter.prototype.push;</span><br><span class="line">VueRouter.prototype.push = function push(location) &#123;</span><br><span class="line">  return originalPush.call(this, location).catch((err) =&gt; err);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default router;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用路由信息，设置路由守卫。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import router from &quot;@/router/index&quot;;</span><br><span class="line">// const whiteList = [&quot;/login&quot;];</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  const Token = localStorage.getItem(&quot;Token&quot;);</span><br><span class="line">  if (Token) &#123;</span><br><span class="line">    if (to.path === &quot;/login&quot;) &#123;</span><br><span class="line">      next(&quot;/&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (to.meta.authentication) &#123;</span><br><span class="line">      next(`/login?redirect=$&#123;to.fullPath&#125;`);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="路由动效"><a href="#路由动效" class="headerlink" title="路由动效"></a>路由动效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用动态的 transition name --&gt;</span><br><span class="line">&lt;transition :name=&quot;transitionName&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="在页面未加载之前获取数据。"><a href="#在页面未加载之前获取数据。" class="headerlink" title="在页面未加载之前获取数据。"></a>在页面未加载之前获取数据。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">    next(vm =&gt; vm.setData(err, post))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结，集中的过了一下，route.parmas，刷新参数会消失的原因是，因为，动态路由传参数，必须要在 router 里面定义。</p><p>视图如何嵌套，命名视图如何和嵌套视图，整在一起，路由如何加动效。router 传参。如何更好的解耦，把它整合到 porps 里面。如何使用重定向和别名。</p><p>包括路由的 3 个全局守卫，路由独享的守卫，组件路由守卫。路由的 mate 信息，配合全局守卫。</p><p>在页面加载之前提前获取到数据。<br>和路由的滚动。等等知识。还是干货满满的。</p><p>百度脑图地址，<a href="https://naotu.baidu.com/file/d10fd6077ad17cc07833f7fd0dbdbc19">百度脑图</a></p>]]></content>
    
    
    <summary type="html">学习vue当中的router，动态传参，动态路由，命名视图，命名路由，组件传参，路由守卫，视图嵌套，懒加载路由，路由动效，路由滚动，路由元信息......</summary>
    
    
    
    <category term="vue router" scheme="http://yaru722.gitee.io/categories/vue-router/"/>
    
    
    <category term="vue" scheme="http://yaru722.gitee.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>css当中的BFC</title>
    <link href="http://yaru722.gitee.io/2022/12/21/css%E5%BD%93%E4%B8%AD%E7%9A%84BFC/"/>
    <id>http://yaru722.gitee.io/2022/12/21/css%E5%BD%93%E4%B8%AD%E7%9A%84BFC/</id>
    <published>2022-12-21T07:37:13.914Z</published>
    <updated>2022-12-21T07:38:39.216Z</updated>
    
    <content type="html"><![CDATA[<h5 id="到底什么是bfc"><a href="#到底什么是bfc" class="headerlink" title="到底什么是bfc"></a>到底什么是bfc</h5><p>Block formatting contexts 也叫做”块格式化上下文”。简单来说，bfc容器在内部有一块独立的空间。不管内部的元素如何布局，如何排列，它们都不回影响到外部的布局。就像一个规则。</p><p>举个例子，</p><p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog_bfc1.jpeg" alt="什么是bfc"></p><p><strong>孙悟空</strong>画的圈圈，就是<strong>BFC</strong>，而里面的唐僧等人，就是BFC容器内部的子元素。</p><p>外部的容器打扰不到BFC内部的布局，BFC容器，也不会影响到外部的布局。。</p><h5 id="BFC-有什么用？为什么要使用它。"><a href="#BFC-有什么用？为什么要使用它。" class="headerlink" title="BFC,有什么用？为什么要使用它。"></a>BFC,有什么用？为什么要使用它。</h5><p>为什么要使用bfc</p><p>举个例子，</p><p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog_bfc2.jpeg" alt="如果不使用bfc的话"></p><p><strong>子元素</strong>(乘客)，就会<strong>挤出</strong>容器，导致影响到外部的布局。。</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div class=&quot;Container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;p&gt;林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">.Container &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图</p><p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChatb847b01c1e81db03fd5eb205c3048678.png" alt="容器被子元素挤出"></p><p>因为，Container，大小只有100px，box1+box2，大小已经超出了100px，那么元素就会溢出。这个时候就会影响到，下面的布局。。</p><p>bfc容器，子元素在空间不足的情况下，不会影响到外部布局。。</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   &lt;div class=&quot;BFC_box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.BFC_box &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果图</p><p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChatb3ca569dc952680bb8ab7b50e2bd73a8.png" alt="bfc容器，子元素不会影响到外部布局"></p><h5 id="如何触发bfc"><a href="#如何触发bfc" class="headerlink" title="如何触发bfc"></a>如何触发bfc</h5><ol><li><p>根元素；</p></li><li><p>浮动元素。元素的 float 不是 none；</p></li><li><p>绝对定位元素。元素的 position 为 absolute 或 fixed；</p></li><li><p>行内块元素。元素的 display 为 inline-block；</p></li><li><p>表格单元格。元素的 display为 table-cell，HTML表格单元格默认为该值；</p></li><li><p>表格标题。元素的 display 为 table-caption，HTML表格标题默认为该值；</p></li><li><p>匿名表格单元格元素。元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table；</p></li><li><p>overflow 值不为 visible 的块元素 ；</p></li><li><p>弹性元素。display为 flex 或 inline-flex元素的直接子元素；</p></li><li><p>网格元素。display为 grid 或 inline-grid 元素的直接子元素。</p></li></ol><h5 id="bfc都有哪些用处。"><a href="#bfc都有哪些用处。" class="headerlink" title="bfc都有哪些用处。"></a>bfc都有哪些用处。</h5><ol><li>出现mrigin重叠。</li><li>可以应用到两栏布局。</li><li>清除内部的元素的浮动。</li></ol><p>marigin 重叠。</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-bottom: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-top: 40px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果图</p><p><a href="https://imgse.com/i/zIlvoq"><img src="https://s1.ax1x.com/2022/12/14/zIlvoq.md.png" alt="zIlvoq.md.png"></a></p><p>按道理来讲  margin-top: 40px;，margin-bottom: 100px;那么，上下边距得有140px的，但是2个盒子之间的上下边距，会被折叠，取最大的那个。所以。上下只有100px的边距。</p><p>bfc可以清除浮动。</p><p>现在产生一个浮动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;111&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    width: 600px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    margin: 0 10px;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    margin: 0 10px;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果图<br><a href="https://imgse.com/i/zI8use"><img src="https://s1.ax1x.com/2022/12/14/zI8use.md.png" alt="zI8use.md.png"></a></p><p>给.box添加 display：flex，</p><p>效果图。</p><p><a href="https://imgse.com/i/zI8TW6"><img src="https://s1.ax1x.com/2022/12/14/zI8TW6.md.png" alt="zI8TW6.md.png"></a></p><p>以下就是bfc格式化块级上下文的理解。bfc容器，不影响到外部容器。marigin会折叠。会清清楚浮动。</p>]]></content>
    
    
    <summary type="html">css当中的(BFC)块级格式化上下文是什么？</summary>
    
    
    
    <category term="css" scheme="http://yaru722.gitee.io/categories/css/"/>
    
    
    <category term="css当中的BFC" scheme="http://yaru722.gitee.io/tags/css%E5%BD%93%E4%B8%AD%E7%9A%84BFC/"/>
    
  </entry>
  
  <entry>
    <title>从0开始学习vuex</title>
    <link href="http://yaru722.gitee.io/2022/12/21/%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%AD%A6%E4%B9%A0vuex/"/>
    <id>http://yaru722.gitee.io/2022/12/21/%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%AD%A6%E4%B9%A0vuex/</id>
    <published>2022-12-21T07:33:39.715Z</published>
    <updated>2022-12-21T07:36:55.095Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h4><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><p>用通俗的话，来说，当一个vue项目，复杂起来的时候，就需要一个vue 组件全局状态管理的工具。vuex就是一个这样的工具。</p><h4 id="vuex的state"><a href="#vuex的state" class="headerlink" title="vuex的state"></a>vuex的state</h4><p>把vuex 当中的state，在组件里展示出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    token: &quot;&quot;,</span><br><span class="line">    count: 1,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return this.$store.state.user.count;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用mapState 辅助函数</p><p>当我们需要在一个组件state当中获取到，多个状态的时候。</p><p>代码如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState &#125; from &quot;vuex&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 10,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    count: (state) =&gt; state.user.count,</span><br><span class="line">    token: (state) =&gt; state.user.token,</span><br><span class="line">    countPlusLocalState(state) &#123;</span><br><span class="line">      return state.user.count + this.num;</span><br><span class="line">    &#125;,</span><br><span class="line">    msg: &quot;msg&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mapState,可以帮助我们更好的生成计算属性，获取到store里面的状态。</p><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &#x27;count&#x27;</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mapState，是一个对象，刚才的那种写法影响到了，我们使用计算属性。这时候我们可以用对象展开运算符写法，以免这样的情况发生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      count: (state) =&gt; state.user.count,</span><br><span class="line">      plus: (state) =&gt; &#123;</span><br><span class="line">        console.log(thit.num);</span><br><span class="line">        return state.user.count;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">    plusNum: () =&gt; &#123;</span><br><span class="line">      return thit.num + 10;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    thit = this;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以在计算属性，照常使用，data里面的参数，与store里面的参数相加。</p><p>也能把computed，mapState分开来。</p><p>对于需要经常去进行通讯的组件来说，vuex，极大了弥补了，单向数据流带来的不足。<br>vuex，更方便调试，更直观。但是，却不好维护，所以，非必要的情况下，组件的局部状态还是保存到局部为好。</p><h4 id="vuex当中的Getter"><a href="#vuex当中的Getter" class="headerlink" title="vuex当中的Getter"></a>vuex当中的Getter</h4><blockquote><p>有时候我们需要从 store 中的 state 中派生出一些状态，比如store里面有个count，我们需要对count，进行加倍。这个时候，使用getter，就非常好使。</p></blockquote><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  dounceCount() &#123;</span><br><span class="line">    return this.$store.getters.doubleCount;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>getter通过属性访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;超级加倍&#123;&#123; $store.getters.doubleCount &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>getter通过方法去访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doubleCount() &#123;</span><br><span class="line">    return thit.$store.getters.doubleCount;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mapGetters辅助函数，当我们需要多个getter的时候，可以使用mapGetters函数，将store里面的getter属性映射到，computed上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters([&quot;doneCount&quot;]),</span><br></pre></td></tr></table></figure><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters([&#123;doneCount:doneCount&#125;]),</span><br></pre></td></tr></table></figure><h4 id="vuex-mutation的使用"><a href="#vuex-mutation的使用" class="headerlink" title="vuex mutation的使用"></a>vuex mutation的使用</h4><p>修改，store里面的状态的唯一方法就是，mutation。</p><p>首先我们要在mutation方法里面注册一个，更改store的事件或者是方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  pluNum(state, payload) &#123;</span><br><span class="line">    console.log(state.count, payload);</span><br><span class="line">    state.count += payload;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mutation会有一个type，一个回调函数，实际上，pluNum，就是我们事件类型的type，而pluNum，就是我们的回调函数，是我们修改，它会接受state，作为一个参数，第二个参数为payload。</p><p>在回调函数内部，对store当中的state进行修改。</p><p>如何提交一个mutation呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.commit(&#x27;pluNum&#x27;, 10)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>store.commit()，第一个注册的mutation名字，第二个是传递过来的参数。</p><p>以对象的方式，提交mutation,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &lt;div</span><br><span class="line">    @click=&quot;</span><br><span class="line">      $store.commit(&#123;</span><br><span class="line">        type: &#x27;pluNum&#x27;,</span><br><span class="line">        data: 10,</span><br><span class="line">      &#125;)</span><br><span class="line">    &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    count自增</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> mutations: &#123;</span><br><span class="line">  pluNum(state, payload) &#123;</span><br><span class="line">    console.log(payload);</span><br><span class="line">    state.count += payload.data;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接受的时候，payload.data,就是要传递过来的参数。</p><p>使用常量代替mutation事件类型。</p><p>创建一个mutation-types.js文件来保存常量。使用export 导出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const PLUS_NUM = &quot;PLUS_NUM&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>store模块代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; PLUS_NUM &#125; from &quot;../mutation-types.js&quot;;</span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  [PLUS_NUM](state, payload) &#123;</span><br><span class="line">    console.log(payload);</span><br><span class="line">    state.count += payload.data;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提交store.commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  @click=&quot;</span><br><span class="line">    $store.commit(&#123;</span><br><span class="line">      type: &#x27;PLUS_NUM&#x27;,</span><br><span class="line">      data: 10,</span><br><span class="line">    &#125;)</span><br><span class="line">  &quot;</span><br><span class="line">&gt;</span><br><span class="line">  count自增</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Mutation必须是一个同步函数。</p><p>使用mapMutations提交 mutation函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;add(&#123; data: 12 &#125;)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">import &#123; mapState, mapGetters, mapMutations &#125; from &quot;vuex&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: &quot;PLUS_NUM&quot;,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vuex-Action"><a href="#vuex-Action" class="headerlink" title="vuex Action"></a>vuex Action</h4><p>action类似于mutation，不同是，</p><p>action是异步，action，可以提交mutation，但是不能直接改变，state的状态。</p><p>注册一个action</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment(&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      commit(&quot;PLUS_NUM&quot;, 12);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>action的分发。</p><p>actioon接受一个叫，context，和store实例对象相同的对象。<br>context，内置了，getter，commit，state，</p><p>载荷方式分发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&quot;increment&quot;, &#123; data: 15 &#125;);</span><br></pre></td></tr></table></figure><p>以对象形式分发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&#123;</span><br><span class="line">  type: &quot;increment&quot;,</span><br><span class="line">  data: 15,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在组件里面分发，action。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;increment(&#123; data: 15 &#125;)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line">import &#123;  mapActions &#125; from &quot;vuex&quot;;</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([&quot;increment&quot;]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>组合式Action。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA(&#123; commit &#125;, params) &#123;</span><br><span class="line">    return new Promise((resolve) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(params);</span><br><span class="line">        commit(&quot;PLUS_NUM&quot;, params);</span><br><span class="line">        resolve(&quot;actionA方法执行成功&quot;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  actionB(&#123; dispatch &#125;) &#123;</span><br><span class="line">    return dispatch(&quot;actionA&quot;, &#123; data: 11 &#125;).then(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;actionB方法执行成功&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">  add() &#123;</span><br><span class="line">    this.$store.dispatch(&quot;actionB&quot;, &#123; data: 11 &#125;).then((res) =&gt; &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vuex-module的使用"><a href="#vuex-module的使用" class="headerlink" title="vuex module的使用"></a>vuex module的使用</h4><p>由于使用单一状态树，所有的应用状态，都会集中到一个对象上，会导致整个store，变大，难易维护。为了解决这个问题，vuex允许我们，把store分割为module模块，每个模块拥有<br>state，getter，mutation，action。</p><p>关于module的命名空间。</p><p>默认的情况下，action，mutation，和getter，注册的是全局命名空间。这样以来，会导致，多个模块对同一个action，或者getter mutation做出响应。</p><p>假设我们在一个大项目，我们希望我们的模块有更高的复用性，封装度。可以开启模块的命名空间。。</p><p>给我们的user模块，打开命名空间。  namespaced: true,</p><p>一旦打开命名空间后，我们获取到的，getter派生出来的值，提交mutition，action都会发生变化。。</p><p>先从，getter说起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//vuex模块，</span><br><span class="line">getters: &#123;</span><br><span class="line">    doneCount(state) &#123;</span><br><span class="line">        return state.count * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">...mapGetters([&quot;doneCount&quot;]),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个时候控制台就会报错，error，[vuex] unknown getter: doneCount。因为，获取，state的时候，我们是这些写的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">  count: (state) =&gt; state.user.count,</span><br><span class="line">  plus: (state) =&gt; &#123;</span><br><span class="line">    return state.user.count;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接从，state.user模块，导出了，state的值。</p><p>开启命名空间后，获取user模块下面的getter，就得通过，mapGetter提供的对象写法。把user/doneCount的值映射到，”doneCount”上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">  doneCount: &quot;user/doneCount&quot;,</span><br><span class="line">&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么，如果我们要提交一个mutation呢，怎么办呢？</p><p>mapMutiton写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  //vuex部分</span><br><span class="line">  mutations: &#123;</span><br><span class="line">   [PLUS_NUM](state, payload) &#123;</span><br><span class="line">     state.count += payload.data;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line">...mapMutations(&#123;</span><br><span class="line">   PLUS_NUM: &quot;user/PLUS_NUM&quot;,</span><br><span class="line">&#125;),</span><br><span class="line"> </span><br><span class="line">&lt;div @click=&quot;PLUS_NUM(&#123; data: 11 &#125;)&quot;&gt;mutation自增&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>store.commit写法。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line"> [PLUS_NUM](state, payload) &#123;</span><br><span class="line">   state.count += payload.data;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"> //store.commit写法</span><br><span class="line"> test(data) &#123;</span><br><span class="line">   this.$store.commit(&quot;user/PLUS_NUM&quot;, data);</span><br><span class="line"> &#125;,</span><br><span class="line">&lt;div @click=&quot;test(&#123; data: 11 &#125;)&quot;&gt;mutation自增&lt;/div&gt;   </span><br></pre></td></tr></table></figure><p>action写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//mapActions写法</span><br><span class="line">...mapActions(&#123;</span><br><span class="line">  add: &quot;user/actionA&quot;,</span><br><span class="line">&#125;),</span><br><span class="line">//store.dispatch写法</span><br><span class="line">test(data) &#123;</span><br><span class="line">  this.$store.dispatch(&quot;user/actionA&quot;, data);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如，在vuex模块化当中，在b模块，获取到a模块的getter派生出来的值。要如何获取呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">这是模块a</span><br><span class="line">export default &#123;</span><br><span class="line">  namespaced: true,</span><br><span class="line">  state: &#123;</span><br><span class="line">    price: 100,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doublePrice(state) &#123;</span><br><span class="line">      return state.price * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模块b，</span><br><span class="line"></span><br><span class="line"> getters: &#123;</span><br><span class="line">    doneCount(state, getters, rootState, rootGetters) &#123;</span><br><span class="line">      console.log(&quot;另一个模块化getter的值&quot;,  </span><br><span class="line">      rootGetters[&quot;cart/doublePrice&quot;]);</span><br><span class="line">      return state.count * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>带命名空间的模块，如果想要使用全局的state，getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p><p>带命名空间绑定函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">  // ...mapState(&#123;</span><br><span class="line">  //   count: (state) =&gt; state.user.count,</span><br><span class="line">  //   plus: (state) =&gt; &#123;</span><br><span class="line">  //     return state.user.count;</span><br><span class="line">  //   &#125;,</span><br><span class="line">  // &#125;),</span><br><span class="line">  ...mapState(&quot;user&quot;, &#123;</span><br><span class="line">    count: (state) =&gt; state.count,</span><br><span class="line">    plus: (state) =&gt; state.count,</span><br><span class="line">  &#125;),</span><br><span class="line">  plusNum: () =&gt; &#123;</span><br><span class="line">    return thit.num + 10;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...mapGetters(&#123;</span><br><span class="line">  //   doneCount: &quot;user/doneCount&quot;,</span><br><span class="line">  // &#125;),</span><br><span class="line">  ...mapGetters(&quot;user&quot;, &#123;</span><br><span class="line">    doneCount: &quot;doneCount&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line">  thit = this;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations(&quot;user&quot;, &#123;</span><br><span class="line">    PLUS_NUM: &quot;PLUS_NUM&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  //mapActions写法</span><br><span class="line">  ...mapActions(&quot;user&quot;, &#123;</span><br><span class="line">    add: &quot;actionA&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  //store.dispatch写法</span><br><span class="line">  test(data) &#123;</span><br><span class="line">    this.$store.dispatch(&quot;user/actionA&quot;, data);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我有点反感，vuex 的写法。。mapstate(‘路径’，导出的参数)，这样只能导出一个模块的参数。觉得更低效了。。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>vuex核心概念，state，与，getter，mutation，action。</p><p>mutation与action的区别是，一个同步一个异步。任何对store进行修改的操作都要经过，mutation。</p><p>action，可以提交mutation。也可以多重action。嵌套着玩。</p><p>getter，派生出来的东西 rootgetter，获取其他模块的getter。</p><p>namespaced，开启空间命名。。</p>]]></content>
    
    
    <summary type="html">vuex当中的state，getter，mutation，action是干什么的？如何使用，如何开启vuex命名空间，如何模块化使用vuex</summary>
    
    
    
    <category term="js" scheme="http://yaru722.gitee.io/categories/js/"/>
    
    
    <category term="VueX" scheme="http://yaru722.gitee.io/tags/VueX/"/>
    
  </entry>
  
  <entry>
    <title>ES Modules的特性</title>
    <link href="http://yaru722.gitee.io/2022/12/06/es_modules%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://yaru722.gitee.io/2022/12/06/es_modules%E7%9A%84%E7%89%B9%E6%80%A7/</id>
    <published>2022-12-06T01:57:36.037Z</published>
    <updated>2022-12-06T01:58:37.092Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>很长的一段时间内，我以为，es modules的关键字import，export,只能在vue里面，使用，是因为webpack，这样的打包工具，才能得已实现的。<br>甚至让我觉得，原生js不行的原因就是因为，不支持es moduls。</p><p>陷入了一定的误区，这篇文章，来修正我的认知错误。</p><h5 id="原生js使用es-module进行模块化。"><a href="#原生js使用es-module进行模块化。" class="headerlink" title="原生js使用es module进行模块化。"></a>原生js使用es module进行模块化。</h5><p>使用script 加载js文件的时候 <strong><u>type = ‘module’</u></strong> 就可以开启模块化。</p><p><a href="https://imgse.com/i/xTjKx0"><img src="https://s1.ax1x.com/2022/11/01/xTjKx0.md.png" alt="xTjKx0.md.png"></a></p><h5 id="注意，es-module，默认开启的严格模式。我来证明给您看。"><a href="#注意，es-module，默认开启的严格模式。我来证明给您看。" class="headerlink" title="注意，es module，默认开启的严格模式。我来证明给您看。"></a>注意，es module，默认开启的严格模式。我来证明给您看。</h5><p><a href="https://imgse.com/i/xTj92t"><img src="https://s1.ax1x.com/2022/11/01/xTj92t.png" alt="xTj92t.png"></a></p><p><a href="https://imgse.com/i/xTjVaQ"><img src="https://s1.ax1x.com/2022/11/01/xTjVaQ.png" alt="xTjVaQ.png"></a></p><p>看吧，控制台上this是 undefined</p><h5 id="原生js，使用import，export"><a href="#原生js，使用import，export" class="headerlink" title="原生js，使用import，export"></a>原生js，使用import，export</h5><p>在上图的index.html文件下的index.js export抛出，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p><p>在test import，引入。<br><a href="https://imgse.com/i/xTjnGn"><img src="https://s1.ax1x.com/2022/11/01/xTjnGn.png" alt="xTjnGn.png"></a></p><p>控制台，打印的结果是，{a: 11}</p><h5 id="es-module，加载是通过cors进行的。"><a href="#es-module，加载是通过cors进行的。" class="headerlink" title="es module，加载是通过cors进行的。"></a>es module，加载是通过cors进行的。</h5><p>如果 <strong><script type='module' src=''> </script></strong><br>如果，这里的 <strong>src</strong>加载的是服务器资源的话，如果资源不支持cors的话，会被浏览器拦截。</p><p>例子如下，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p><p>支持，cors 加载的资源，type = ‘module’ 会被浏览器所加载，不支持cors的，会被浏览器拦截，这点服务端需要注意。</p><p><a href="https://imgse.com/i/xTj1qU"><img src="https://s1.ax1x.com/2022/11/01/xTj1qU.png" alt="xTj1qU.png"></a></p><p>cors，不支持文件的访问，所以，必须使用，http，serve的方式进行访问。</p><p><strong>使用，文件访问导致的后果</strong></p><p><a href="https://imgse.com/i/xTjlrT"><img src="https://s1.ax1x.com/2022/11/01/xTjlrT.png" alt="xTjlrT.png"></a></p><h5 id="es-module，自带脚本延迟效果"><a href="#es-module，自带脚本延迟效果" class="headerlink" title="es module，自带脚本延迟效果"></a>es module，自带脚本延迟效果</h5><p>当页面，加载完毕后，才会加载，es module脚本。<br><a href="https://imgse.com/i/xTjQMV"><img src="https://s1.ax1x.com/2022/11/01/xTjQMV.png" alt="xTjQMV.png"></a></p><p>当所有的，非es module加载完毕后，才能加载es module模块。</p><p>总结，<br>es module的特性是，<br>1，默认就是严格模式<br>2，每个module模块，都拥有私有的作用域。<br>3，只支持cors，加载。本地必须开启 web serve<br>4，自带延迟效果</p><h5 id="关于import-export-一些小知识。"><a href="#关于import-export-一些小知识。" class="headerlink" title="关于import export 一些小知识。"></a>关于import export 一些小知识。</h5><p>我们可以使用，export，到处一些变量方法，也可以，export，设置默认导出的方法。</p><p><a href="https://imgse.com/i/xTjEVg"><img src="https://s1.ax1x.com/2022/11/01/xTjEVg.jpg" alt="xTjEVg.jpg"></a></p><p>接收默认到处的值</p><p><a href="https://imgse.com/i/xTjiKf"><img src="https://s1.ax1x.com/2022/11/01/xTjiKf.png" alt="xTjiKf.png"></a></p><p>接收默认导出的值</p><p><a href="https://imgse.com/i/xTjmPs"><img src="https://s1.ax1x.com/2022/11/01/xTjmPs.png" alt="xTjmPs.png"></a></p><p><strong>as 关键字，修改默认导出的值</strong></p><p>export <strong>as关键字修改 变量名</strong></p><p><a href="https://imgse.com/i/xTj8ZF"><img src="https://s1.ax1x.com/2022/11/01/xTj8ZF.png" alt="xTj8ZF.png"></a></p><p><a href="https://imgse.com/i/xTjGa4"><img src="https://s1.ax1x.com/2022/11/01/xTjGa4.png" alt="xTjGa4.png"></a><br>import <strong>as修改接收参数的变量名</strong></p><h5 id="export-导出的并不是一个对象-import-引入的也不是个对象的解构。"><a href="#export-导出的并不是一个对象-import-引入的也不是个对象的解构。" class="headerlink" title="export 导出的并不是一个对象 import 引入的也不是个对象的解构。"></a>export 导出的并不是一个对象 import 引入的也不是个对象的解构。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">export &#123;</span><br><span class="line">    num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然export后面跟着 {} 看起来很像对象， { name },看起来很像es6，字面量的写法。</p><p>import 在这里 **{}**，就像使用对象字面量解构一样，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; num &#125; from &#x27;./test.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>export {}</strong> 和 <strong>import {}</strong> 是 es modulc的固定语法。</p><p>export 导出的只是，内存地址。<br>export 导出的，是常量。只能在 export 内部修改。</p><p><strong>例子如下</strong></p><p>导出num</p><p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p><p><a href="https://imgse.com/i/xTjNGR"><img src="https://s1.ax1x.com/2022/11/01/xTjNGR.png" alt="xTjNGR.png"></a></p><p>控制台报错，index.js:4 Uncaught TypeError: Assignment to constant variable.<br>    at index.js:4:4</p><p>因为，我们import引入的，<strong>num</strong> 是个常量。无法在外部，对 import 引入的 num进行修改。</p><p><strong>那么，怎么样导入，一个字面量对象呢？</strong></p><p>使用 <strong>export default</strong></p><p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p><h5 id="import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"><a href="#import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。" class="headerlink" title="import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"></a>import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。</h5><p>如果export 导入了很多属性。我们可以使用import * 把所有的导出全部接收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">let name = &#x27;张三&#x27;;</span><br><span class="line">let age = 12;</span><br><span class="line">let sigin = &#x27;为什么&#x27;</span><br><span class="line">export &#123;</span><br><span class="line">    num,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sigin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import * as module from &#x27;./test.js&#x27;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure><p>import * as module 导入全部的要导出的模块。</p><p>试想，我们有一个这样的需求，根据判断条件，来决定要导入，那个模块。</p><p>import 必须要在最外层，最顶层的作用域当中。不能嵌套在if，或者funtion当中。</p><p>es modulc，提供了一个，<strong>import</strong>函数，来帮助我们动态的导入模块。而且，import(),本身是一个promise函数。</p><p><a href="https://imgse.com/i/xTjFr8"><img src="https://s1.ax1x.com/2022/11/01/xTjFr8.png" alt="xTjFr8.png"></a></p><p>这样通过，then,那么就能读取到模块了。</p><p>import 可以导入一个，url链接模块<br><a href="https://imgse.com/i/xTju2q"><img src="https://s1.ax1x.com/2022/11/01/xTju2q.png" alt="xTju2q.png"></a></p><p>import 导出默认成员与，命名成员<br><a href="https://imgse.com/i/xTjkqS"><img src="https://s1.ax1x.com/2022/11/01/xTjkqS.png" alt="xTjkqS.png"></a></p><p>总结，es module，</p><ol><li>在原生js当中使用，script标签，type应该使用，module。module默认就在严格模式环境下，this不可能指向全局。</li><li>每个模块都拥有了独立的，私有的作用域。</li><li>module加载，模块，会存在cors问题，需要服务端专门设置，本地必须开启，web sever</li><li>type = module后，会存在延迟效果，等页面资源加载完毕后，再去加载。</li></ol><p>总结，import的特性</p><ol><li>import {} 并非对象的解构，而是语法就是这样的。</li><li>import，导入的属性，只可以读取。import导入的是常量，无法修改。</li><li>import * model from 可以把，所有导出的属性，全部导入到一个对象里面。</li><li>import，可以导入url模块，</li><li>import必须在顶部，不可以在函数，条件语句下面。</li><li>import()，可以动态导入，<strong>import</strong>默认本身就是一个promise方法。</li><li>import as 可以更换导入的属性别名。</li><li>import num，{age,age1} from ‘../../‘可以导入，默认的成员与命名的成员。</li></ol><p>总结，export的特性</p><ol><li>export {} 这是语法，抛出的不是一个，字面量对象，export default是抛出对象。</li><li>export 抛出去的值是内存地址的引用，值，只能在export模块里面修改。</li><li>as 可以修改默认要导出的值的别名。</li></ol>]]></content>
    
    
    <summary type="html">如何使用es modules进行模块化开发</summary>
    
    
    
    <category term="js" scheme="http://yaru722.gitee.io/categories/js/"/>
    
    
    <category term="import export的使用" scheme="http://yaru722.gitee.io/tags/import-export%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>初学webpack</title>
    <link href="http://yaru722.gitee.io/2022/12/06/%E5%88%9D%E5%AD%A6webpack/"/>
    <id>http://yaru722.gitee.io/2022/12/06/%E5%88%9D%E5%AD%A6webpack/</id>
    <published>2022-12-06T01:55:34.675Z</published>
    <updated>2022-12-06T01:56:25.988Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h5><blockquote><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些预设，打包为合适的格式以供浏览器使用。</p></blockquote><p>1，webpack可以分析你项目当中的代码，提取使用到的代码，去除用不到代码。<br>2，配合各种loader，来把sass，less，scss，ts，es新语法，解析成各种各样的文件。<br>3，帮忙把打包的项目，文件通过plugin，进行各种优化，比如压缩，混淆。</p><h5 id="webpack模块化打包的原因。"><a href="#webpack模块化打包的原因。" class="headerlink" title="webpack模块化打包的原因。"></a>webpack模块化打包的原因。</h5><ol><li>浏览器内核不同，对于技术支持的情况不一样，会存在兼容性问题。</li><li>模块化划分下，会增加多余的http请求次数。</li><li>不仅仅是js需要模块化，css，img，整个前端项目都需要，进行模块化。</li></ol><h5 id="webpack的概念"><a href="#webpack的概念" class="headerlink" title="webpack的概念"></a>webpack的概念</h5><p>webpack4以后，webpack配置默认的<strong>entry</strong>就是src目录下的js文件。<br><strong>output</strong>默认输出的path，就是dist下的main.js文件。</p><p>我们也可以，新建一个webpack.config.js文件。来设置，<strong>entry与output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//path是node里面的path</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //webpck的入口文件，要模块化打包的js代码目录，是个相对路径，&quot;./&quot;，不能丢。</span><br><span class="line">    entry: &#x27;./src&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;pc&#x27;),//path.resolve,是一个绝对路径，</span><br><span class="line">        filename: &#x27;dist.js&#x27;//要输出的文件名称</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于webpack的loader</strong></p><p>webpack，可以把，js代码模块化打包，但是，前端不仅仅是css需要打包。还有还有，css，ts，各种资源。</p><p>这个时候就得需要配置loader，来处理这些文件。</p><h5 id="webpack的工作模式"><a href="#webpack的工作模式" class="headerlink" title="webpack的工作模式"></a>webpack的工作模式</h5><table><thead><tr><th>webpack的工作模式</th><th>语法</th><th>特性</th></tr></thead><tbody><tr><td>开发环境</td><td>webpack –mode development</td><td>开发环境下的代码</td></tr><tr><td>原始环境</td><td>webpack –mode none</td><td>最原始的代码</td></tr><tr><td>生产环境</td><td>webpack –mode production</td><td>默认就是生产环境下的压缩代码</td></tr></tbody></table><h5 id="关于webpack的loader"><a href="#关于webpack的loader" class="headerlink" title="关于webpack的loader"></a>关于webpack的loader</h5><p><strong>如何去使用loader编译，css代码。</strong></p><p>首先使用npm，css loader。</p><p>npm i css-loder –dev<br>npm i style-loader –dev</p><p>然后设置。webpack.config.js配置的module。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rules，是数组，决定都要使用，那些loader，test，<br>use是个数组，指定要，使用哪些loader。</p><p><strong>use设置要使用的loader，打包的时候，会存在先后顺序，比如，把css文件，模块化，打包到，dist文件资源里面，css-loader，解析css文件上使用到的样式，而，style loadr 把样式放入，style到页面上。</strong></p><p>并且，通常我们都会把，所有的资源都汇总到，src/main.js，至少是个js文件到情况下。<br>要加载，或者使用到的css文件，直接import到，main.js页面就行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //webpck的入口文件，要模块化打包的js代码目录</span><br><span class="line">    entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main.js</span><br><span class="line"></span><br><span class="line">import createHeading from &#x27;./test.js&#x27;</span><br><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line">import &#x27;../sass/index.css&#x27;</span><br><span class="line">const heading = createHeading();</span><br><span class="line">console.log(createHeading())</span><br><span class="line">document.body.append(heading);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**entry: ‘./src/index.js’,**输出来的，webpack打包出来的还是一个js文件。顺便把css模块给整合进入。</p><h5 id="如何使用loader-file-loader与url-loader。"><a href="#如何使用loader-file-loader与url-loader。" class="headerlink" title="如何使用loader file-loader与url-loader。"></a>如何使用loader file-loader与url-loader。</h5><p>安装file-loader</p><p>yarn add file-loader</p><p>webpack.config.js配置 file-loader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;,</span><br><span class="line">        &#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: [&#x27;file-loader&#x27;] &#125;,</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后运行，yarn webapck 命令。</p><p>输出的dist目录下，会有图片。</p><p>但是，如果加载的项目静态资源过多的话，会导致，请求变多。网页卡顿。这个时候，url-loader，就能解决问题。</p><p>base64，可以减少我们http请求次数。</p><p>设置url-loader的情况下的前提下是，必须安装<strong>file-loader</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.(jpg|png|gif|bmp|jpeg)$/,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: &#x27;url-loader&#x27;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: 10 * 1024,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后通过，use下的option设置规则，limit: 10 * 1024,这里的10是字节，1024字节是1kb，大于10kb的图片，我们就通过，file-loader，加载到项目当中，小于10kb到情况下，就使用url-loader，base64.</p><h4 id="使用webpack-，转换es6代码。"><a href="#使用webpack-，转换es6代码。" class="headerlink" title="使用webpack ，转换es6代码。"></a>使用webpack ，转换es6代码。</h4><p>webpack，只是打包工具。虽然队，import，export，能够转换，但是，对es6并没有进行。</p><p>所以我们需要使用，bable-loader插件对es6的代码转换。</p><p>例子如下，</p><p><strong>安装bable-loader插件</strong></p><p>yarn add bable-loader @babel/core @babel/preset-env –dev</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.js$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&#x27;@babel/preset-env&#x27;],</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>option,选择 persets，使用@babel/preset-env插件。来对es6代码进行转换。。</p><h4 id="webpack加载的资源方式"><a href="#webpack加载的资源方式" class="headerlink" title="webpack加载的资源方式"></a>webpack加载的资源方式</h4><p>webpack不仅仅会通过css-loader 和style-loader 把css样式给打包到一个模块js文件里面。<br>也会，把图片资源 通过，file-loader 或者 url-loadr，打包到js文件里面。</p><p>连html都模块也可以打包，但是，html当中我们会引用到其他资源，比如a标签的地址，比如图片加载的资源文件。</p><p>所以我们先安装html-loader</p><p>yarn add html-loader @1.3.2</p><p>配置，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: /.html$/,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &#x27;html-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">        //仅仅限制版本号。1.3.2</span><br><span class="line">            attributes: &#123;</span><br><span class="line">                list: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        tag: &#x27;img&#x27;,</span><br><span class="line">                        attribute: &#x27;src&#x27;,</span><br><span class="line">                        type: &#x27;src&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        tag: &#x27;a&#x27;,</span><br><span class="line">                        attribute: &#x27;href&#x27;,</span><br><span class="line">                        type: &#x27;src&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过配置attributes的方式，对需要加载资源的标签，进行处理。。</p><h5 id="如何自己开发一个loader出来。。"><a href="#如何自己开发一个loader出来。。" class="headerlink" title="如何自己开发一个loader出来。。"></a>如何自己开发一个loader出来。。</h5><p><strong>weboack</strong>除了给我们提供了许许多多的loader以外，我们也可以开发自己的loader来进行使用。。</p><p>比如，我们需要把markdown 文件，在webpack打包的时候，转化为html，并且渲染到页面上。。</p><p>首先第一步，新建一个markdown-loader.js文件。在src目录下。。<br>然后安装yarn add marked</p><p>然后在weback-config.js下，配置loader<br>webpack-config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">               test: /.md$/,</span><br><span class="line">               use: [</span><br><span class="line">                   &#x27;./src/markdown-loader.js&#x27;,</span><br><span class="line">               ]</span><br><span class="line">           &#125;</span><br><span class="line">       ],</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>use,可指定加载相对路径的loader</p><p>//source 是webpack在打包过程中，输入的md文件<br>// return 出去必须是，js语法。通过<strong>module.exports</strong>或者 <strong>return export default</strong> 输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//引入 marked</span><br><span class="line">const marked = require(&#x27;marked&#x27;);</span><br><span class="line">module.exports = (source) =&gt; &#123;</span><br><span class="line">    const html = marked.marked(source);</span><br><span class="line">    return ` module.exports = $&#123;JSON.stringify(html)&#125;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就能在dist下的markdown 被转换到html到，bundle.js当中了。</p><p>当然loader之间可以相互配合使用，比如，markdown文件被转换到，html之后，我们也可以不选择，return export default html。</p><p>我们也可以交给，html-loader来处理。</p><hr><p>markdown-loader 和 html-loader 配合使用。。</p><p>mackdown-loader.js文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const marked = require(&#x27;marked&#x27;);</span><br><span class="line">module.exports = (source) =&gt; &#123;</span><br><span class="line">    const html = marked.marked(source);</span><br><span class="line">    return html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>webpack-config.js文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /.md$/,</span><br><span class="line">            use: [</span><br><span class="line">                &#x27;html-loader&#x27;,</span><br><span class="line">                &#x27;./src/markdown-loader.js&#x27;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="webpack-Plugins"><a href="#webpack-Plugins" class="headerlink" title="webpack Plugins"></a>webpack Plugins</h4><p>webpack plugins的功能可以，让我们在打包的时候，webpack运行到某个阶段的时候，帮我们做一些事情。</p><p>比如，在dist文件夹下面，生成html，比如，每次打包之前，清空dist文件夹。</p><p>例子如下，</p><p>安装CleanWebpackPlugin，每次打包的dist文件夹的时候，把dist文件下下面上次打包的资源文件清空。</p><p>yran add clean-webpack-plugin –dev</p><p>webpack-config.js下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">    ],</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再比如，dist文件夹下面每次打包发布资源的时候，都没有html页面。</p><p>这个时候，我们需要html-webpack-plugin，来使用。</p><p>yran add html-webpack-plugin –dev</p><p>webpack-config.js</p><p>template可以指定html模版作为，HtmlWebpackPlugin输出的index.html模版。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: &#x27;Webpack Plugin Sample&#x27;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            viewport: &#x27;width-device-width&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &#x27;./src/template.html&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">什么是webpack，webpack都有哪些特性</summary>
    
    
    
    <category term="js" scheme="http://yaru722.gitee.io/categories/js/"/>
    
    
    <category term="webpack初学" scheme="http://yaru722.gitee.io/tags/webpack%E5%88%9D%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何实现网站的哀悼模式</title>
    <link href="http://yaru722.gitee.io/2022/12/06/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%93%80%E6%82%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yaru722.gitee.io/2022/12/06/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%93%80%E6%82%BC%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-12-06T01:52:27.859Z</published>
    <updated>2022-12-06T01:54:01.681Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">body&#123;</span><br><span class="line"> filter: grayscale(100%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChat1d1ad09b1ab494616acafe5348a975e4.png" alt="黑白效果图"></p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6844904114053185544">明天全国哀悼日，一段css让全站变灰</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">mdn</a></p>]]></content>
    
    
    <summary type="html">使用一行代码，实现网站当中的哀悼模式</summary>
    
    
    
    <category term="css" scheme="http://yaru722.gitee.io/categories/css/"/>
    
    
    <category term="css" scheme="http://yaru722.gitee.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>什么是Data URL</title>
    <link href="http://yaru722.gitee.io/2022/12/06/DataUrl%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://yaru722.gitee.io/2022/12/06/DataUrl%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2022-12-06T01:50:06.179Z</published>
    <updated>2022-12-06T01:54:54.836Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Data-URL"><a href="#什么是Data-URL" class="headerlink" title="什么是Data URL"></a>什么是Data URL</h4><p>Data URL指的是，前缀为data:协议url。<br>现代浏览器将 <strong>Data URL</strong> 视作唯一的不透明来源，而不是可以用于导航的 URL，<br>不透明质指的是，在浏览器url上，输入上，一段比如<a href="https://baidu.com,我们可以看到这段url最终是要访问那里,而/">https://baidu.com,我们可以看到这段url最终是要访问那里，而</a> <strong>Data Url</strong>，则不是不透明，又长又臭，我们看不出这段url是什么。</p><h5 id="Data-URL语法"><a href="#Data-URL语法" class="headerlink" title="Data URL语法"></a>Data URL语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA2CAYAAAB3Ep8CAAAAAXNSR0IArs4c6QAABTtJREFUaEPVW1Fy4kYU7CflI1W4Kr5B2BME2wcInCDrE8ScIMbs/9oHAPkGi08Q7wnMBWDxDZwb2FUmlY/VvK0RiGAxM280SID5RTNMt1pv+vUIQvCndYwo+gyiFoB28DShA5mfQTQD4x4qvQNmzyFTUcggoNVGFH0BUTNsfMWjGDOotAvMZmVnDiCg1UYcP5T9odqv14pQqlOWhJIEtFqIogcQHdcOKOQHAkgoQcCBg88JY36CUie+NcGTgFYTUfTtYO98US2LmqAfB7EwehCgq338AIKu9uZPmmrGSxegEJWvxsSnFwB9sc7hSYJAgAd4cBfpdLQVmNDBEgnAGOmk45reQcCBg89RRafXIPpsVwKPoKZd2/d2AqJTvc9f2Nnb450vLio6G4HwZwgJZgIk8Iw7qImDnFBNbzFOJuEGanpd/IVNAt4j+BxVfHYP4I8yqn1LgFRUDvHOv0Gb9SdjEP3mS8L/BIjg+RFqat8Kt1BvtUM9SEhxDky0WrAkQPD3rMGrto+xqBZM6GwCCWuWmYDsYu3yzJ3duwOfk6atezwG4RcjjZlRmpwQotNLECWWi16g0ub7ufNFFAIJadrRBNyC6K8NAhgavJb9bi1uqOqt4xwkMN8Q7FvHPdLJeeXr2ceE8ZnOLzZTq4wAl5VkNpoHJ4YkOW4AzXmvV6lyjpKk/drrjUvz5/Q13NVFsIU4/ua7b7oWcDQYrHw5AzMQdbclopEkLWLWd1CHMM/M3Jv3+37Nl9QnpOmHxTZoqwM52rV900ZAYzC4INpoT5+/E5381+s9lb5zAArgV1Mopc7//fQp28etH9nX9KCmt7kPcDsoj6jpaDjU8vy9uCCthDlRB72eGE6sj/05SZo/MWtlmuK3r69XVx/t6M8+IsbfDnq+Ip1k49escOYHtGx/NW+JWeiogw/j3bQRoOcqTYKuI8wP+vk0rYWBu/nVlaUZE6K7gq8pNEM+5sEcNekihcWzauGPR/N+39qXrwYJ4PV134k+mB8rIbpj/gdKtdZ9jaEdDifBUgdW2JhlEhrD4Yhg7+2ZuWsugkKAY/E15jxALiDWlMUDgK7ityaZeIytFHyhBhSWVC8JG0Aag8El2Sz5oo7Yn3spw3Dklu5QVEpZHBM3BoMZufpyok5ubMRHpybwbgXkggglQRczpcYOEp6ZqEN6m3MXz8d5v2/OIUSVytGdx7lAZpT09mhPWWznAklyfKTUE4jMLSmQewPjURszP86jqG30EBWA91NApgT/gKFY3DI3p5SOqWwk2PbNl9coapoNlGDfs73eL73yU8CChCaieGYPGOxncktL6+g3Chwwv3AUtc19RDmj43LLJRSQT1OfR1hfKBOdWMAL6VWWYWij4917lFDAigTp/QDrcZRU7TPbXLHRqVgBy+nEAmQ/jnKZHTt4ALZQI0eYZha9dF4QoIDlL0q9tiNMMZFQl9GpRwHbegTd6w+HuhdfZJHMN6/9/saxVfbdFkRL4AOKoGFK6TjKI0yxLlR81GSjI5EQ/gisZg73CO7F+YcaEkjX9xUQsDJKwWHK5gKr3et3QEBGgsdJjM97O+VDjQNQwPZGaTFDWKhxQATo/Vp6ecnmEXYPvppdwER/CAlbhBqHpYAQj7An8PUpoAwJ2bXO9/1qfR+pom3QIUIpTHHpdwev5NRPgBSm2AgoEWocZg14syohTCki2OFbKTtQgKdHyC9bHGCUCjXegQJWJLjDlD28lbJDBSxJsHmEPYCvfxu0ajNLda/B+rWV5Z+f0vSyTJa3jezXx/4AhsQjITcm0vsAAAAASUVORK5CYII=</span><br><span class="line">    &quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>mediatype</strong>为image/png，指的是，文件的类型。<br>base64为64位字符表示二进制的流。</p><p>Data URL，减少http请求次数</p><p><a href="https://imgse.com/i/zyBco6"><img src="https://s1.ax1x.com/2022/12/05/zyBco6.jpg" alt="zyBco6.jpg"></a></p><p>Data URL，会占html文件的内存空间。<br><a href="https://imgse.com/i/zyBco6"><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog2.jpg" alt="zyBco6.jpg"></a></p><p>Data URL，加载的图片，不会被缓存下来，每次访问图片都得再下载一次。除非放入css当中缓存下来。</p><p>http加载的图片，只需要加载一次，就可以在页面上使用了，而每次使用Data URL作为图片，都会被重新加载。</p><p>base64 编码后的图片会比原来的体积大三分之一左右。</p><p>使用Data URL方式的Demo在渲染时会比不使用 多消耗53%左右的CPU资源，内存多出4倍左右，耗时平均高出24.6倍 。由此可见，使用Data URl方式还是需要更多的考量，在可接受的范围内适量使用。</p><p>Data URL的适用场景。</p><p>减轻http并发，减少http请求数量，加载icon的时候，或者作为css文件，引入，iconfont的时候。非常好用。</p>]]></content>
    
    
    <summary type="html">什么是Data URL,它的优点是什么，缺点是什么</summary>
    
    
    
    <category term="js" scheme="http://yaru722.gitee.io/categories/js/"/>
    
    
    <category term="使用Data URL，对页面进行优化" scheme="http://yaru722.gitee.io/tags/%E4%BD%BF%E7%94%A8Data-URL%EF%BC%8C%E5%AF%B9%E9%A1%B5%E9%9D%A2%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>使用es module模块化编程</title>
    <link href="http://yaru722.gitee.io/2022/11/01/%E5%85%B3%E4%BA%8Ees%20module%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yaru722.gitee.io/2022/11/01/%E5%85%B3%E4%BA%8Ees%20module%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2022-11-01T04:12:37.578Z</published>
    <updated>2022-11-01T05:12:11.781Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>很长的一段时间内，我以为，es modules的关键字import，export,只能在vue里面，使用，是因为webpack，这样的打包工具，才能得已实现的。<br>甚至让我觉得，原生js不行的原因就是因为，不支持es moduls。</p><p>陷入了一定的误区，这篇文章，来修正我的认知错误。</p><h5 id="原生js使用es-module进行模块化。"><a href="#原生js使用es-module进行模块化。" class="headerlink" title="原生js使用es module进行模块化。"></a>原生js使用es module进行模块化。</h5><p>使用script 加载js文件的时候 <strong><u>type = ‘module’</u></strong> 就可以开启模块化。</p><p><a href="https://imgse.com/i/xTjKx0"><img src="https://s1.ax1x.com/2022/11/01/xTjKx0.md.png" alt="xTjKx0.md.png"></a></p><h5 id="注意，es-module，默认开启的严格模式。我来证明给您看。"><a href="#注意，es-module，默认开启的严格模式。我来证明给您看。" class="headerlink" title="注意，es module，默认开启的严格模式。我来证明给您看。"></a>注意，es module，默认开启的严格模式。我来证明给您看。</h5><p><a href="https://imgse.com/i/xTj92t"><img src="https://s1.ax1x.com/2022/11/01/xTj92t.png" alt="xTj92t.png"></a></p><p><a href="https://imgse.com/i/xTjVaQ"><img src="https://s1.ax1x.com/2022/11/01/xTjVaQ.png" alt="xTjVaQ.png"></a></p><p>看吧，控制台上this是 undefined</p><h5 id="原生js，使用import，export"><a href="#原生js，使用import，export" class="headerlink" title="原生js，使用import，export"></a>原生js，使用import，export</h5><p>在上图的index.html文件下的index.js export抛出，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p><p>在test import，引入。<br><a href="https://imgse.com/i/xTjnGn"><img src="https://s1.ax1x.com/2022/11/01/xTjnGn.png" alt="xTjnGn.png"></a></p><p>控制台，打印的结果是，{a: 11}</p><h5 id="es-module，加载是通过cors进行的。"><a href="#es-module，加载是通过cors进行的。" class="headerlink" title="es module，加载是通过cors进行的。"></a>es module，加载是通过cors进行的。</h5><p>如果 <strong><script type='module' src=''> </script></strong><br>如果，这里的 <strong>src</strong>加载的是服务器资源的话，如果资源不支持cors的话，会被浏览器拦截。</p><p>例子如下，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p><p>支持，cors 加载的资源，type = ‘module’ 会被浏览器所加载，不支持cors的，会被浏览器拦截，这点服务端需要注意。</p><p><a href="https://imgse.com/i/xTj1qU"><img src="https://s1.ax1x.com/2022/11/01/xTj1qU.png" alt="xTj1qU.png"></a></p><p>cors，不支持文件的访问，所以，必须使用，http，serve的方式进行访问。</p><p><strong>使用，文件访问导致的后果</strong></p><p><a href="https://imgse.com/i/xTjlrT"><img src="https://s1.ax1x.com/2022/11/01/xTjlrT.png" alt="xTjlrT.png"></a></p><h5 id="es-module，自带脚本延迟效果"><a href="#es-module，自带脚本延迟效果" class="headerlink" title="es module，自带脚本延迟效果"></a>es module，自带脚本延迟效果</h5><p>当页面，加载完毕后，才会加载，es module脚本。<br><a href="https://imgse.com/i/xTjQMV"><img src="https://s1.ax1x.com/2022/11/01/xTjQMV.png" alt="xTjQMV.png"></a></p><p>当所有的，非es module加载完毕后，才能加载es module模块。</p><p>总结，<br>es module的特性是，<br>1，默认就是严格模式<br>2，每个module模块，都拥有私有的作用域。<br>3，只支持cors，加载。本地必须开启 web serve<br>4，自带延迟效果</p><h5 id="关于import-export-一些小知识。"><a href="#关于import-export-一些小知识。" class="headerlink" title="关于import export 一些小知识。"></a>关于import export 一些小知识。</h5><p>我们可以使用，export，到处一些变量方法，也可以，export，设置默认导出的方法。</p><p><a href="https://imgse.com/i/xTjEVg"><img src="https://s1.ax1x.com/2022/11/01/xTjEVg.jpg" alt="xTjEVg.jpg"></a></p><p>接收默认到处的值</p><p><a href="https://imgse.com/i/xTjiKf"><img src="https://s1.ax1x.com/2022/11/01/xTjiKf.png" alt="xTjiKf.png"></a></p><p>接收默认导出的值</p><p><a href="https://imgse.com/i/xTjmPs"><img src="https://s1.ax1x.com/2022/11/01/xTjmPs.png" alt="xTjmPs.png"></a></p><p><strong>as 关键字，修改默认导出的值</strong></p><p>export <strong>as关键字修改 变量名</strong></p><p><a href="https://imgse.com/i/xTj8ZF"><img src="https://s1.ax1x.com/2022/11/01/xTj8ZF.png" alt="xTj8ZF.png"></a></p><p><a href="https://imgse.com/i/xTjGa4"><img src="https://s1.ax1x.com/2022/11/01/xTjGa4.png" alt="xTjGa4.png"></a><br>import <strong>as修改接收参数的变量名</strong></p><h5 id="export-导出的并不是一个对象-import-引入的也不是个对象的解构。"><a href="#export-导出的并不是一个对象-import-引入的也不是个对象的解构。" class="headerlink" title="export 导出的并不是一个对象 import 引入的也不是个对象的解构。"></a>export 导出的并不是一个对象 import 引入的也不是个对象的解构。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">export &#123;</span><br><span class="line">    num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然export后面跟着 {} 看起来很像对象， { name },看起来很像es6，字面量的写法。</p><p>import 在这里 **{}**，就像使用对象字面量解构一样，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; num &#125; from &#x27;./test.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>export {}</strong> 和 <strong>import {}</strong> 是 es modulc的固定语法。</p><p>export 导出的只是，内存地址。<br>export 导出的，是常量。只能在 export 内部修改。</p><p><strong>例子如下</strong></p><p>导出num</p><p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p><p><a href="https://imgse.com/i/xTjNGR"><img src="https://s1.ax1x.com/2022/11/01/xTjNGR.png" alt="xTjNGR.png"></a></p><p>控制台报错，index.js:4 Uncaught TypeError: Assignment to constant variable.<br>    at index.js:4:4</p><p>因为，我们import引入的，<strong>num</strong> 是个常量。无法在外部，对 import 引入的 num进行修改。</p><p><strong>那么，怎么样导入，一个字面量对象呢？</strong></p><p>使用 <strong>export default</strong></p><p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p><h5 id="import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"><a href="#import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。" class="headerlink" title="import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"></a>import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。</h5><p>如果export 导入了很多属性。我们可以使用import * 把所有的导出全部接收。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">let name = &#x27;张三&#x27;;</span><br><span class="line">let age = 12;</span><br><span class="line">let sigin = &#x27;为什么&#x27;</span><br><span class="line">export &#123;</span><br><span class="line">    num,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sigin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import * as module from &#x27;./test.js&#x27;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure><p>import * as module 导入全部的要导出的模块。</p><p>试想，我们有一个这样的需求，根据判断条件，来决定要导入，那个模块。</p><p>import 必须要在最外层，最顶层的作用域当中。不能嵌套在if，或者funtion当中。</p><p>es modulc，提供了一个，<strong>import</strong>函数，来帮助我们动态的导入模块。而且，import(),本身是一个promise函数。</p><p><a href="https://imgse.com/i/xTjFr8"><img src="https://s1.ax1x.com/2022/11/01/xTjFr8.png" alt="xTjFr8.png"></a></p><p>这样通过，then,那么就能读取到模块了。</p><p>import 可以导入一个，url链接模块<br><a href="https://imgse.com/i/xTju2q"><img src="https://s1.ax1x.com/2022/11/01/xTju2q.png" alt="xTju2q.png"></a></p><p>import 导出默认成员与，命名成员<br><a href="https://imgse.com/i/xTjkqS"><img src="https://s1.ax1x.com/2022/11/01/xTjkqS.png" alt="xTjkqS.png"></a></p><p>总结，es module，</p><ol><li>在原生js当中使用，script标签，type应该使用，module。module默认就在严格模式环境下，this不可能指向全局。</li><li>每个模块都拥有了独立的，私有的作用域。</li><li>module加载，模块，会存在cors问题，需要服务端专门设置，本地必须开启，web sever</li><li>type = module后，会存在延迟效果，等页面资源加载完毕后，再去加载。</li></ol><p>总结，import的特性</p><ol><li>import {} 并非对象的解构，而是语法就是这样的。</li><li>import，导入的属性，只可以读取。import导入的是常量，无法修改。</li><li>import * model from 可以把，所有导出的属性，全部导入到一个对象里面。</li><li>import，可以导入url模块，</li><li>import必须在顶部，不可以在函数，条件语句下面。</li><li>import()，可以动态导入，<strong>import</strong>默认本身就是一个promise方法。</li><li>import as 可以更换导入的属性别名。</li><li>import num，{age,age1} from ‘../../‘可以导入，默认的成员与命名的成员。</li></ol><p>总结，export的特性</p><ol><li>export {} 这是语法，抛出的不是一个，字面量对象，export default是抛出对象。</li><li>export 抛出去的值是内存地址的引用，值，只能在export模块里面修改。</li><li>as 可以修改默认要导出的值的别名。</li></ol>]]></content>
    
    
    <summary type="html">js模块化编程</summary>
    
    
    
    <category term="ES6" scheme="http://yaru722.gitee.io/categories/ES6/"/>
    
    
    <category term="ES6模块化" scheme="http://yaru722.gitee.io/tags/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于JavaScript的严格模式那些事</title>
    <link href="http://yaru722.gitee.io/2022/06/08/JavaScript%E5%BD%93%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yaru722.gitee.io/2022/06/08/JavaScript%E5%BD%93%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-08T10:54:30.539Z</published>
    <updated>2022-06-08T10:56:01.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript通常情况下隐式运行在正常模式-“Sloppy Mode”，ES5及其版本之后，javaScript可以显示运行在严格模式-“Strict Mode”！在严格模式下。可以减少我们编写不安全的JavaScript代码，获得更加清大的错误检查机制。为了向后兼容，严格模式需要我们手动开启！</p></blockquote><ol><li>变量必须先声明后使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">console.log(&quot;🚀 ~ file: index.js ~ line 4 ~ a&quot;, a)</span><br><span class="line">a = 11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>函数型参不允许重复</li></ol><p>bad</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(x, y, y) &#123;</span><br><span class="line">   return x + y + y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(1, 2, 1));//Uncaught SyntaxError: Duplicate parameter name not allowed in this context (at index.js:4:21)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>good</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(x, y, z) &#123;</span><br><span class="line">   return x + y + z;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(1, 2, 1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>函数的arguments 在严格模式和非严格模式下也有区别。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">   console.dir(arguments)</span><br><span class="line">   console.log(arguments.callee, arguments.caller);</span><br><span class="line">   /**</span><br><span class="line">    * @非严格模式</span><br><span class="line">   0: (4) [1, 2, 3, 4]</span><br><span class="line">   callee: ƒ test()</span><br><span class="line">   length: 1</span><br><span class="line">   Symbol(Symbol.iterator): ƒ values()</span><br><span class="line">   [[Prototype]]: Object</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @严格模式</span><br><span class="line">    * 0: (4) [1, 2, 3, 4]</span><br><span class="line">      callee: [Exception: TypeError: &#x27;caller&#x27;, &#x27;callee&#x27;, and &#x27;arguments&#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them at Arguments.s (&lt;anonymous&gt;:1:83)]</span><br><span class="line">      length: 1</span><br><span class="line">      Symbol(Symbol.iterator): ƒ values()</span><br><span class="line">      get callee: ƒ ()</span><br><span class="line">      set callee: ƒ ()</span><br><span class="line">      [[Prototype]]: Object</span><br><span class="line">   */</span><br><span class="line">&#125;</span><br><span class="line">test([1, 2, 3, 4]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>严格模式下的arguments消失了。</p><p>arguments.callee, arguments.caller</p><h4 id="width不可用"><a href="#width不可用" class="headerlink" title="width不可用"></a>width不可用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">   name: &#x27;使用with读取对象属性&#x27;</span><br><span class="line">&#125;</span><br><span class="line">with (obj) &#123;//严格模式下将禁用with关键字</span><br><span class="line">   console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="八进制数不可用"><a href="#八进制数不可用" class="headerlink" title="八进制数不可用"></a>八进制数不可用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">console.log(010 === 8)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="严格模式下的this指向"><a href="#严格模式下的this指向" class="headerlink" title="严格模式下的this指向"></a>严格模式下的this指向</h4><p>请注意：这里的函数时非方法函数！因为方法与对象挂钩，有具体的this!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line">function foo() &#123;</span><br><span class="line">   console.log(this)//undefined</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结</p><ul><li>js严格模式下 必须要显式声明变量才允许使用</li><li>width 方法不可用</li><li>arguments少了一些东西</li><li>八进制不可用</li><li>非方法函数this指向undefined</li><li>形参不允许 重复定义</li></ul>]]></content>
    
    
    <summary type="html">严格模式是什么，为什么要有严格模式，都有哪些限制</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="严格模式" scheme="http://yaru722.gitee.io/tags/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的去console</title>
    <link href="http://yaru722.gitee.io/2022/06/08/%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8Cconsole/"/>
    <id>http://yaru722.gitee.io/2022/06/08/%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8Cconsole/</id>
    <published>2022-06-08T10:52:01.196Z</published>
    <updated>2022-06-08T10:53:44.747Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不要再去console一把梭了。"><a href="#不要再去console一把梭了。" class="headerlink" title="不要再去console一把梭了。"></a>不要再去console一把梭了。</h4><h5 id="使用console-time-console-timeEnd"><a href="#使用console-time-console-timeEnd" class="headerlink" title="使用console.time,console.timeEnd"></a>使用console.time,console.timeEnd</h5><p>可以获取到代码的执行时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.time(1);</span><br><span class="line">console.timeEnd(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Console-assert-如果结果是true-就不会打印出来。"><a href="#Console-assert-如果结果是true-就不会打印出来。" class="headerlink" title="Console.assert()如果结果是true 就不会打印出来。"></a>Console.assert()如果结果是true 就不会打印出来。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let len = 10;</span><br><span class="line">console.assert(len !== 10, &#x27;失败&#x27;);</span><br></pre></td></tr></table></figure><h5 id="console-trace对栈的追踪"><a href="#console-trace对栈的追踪" class="headerlink" title="console.trace对栈的追踪"></a>console.trace对栈的追踪</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.trace(test)</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="console-table-打印出来一个表格，比较适合对-引用类型的数据"><a href="#console-table-打印出来一个表格，比较适合对-引用类型的数据" class="headerlink" title="console.table 打印出来一个表格，比较适合对 引用类型的数据"></a>console.table 打印出来一个表格，比较适合对 引用类型的数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let tableData = [&#123;</span><br><span class="line">    date: &#x27;2016-05-02&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1518 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-04&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1517 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-01&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1519 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-03&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1516 弄&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">console.table(tableData)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据的展示会更加直观。。</p><h5 id="对log进行分级"><a href="#对log进行分级" class="headerlink" title="对log进行分级"></a>对log进行分级</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">console.info(1);</span><br><span class="line">console.debug(1);</span><br><span class="line">console.warn(1);</span><br><span class="line">console.error(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>像百度一样骚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;每一个星球都有一个驱动核心，\n每一种思想都有影响力的种子。\n感受世界的温度，\n年轻的你也能成为改变世界的动力，\n百度珍惜你所有的潜力。\n你的潜力，是改变世界的动力！\n\n&quot;), console.log(&quot;%c百度2022校园招聘简历投递：https://talent.baidu.com/external/baidu/campus.html&quot;, &quot;color:red&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">求求，不要再去console.log一把梭了。</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="console" scheme="http://yaru722.gitee.io/tags/console/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript标签页通讯问题</title>
    <link href="http://yaru722.gitee.io/2022/06/08/js%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF/"/>
    <id>http://yaru722.gitee.io/2022/06/08/js%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF/</id>
    <published>2022-06-08T10:49:36.039Z</published>
    <updated>2022-06-08T10:51:27.238Z</updated>
    
    <content type="html"><![CDATA[<h4 id="浏览器中的标签页如何通讯"><a href="#浏览器中的标签页如何通讯" class="headerlink" title="浏览器中的标签页如何通讯"></a>浏览器中的标签页如何通讯</h4><ol><li>标签页必须是同源的页面，必须是同源的页面。</li><li>使用BroadcastChannel。</li></ol><p>例子如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let channel = new BroadcastChannel(&#x27;test&#x27;);</span><br><span class="line">channel.postMessage(&#x27;hello,word&#x27;)</span><br><span class="line">channel.onmessage = (res =&gt; &#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">&#125;)</span><br><span class="line">channel.onmessageerror = (err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例话BroadcastChannel<br>postMessage方法发送数据</p><p>onmessageerror 监听错误信息<br>onmessage 获取消息</p>]]></content>
    
    
    <summary type="html">浏览器标签页进行通讯（同源）</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6中的Promise</title>
    <link href="http://yaru722.gitee.io/2022/05/30/%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yaru722.gitee.io/2022/05/30/%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</id>
    <published>2022-05-30T14:13:38.581Z</published>
    <updated>2022-05-30T14:16:14.941Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>关于ES6中<strong>promise</strong>的使用，我已经熟练掌握了不少。至少能顺顺利利的写上一个异步方法。<br>但是对promise的理解使用 并没有得到提高。</p><p>比如，有这么一个场景，我需要发送5个接口。拿到5个接口里面的数据，且必须五个接口全部请求完毕，有结果了，我才能拿到。因为接口的响应时间不一样的，而且这个业务里面不想，a接口好了，去请求b接口。而是abcde5个接口一起请求。</p><p>这就是我，重新细读promsie的原因。</p><h5 id="关于promise的特点。"><a href="#关于promise的特点。" class="headerlink" title="关于promise的特点。"></a>关于promise的特点。</h5><ol><li><p>promise有3个状态， pending（进行中），和fulfilled（已成功），和rejected（已失败）。只有异步操作才能决定promise当前是哪一种状态，任何操作都无法改变</p></li><li><p>promsie的状态一旦改变就不可能逆转。比如从pending状态，到rejected状态。这个状态，就会凝固，不会再改变了，这个就称为resolved（已定型）。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">primise-&gt;&gt;fulfilled或rejected:异步操作才能决定promise当前的状态。</span><br><span class="line">fulfilled或rejected-&gt;&gt;primise:状态处于resolved状态凝固不可改变。</span><br></pre></td></tr></table></figure><h5 id="关于promise的一些缺点。"><a href="#关于promise的一些缺点。" class="headerlink" title="关于promise的一些缺点。"></a>关于promise的一些缺点。</h5><ul><li>promise一旦建立就无法取消。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;11&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码里面的log会立刻执行。</p><ul><li>promise异步执行的时候，我们无法知道他在哪一步。</li></ul><h5 id="promise的then"><a href="#promise的then" class="headerlink" title="promise的then"></a>promise的then</h5><p>primise的then方法，能够接受2个回调函数做参数使用。第一个是，当pending状态改变为，fulfilled调用，另一个是pending状态改变为，reject调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(11);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(function (res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="promise-catch-只能接受一个回调函数做参数使用。"><a href="#promise-catch-只能接受一个回调函数做参数使用。" class="headerlink" title="promise catch 只能接受一个回调函数做参数使用。"></a>promise catch 只能接受一个回调函数做参数使用。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(11);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(function (res) &#123;</span><br><span class="line">    console.log(res);//没有打印结果</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="如果promise里面有同步执行的代码呢？？？"><a href="#如果promise里面有同步执行的代码呢？？？" class="headerlink" title="如果promise里面有同步执行的代码呢？？？"></a>如果promise里面有同步执行的代码呢？？？</h5><p>我们可以来看一段代码的执行顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function promise(time) &#123;</span><br><span class="line">    console.log(&#x27;预计执行时间:&#x27;, time / 1000);</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;欢迎来到promise:&#x27;);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;promise结果:resolve&#x27;);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;codeing&#x27;);</span><br><span class="line">promise(3000).then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;执行结束&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正确的执行顺序应该是：</p><ol><li>codeing</li><li>预计执行时间</li><li>欢迎来到promise</li><li>promise结果</li><li>执行结束。</li></ol><p>promise异步操作执行的时候，除了pending 状态发生改变之前，都是同步的代码。<br>当定时器结束，异步操作的状态改变。我们通过then 或者catch来回调promise的结果。</p><p>使用promise异步加载图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function imgaeLoad(src) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let image = new Image();</span><br><span class="line">        image.src = src;</span><br><span class="line">        image.onload = function () &#123;</span><br><span class="line">            resolve(&#x27;succss&#x27;);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = function () &#123;</span><br><span class="line">            reject(&#x27;error&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">imgaeLoad(&#x27;https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/04/26/6267bb50cad26.jpeg&#x27;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="关于promise的异步操作的结果是返回另一个异步操作"><a href="#关于promise的异步操作的结果是返回另一个异步操作" class="headerlink" title="关于promise的异步操作的结果是返回另一个异步操作"></a>关于promise的异步操作的结果是返回另一个异步操作</h5><p>如果调用resolve或者reject函数带有参数，那么参数会被传递到回调函数。<br>reeject通常的参数是new Error的参数实例，无论reslove，还是reject来说，都有可能接受一个promise实例作为参数。</p><p>比如下面这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        reject(new Error(&#x27;fail&#x27;))</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(p1)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>p2的resolve的方法，将p1作为参数，即一个异步操作的结果返回另一个异步操作。</p><p>这个时候p1的状态就会传递给p2，如果p1，在pending，那么p2会等待。直到p1的状态从pending改变到resolved，或者rejectd，这个时候。p2的回调函数会马上执行。。</p><p>白话文就是，如果p2的异步操作把p1作为参数的话。那么p2的回调函数的状态就由p1异步操作来决定。</p><p>再浅一点，p2的异步操作如果把p1作为参数的话。那么p1的异步操作会执行，且他的状态影响着p2回调函数的状态。又或者说p1的状态结果就是p2的。</p><p>对于promise 方法来说，一旦状态从resolved 到 rejectd后。接下来的操作，直接在then，和catch里面操作就行了。</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段方法会导致，即便是promise 状态已经改变了，log方法也还是执行了。所以一旦状态从resolved 到 rejectd后，一定要return出去。</p><h5 id="关于promise的链式调用。"><a href="#关于promise的链式调用。" class="headerlink" title="关于promise的链式调用。"></a>关于promise的链式调用。</h5><p>曾经做过微信服务商入驻哪一块。需要调上传接口，上传图片，然后在上传给图片给微信，然后再去给后端。</p><p>要发送4个请求，其中错了一个之后，就算失败。<br>于是代码就成了这个样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">promiseA().then(()=&gt;&#123;</span><br><span class="line">    promiseB().then(()=&gt;&#123;</span><br><span class="line">            promiseC().then(()=&gt;&#123;</span><br><span class="line">                 promiseD().then(()=&gt;&#123;</span><br><span class="line">        </span><br><span class="line">                &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是promise 是可以使用链式调用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结其他来是，链式调用可以避免回调地狱的产生，你需要then下去就好了。<br>无非就promiseA好了那就去调用promiseB。如果失败了直接在catch捕捉就可以了。</p><p>当然如果promiseA失败了，catch捕捉到的肯定是，promiseA的catch。</p><p>我们只需要在第五个then下面，进行操作就可以了。</p><p>好处是。catch捕捉一次就够了。</p><h5 id="关于promise的catch"><a href="#关于promise的catch" class="headerlink" title="关于promise的catch"></a>关于promise的catch</h5><ol><li>promise的catch具有冒泡性。</li></ol><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段方法会导致，即便是promise 状态已经改变了，log方法也还是执行了。所以一旦状态从resolved 到 rejectd后，一定要return出去。</p><h5 id="关于promise的链式调用。-1"><a href="#关于promise的链式调用。-1" class="headerlink" title="关于promise的链式调用。"></a>关于promise的链式调用。</h5><p>曾经做过微信服务商入驻哪一块。需要调上传接口，上传图片，然后在上传给图片给微信，然后再去给后端。</p><p>要发送4个请求，其中错了一个之后，就算失败。<br>于是代码就成了这个样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">promiseA().then(()=&gt;&#123;</span><br><span class="line">    promiseB().then(()=&gt;&#123;</span><br><span class="line">            promiseC().then(()=&gt;&#123;</span><br><span class="line">                 promiseD().then(()=&gt;&#123;</span><br><span class="line">        </span><br><span class="line">                &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是promise 是可以使用链式调用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不管是say1 到say5promise方法，只要有一个错误都会被catch捕捉到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>且尽可能不要尝试在then方法里面捕捉，错误信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say1().then(function (value) &#123;</span><br><span class="line">    console.log(&#x27;succss&#x27;);</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // failure</span><br><span class="line">    console.log(&#x27;error&#x27;);</span><br><span class="line">&#125;)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>promise方法的任何报错都会导致，promise进入rejected状态，被catch捕捉到错误信息。</p><p>比如我们人为制造一些报错信息。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">        let a;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say1().then(succss =&gt; &#123;</span><br><span class="line">    console.log(succss);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本身promise应该是resolved的。因为报错信息，导致变成rejected，然后被catch捕捉。</p><p>promise 会把报错信息给吞掉。</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const someAsyncThing = function () &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        // 下面一行会报错，因为x没有声明</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">someAsyncThing().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">&#125;, 2000)//11</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在promise中如果没有使用catch函数去接受捕捉错误信息的话，promsie对象抛出错误，不会传递到外层的代码。也不会有任何反应。</p><p>在看下个例子，当promise已经结束了，下轮事件循环再抛出错误，这个时候，promise已经执行完毕了，所以这个错误是promise函数体外抛出的，会冒泡到最外层。导致无法捕获该错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let test = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&#x27;succss&#x27;);</span><br><span class="line">    setTimeout(function () &#123; throw new Error(&#x27;test&#x27;) &#125;, 0)</span><br><span class="line">&#125;)</span><br><span class="line">test.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>promise 可以运行catch函数方法，再去运行，then函数方法。如果没有报错会绕过catch，运行then方法指定的回调函数。。</p><p>如果存在报错，catch捕捉错误后继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;errors:&#x27;, error);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    alert(&#x27;11&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>没有报错，catch被绕过，直接执行then。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function p1(x = 1) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;errors:&#x27;, error);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>catch内部也会报错。如果catch报错了，在后面再写一个catch捕获错误信息就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return p1();</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    y + 2;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="promise-finally方法。"><a href="#promise-finally方法。" class="headerlink" title="promise finally方法。"></a>promise finally方法。</h5><p>不管promise的状态如何，他都会执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(0);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;).finally(e =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>then回调函数与finally函数，分别console.log出来了，0和1</p><h5 id="promise-all"><a href="#promise-all" class="headerlink" title="promise all"></a>promise all</h5><p>假设，我是说假设，我们有3个promise方法，p1，p2，p3。<br>让p1，p2，p3，几乎同时发送，p1，p2，p3全部是resloved，那就then回调函数捕获。不然就使用，catch捕获。。</p><p>我们该怎么去写呢。</p><p>这个时候就可以使用promise all来处理。</p><p>例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            resolve(&#x27;p3成功&#x27;);</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1(), p2(), p3()]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise.all（）把p1-p3函数全部放入。</p><p>等到p1-p3函数的promise状态全部都为resovled 或者rejected的话。promise.all的状态是rejected或者resovled</p><p>promise.all的成员可以不是数组，但是必须具有Iterator，且每个成员都是返回了promise实例。</p><p>如果primise.all内的promise实例，catch捕获了错误信息，那么promise.all，的状态不会受rejected的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            reject(new Error(&#x27;p3失败&#x27;));</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1(), p2(), p3().catch(err =&gt; &#123; console.log(err); &#125;)]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//因为p3函数使用catch函数捕获了，报错信息。所以promise.all的 没有捕获到错误，导致还是then回调函数正常使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="promise的race方法。"><a href="#promise的race方法。" class="headerlink" title="promise的race方法。"></a>promise的race方法。</h5><p>promise.race 函数的特点是，假设，我们拥有，p1-p3多个promise函数，如果p2promise方法，状态首先改变了，那么会改变promise.race的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            reject(new Error(12121));</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.race([p1(), p2(), p3()]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和promise.all不同，里面的成员必须是promise实例。promise.race，成员什么参数都可以接收。。</p><p>并且，promise.race()的成员里非primise实例的成员，会立马，触发promise.race的then回调函数。</p><h5 id="promise-race，all的区别。"><a href="#promise-race，all的区别。" class="headerlink" title="promise race，all的区别。"></a>promise race，all的区别。</h5><p>promise all，p1-p4….promise方法，同时执行，全部成功了，会成功，一个失败，那就是失败咯，all方法的成员不一定非得是数组，但是一定要有，有Iterator接口。</p><p>promise race，p1-p4…..promise方法，promis.race的实例的状态是，p1-p4promise函数中那个函数的结果改变了，那么改变的状态就是promise.race的状态。</p><h5 id="promise-allSettled方法。"><a href="#promise-allSettled方法。" class="headerlink" title="promise allSettled方法。"></a>promise allSettled方法。</h5><p>假设，我们有p1-p4，4个promise实例，不管成功与否，我都想让他走完，又或者（等待所有的promise实例，全部结束），再去做一些操作。</p><p>promise.all的前提是，p1-p4实例，必须要走完，才能进行操作，如果但凡有个失败，那就直接报错，不管另外的promise是否结束。。</p><p>alisettled不是这样的，promise多个实例，都会执行，并且全部执行结束了promise.allsettled的promise状态才改变，并且then回调函数下面，我们会拿到所有promise的结果，以对象的形式</p><h5 id="关于promise的any"><a href="#关于promise的any" class="headerlink" title="关于promise的any"></a>关于promise的any</h5><p>与promise，reac函数不同的是，reac，在promise实例当中，找到最快响应的实例，</p><p>promise，any，找到最快响应的实例，必须得是，resovled，状态的。</p><p>p1-p4，4个promise实例，是promise，any的成员。<br>p1-p4，最快执行完毕，且实例本身，是resolved的，成为any的状态。<br>假设p1-p4全部rejected的话，那么，就得使用catch去捕获异常。。</p><p>p1-p4，只要有一个resolved，那就算成功了。</p><h5 id="关于promise-try"><a href="#关于promise-try" class="headerlink" title="关于promise try"></a>关于promise try</h5><p>关于promise的执行顺序。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(0);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印的顺序居然是，1 0；</p><p>因为promise是异步函数，除非你给他做一个匿名立即执行函数。绕过去。不然的话。</p><p>可是我们即想要使用，promise函数，但也没有什么，异步操作。。。</p><p>这个时候，promise，try就诞生了。</p><p>promise try文档不全，最新还没有进行适配。后面补上。。</p><h5 id="关于promise-resolve。"><a href="#关于promise-resolve。" class="headerlink" title="关于promise resolve。"></a>关于promise resolve。</h5><ol><li>primise resolve，可以将一个对象转换为，promise方法。</li></ol><p>promise.resolve等于 new prmise((resolve,reject)=&gt;{});</p><p>例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let object = &#123;</span><br><span class="line">    name: 111,</span><br><span class="line">    age: &#x27;12&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Promise.resolve(object);</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res.name)//111</span><br><span class="line">&#125;)</span><br><span class="line">console.log(p1)//Promise &#123;&lt;fulfilled&gt;: &#123;…&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功的把一个promise例子转换为，真实的例子。</p><p>primise.resolve()的参数有四种。</p><p>resolve()的参数是一个promise实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(12121);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Promise.resolve(p3())</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//12121</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>promise.resolve参数返回的还是promise实例。。</p><p>resolve(),thenable，参数。<br>thenable对象，指的是具有，then方法的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(&#123;</span><br><span class="line">    then: () =&gt; &#123;</span><br><span class="line">        console.log(11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//11</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>resolve,then对象调用执行后，对象p1的状态就回变为resolved。</p><p>参数不是具有then()方法的对象，或根本就不是对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(&#x27;11&#x27;)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//11</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为hello不属于一步操作，返回promise的实例状态从医生称就是resloved，所以回调函数立即执行。<br>同时会传给回调函数。。</p><p>如果promise.resolved,不带参数。那么直接返回resolved状态的promise对象。</p><p>立即执行的promise对象，是在本轮事件循环结束时执行，而不是在下一轮事件循环开始时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(0)</span><br><span class="line">let p1 = Promise.resolve(1)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;, 0)</span><br><span class="line">// 0 1 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="promise-reject"><a href="#promise-reject" class="headerlink" title="promise.reject(),"></a>promise.reject(),</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">p1.catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">/**</span><br><span class="line"> * Promise.reject(&#x27;出错了&#x27;) === new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line"> * reject</span><br><span class="line"> * &#125;)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">今天总算耐着性子吧，阮一峰大佬的ES6的Promise认认真真的过了一遍，有些心得体会</summary>
    
    
    
    <category term="ES6" scheme="http://yaru722.gitee.io/categories/ES6/"/>
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>js中的包管理器</title>
    <link href="http://yaru722.gitee.io/2022/04/14/%E5%85%B3%E4%BA%8Enpm%E4%B8%8Eyran%E5%92%8Ccnpm%E5%8C%85%E6%8B%ACpnpm%E3%80%82/"/>
    <id>http://yaru722.gitee.io/2022/04/14/%E5%85%B3%E4%BA%8Enpm%E4%B8%8Eyran%E5%92%8Ccnpm%E5%8C%85%E6%8B%ACpnpm%E3%80%82/</id>
    <published>2022-04-14T06:41:25.017Z</published>
    <updated>2022-04-14T06:42:43.945Z</updated>
    
    <content type="html"><![CDATA[<ol><li>npm早起pages.json来确定node_modules依赖树关系，而且众所周知的原因，慢。v5版本之后多了，package-lock.json文件，锁定了依赖的版本，保证我们每次都能下到正确版本的依赖。</li><li>yran性能好，体积会小一些。早起的时候npm没有package-look.json。</li><li>pnpm超级快，体积小，掘金社区，说依赖少一些，不稳定。没有声明使用的依赖，好想存在一些问题。观望。</li><li>前端项目当中，一定要保持node版本，和包管理器的版本一致。</li></ol>]]></content>
    
    
    <summary type="html">js中的包管理器</summary>
    
    
    
    <category term="js" scheme="http://yaru722.gitee.io/categories/js/"/>
    
    
    <category term="js" scheme="http://yaru722.gitee.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript闭包（Closure）</title>
    <link href="http://yaru722.gitee.io/2022/04/14/%E5%AD%A6%E4%B9%A0Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/"/>
    <id>http://yaru722.gitee.io/2022/04/14/%E5%AD%A6%E4%B9%A0Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/</id>
    <published>2022-04-14T06:38:37.809Z</published>
    <updated>2022-04-14T06:40:45.499Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。"><a href="#在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。" class="headerlink" title="在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。"></a>在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。</h5><p>不bb上代码！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = 0;</span><br><span class="line">function parent() &#123;</span><br><span class="line">    var b = 1;</span><br><span class="line">    console.log(a, b);</span><br><span class="line">    function son() &#123;</span><br><span class="line">        var c = 2;</span><br><span class="line">        console.log(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">parent();</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><ol><li>我们可以在任何地方访问变量，全局变量a。</li><li>局部变量，b，c，parent函数，只能访问到局部变量，b。son函数的作用域变量，parent无法访问。</li><li>son函数，访问，a，b，c变量的过程就是一个完整的作用域链。是一个向上的过程。</li></ol><p>通俗的语言表达，son作用域就是一个鱼缸，parent作用域是一个池塘。son可以通过吸管来抽取parent作用域的水（变量）;</p><h5 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h5><p>闭包问题，让池塘拿出吸管来抽取鱼缸的水（变量）的过程。</p><p><strong>所以，如何在外部访问函数内部的变量呢？</strong></p><p>看个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line">let val = parent();</span><br><span class="line">console.log(val);//0</span><br></pre></td></tr></table></figure><p>这里我们把parent函数直接return出去，就拿到了内部变量了，吗？</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    ++num;</span><br><span class="line">    console.log(num);</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line">parent();//1</span><br><span class="line">parent();//1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们执行了，2次parent函数，log打印出来的只有1，1。<br>函数的内部变量为什么只做了一次自增就就没有了呢？？？？</p><p>这里不得不谈的js的执行机制问题。</p><p>太复杂的不想谈，parnt方法执行完毕之后，整个方法，连变量都被回收了，num变量值只拿到了自增一次后的，parnt函数的返回值。</p><p>可以把js执行理解为一个机器，parent执行，回收掉。返回值1，parent执行，回收掉返回值1。</p><h5 id="如何得到一个闭包呢？"><a href="#如何得到一个闭包呢？" class="headerlink" title="如何得到一个闭包呢？"></a>如何得到一个闭包呢？</h5><p>我们可以看看闭包需要达成的条件。</p><ol><li>外部函数能够访问，内部函数的变量。</li><li>内部的变量可以一直存在内存里面，不会被js的垃圾回收机制回收掉。</li></ol><h6 id="如何在外部访问部分的函数变量。"><a href="#如何在外部访问部分的函数变量。" class="headerlink" title="如何在外部访问部分的函数变量。"></a>如何在外部访问部分的函数变量。</h6><p>在函数内部在创建一个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    son();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>son有权利访问，parent内部的所有变量。那么我们如果把son函数当作返回值，在外部不就能拿到，函数内部的变量了吗。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">val();//0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这个例子，只能证明，外部函数可以访问得到parent函数的内部。可是函数内部的变量，有没有被垃圾回收，下面这个例子就能证明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    add = function () &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    minus = function () &#123;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">minus();</span><br><span class="line">val();//2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在函数内部，声明了2个全局变量方法。一个做自增，一个做自减。</p><p>还有一个例子也能证明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        num: 0</span><br><span class="line">    &#125;;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">var c1 = val();</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">console.log(c1.num, val());//6,6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cl.num 与函数内部的变量完全相等。<br>son函数就是 闭包。在parent函数内部，通过return，与外部函数建立一条通道。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>闭包就是外部函数访问内部函数变量，且函数内部的变量一直在内存里得到保留，不会被垃圾回收。</p><p>产生闭包的原因是，因为，外部函数引用了函数内部的函数，导致不会进行垃圾回收，变量得到了保留。</p><p>这就是函数内部建立函数，return函数内部给外部函数的原因。</p><h5 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h5><ol><li>因为闭包函数内部的变量不会被垃圾回收，需要小心内存泄漏。</li><li>闭包让我们有了访问函数内部变量的权利，但是不要轻易去修改函数内部的值。</li></ol><h5 id="阮一峰大佬的思考题"><a href="#阮一峰大佬的思考题" class="headerlink" title="阮一峰大佬的思考题"></a>阮一峰大佬的思考题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">　　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that = this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一个结果是，The Window”原因是因为，this的指向问题，return funtion是一个匿名函数，匿名函数默认指向window。</p><p>第二个结果是，My Object”原因是因为，getNameFunc，在obect下面，this自然而然就指向object。这个时候把this指针所谓变量，给了匿名函数。return的时候，this自然而然指向了objet，所以访问到name。</p>]]></content>
    
    
    <summary type="html">把js中的闭包搞清楚</summary>
    
    
    
    <category term="css" scheme="http://yaru722.gitee.io/categories/css/"/>
    
    
    <category term="九宫格" scheme="http://yaru722.gitee.io/tags/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>js中的new操作符</title>
    <link href="http://yaru722.gitee.io/2022/01/23/javascript%E4%B8%AD%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yaru722.gitee.io/2022/01/23/javascript%E4%B8%AD%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/</id>
    <published>2022-01-23T10:29:42.593Z</published>
    <updated>2022-04-14T06:45:30.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new操作符有什么用？"><a href="#new操作符有什么用？" class="headerlink" title="new操作符有什么用？"></a>new操作符有什么用？</h4><h5 id="试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。"><a href="#试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。" class="headerlink" title="试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。"></a>试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(&#123;</span><br><span class="line">        id: index,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">        run: function () &#123;</span><br><span class="line">            console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">arr[0].run();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>100个士兵，我们生成了，但是，这样这样，既不优雅，对性能也是一种极大的浪费。</p><h5 id="可不可以再优雅一点。"><a href="#可不可以再优雅一点。" class="headerlink" title="可不可以再优雅一点。"></a>可不可以再优雅一点。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//士兵原型</span><br><span class="line">var model = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    //创建一个临时对象</span><br><span class="line">    let object = &#123;</span><br><span class="line">        id: index,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">    &#125;</span><br><span class="line">    object.__proto__ = model;</span><br><span class="line">    arr.push(object)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr[0].run();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们创建了一个原型对象 通过object的proto指向士兵的原型。</p><h5 id="还能不能更优雅一点，原型与对象在2个地方。"><a href="#还能不能更优雅一点，原型与对象在2个地方。" class="headerlink" title="还能不能更优雅一点，原型与对象在2个地方。"></a>还能不能更优雅一点，原型与对象在2个地方。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//士兵原型</span><br><span class="line">var model = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//更优雅的方式</span><br><span class="line"></span><br><span class="line">function Cat(id) &#123;</span><br><span class="line">    let object = &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">    &#125;</span><br><span class="line">    object.__proto__ = model;</span><br><span class="line">    return object;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(Cat(index))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr, arr[0].run());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/75NzLt"><img src="https://s4.ax1x.com/2022/01/23/75NzLt.jpg" alt="代码演示.jpg"></a></p><p>使用 new来实现一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//士兵们</span><br><span class="line">let arr = [];</span><br><span class="line">function Soldier(id) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.hp = Math.floor(Math.random() * (100 - 0)) + 0;</span><br><span class="line">&#125;</span><br><span class="line">Soldier.prototype.run = function () &#123;</span><br><span class="line">    console.log(`$&#123;this.id&#125;号士兵在逃跑`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实例化</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(new Soldier(index))</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr, arr[80].run());</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先实例化过程中创建了一个对象。</li><li>给对象添加proto，然后new自动找到了构造函数的原型并且把原型链接到了对象proto。</li><li>this做实例化的对象的上下文。</li><li>如果该函数没有返回对象，返回this。</li></ul><p>这就是new操作符的作用。<br><a href="https://zhuanlan.zhihu.com/p/23987456">参考文章</a></p>]]></content>
    
    
    <summary type="html">new操作符做干了什么</summary>
    
    
    
    <category term="js" scheme="http://yaru722.gitee.io/categories/js/"/>
    
    
    <category term="js" scheme="http://yaru722.gitee.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于js中的apply bind call的使用</title>
    <link href="http://yaru722.gitee.io/2022/01/20/%E5%85%B3%E4%BA%8Ethis%E7%9A%84call%EF%BC%8Capply%EF%BC%8Cbind%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yaru722.gitee.io/2022/01/20/%E5%85%B3%E4%BA%8Ethis%E7%9A%84call%EF%BC%8Capply%EF%BC%8Cbind%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-20T14:08:20.453Z</published>
    <updated>2022-01-20T14:11:54.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="this到底指向哪里。"><a href="#this到底指向哪里。" class="headerlink" title="this到底指向哪里。"></a>this到底指向哪里。</h4><p>事实上，this基本上指向最后调用他的对象。谁最后调用了this，this最终就指向哪里。（虽然会存在着，隐式调用的时候，this就变成了默认）</p><h4 id="而apply-call-与-bind-，可以改变this的指向。"><a href="#而apply-call-与-bind-，可以改变this的指向。" class="headerlink" title="而apply call 与 bind ，可以改变this的指向。"></a>而apply call 与 bind ，可以改变this的指向。</h4><p>例子如下，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi();//芳芳</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>我们需要让sayHi方法的this指向parson</strong></p><p>例子如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi.call(parson)//李四</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用apply 也可以改变指向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi.apply(parson)//李四</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="apply-与-call-的区别。"><a href="#apply-与-call-的区别。" class="headerlink" title="apply 与 call 的区别。"></a>apply 与 call 的区别。</h5><p>apply 和call的第一个参数都是，制定this的指向。第二次参数都是要传递进入的参数。不同的是 apply方法必须要制定一个数组作为参数传入，而，call则不是。</p><p>例子如下，，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi(a, b) &#123;</span><br><span class="line">    console.log(this.val + a + b);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    val: 10,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sayHi.call(parson, 1, 2);</span><br><span class="line">sayHi.apply(parson, [1, 2,]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不管是apply 与call 方法都指向了 parson，且，只不过apply参数传递必须是个数组。</p><p>bind 与 apply 和call不同的地方在于。</p><table><thead><tr><th>属性</th><th>执行</th><th>返回</th></tr></thead><tbody><tr><td>apply</td><td>改变函数的this上下文后马上执行函数</td><td>返回fun的执行结果</td></tr><tr><td>bind</td><td>返回函数改变了上下文的函数不马上执行</td><td>返回fun的拷贝，并指定了this的指向，保存函数的参数。</td></tr></tbody></table><p>关于apply 的一些妙用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 21, 21, 31, 32, 32, 12121, 21];</span><br><span class="line">let max = Math.max.apply(Math, arr);</span><br><span class="line">let min = Math.min.apply(Math, arr)</span><br><span class="line">console.log(max, min);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于如果显式的绑定this</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="改变this的指向" scheme="http://yaru722.gitee.io/tags/%E6%94%B9%E5%8F%98this%E7%9A%84%E6%8C%87%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>reduce解决商品sku算法问题</title>
    <link href="http://yaru722.gitee.io/2022/01/10/reduce%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81sku%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/"/>
    <id>http://yaru722.gitee.io/2022/01/10/reduce%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81sku%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-10T11:15:02.487Z</published>
    <updated>2022-01-10T11:17:13.864Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sku问题。"><a href="#sku问题。" class="headerlink" title="sku问题。"></a>sku问题。</h4><p>找到了一个数组方法 特别适合计算sku。</p><p>就是js中的reduce方法。</p><p>关于reduce方法的四个参数。<br>Accumulator (acc) (累计器)<br>Current Value (cur) (当前值)<br>Current Index (idx) (当前索引)<br>Source Array (src) (源数组)<br>initialValue（初始值）</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>accmulator</td><td>累加器（如果设置有初始值的话，第一次是初始值的参数，没有初始值，返回上次回调函数的结果）</td></tr><tr><td>Current Value</td><td>当前的值</td></tr><tr><td>Current Index</td><td>当前下标</td></tr><tr><td>Source Array</td><td>源数组</td></tr><tr><td>initialValue</td><td>默认值</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var arr = [[&#x27;s&#x27;, &#x27;m&#x27;, &#x27;x&#x27;, &#x27;l&#x27;, &#x27;xl&#x27;], [&#x27; T恤&#x27;, &#x27;裤子&#x27;, &#x27;裙子&#x27;], [&#x27;蓝色&#x27;, &#x27;白色&#x27;], [&#x27;nike&#x27;, &#x27;安踏&#x27;, &#x27;李宁&#x27;]];</span><br><span class="line">console.log(...arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    pre.forEach(item =&gt; &#123;</span><br><span class="line">        cur.forEach(items =&gt; &#123;</span><br><span class="line">            res.push(item.concat(items));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;, [[]]));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码需要理解的地方在于，第一遍的时候因为设置了默认值，[[]],所以第一次遍历到的是一个空数组。第二次再去遍历的时候 <strong>此时</strong>，当前值已经T恤xxx什么的了，所以第二次，我们遍历pre数组，合并cur数组就可以了。</p><p>reduce方法。。</p><p>这样sku问题就解决了</p><h5 id="reduce其他妙用。"><a href="#reduce其他妙用。" class="headerlink" title="reduce其他妙用。"></a>reduce其他妙用。</h5><h6 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr = [12, 3, 31, 21, 21, , 31, 31];</span><br><span class="line"></span><br><span class="line">console.log(arr.reduce((per, cur) =&gt; &#123;</span><br><span class="line">    return per + cur</span><br><span class="line">&#125;));//150</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="reduce-计算数组中每个元素出现的次数"><a href="#reduce-计算数组中每个元素出现的次数" class="headerlink" title="reduce 计算数组中每个元素出现的次数"></a>reduce 计算数组中每个元素出现的次数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Tiff&#x27;, &#x27;Bruce&#x27;, &#x27;Alice&#x27;];</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    return names.reduce((allNames, name) =&gt; &#123;</span><br><span class="line">        if (name in allNames) &#123;</span><br><span class="line">            allNames[name]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            allNames[name] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return allNames;</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(names));</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">商品规格sku算法问题</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="http://yaru722.gitee.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>includes</title>
    <link href="http://yaru722.gitee.io/2022/01/10/includes/"/>
    <id>http://yaru722.gitee.io/2022/01/10/includes/</id>
    <published>2022-01-10T11:11:35.014Z</published>
    <updated>2022-01-10T11:18:28.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于ES6-include的使用方法。"><a href="#关于ES6-include的使用方法。" class="headerlink" title="关于ES6-include的使用方法。"></a>关于ES6-include的使用方法。</h4><p>场景，和后端同学调试接口的时候，后端同学很喜欢返回我，status，或者type来给我判断。但是，，，如果状态多的话，那么判断可能是这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let status = 0;</span><br><span class="line"></span><br><span class="line">if (status == 1 || status == 2 || status == 3) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说实话这样写一点都不优雅。但是还能接受。毕竟 1 2 3，还好判断。</p><p>场景，后端同学又过来，接口要改，status可能要多判断2个值，4，5。4是进行中，5是已售后，或者叫啥都行。</p><p><a href="https://imgtu.com/i/7VEMdI"><img src="https://s4.ax1x.com/2022/01/10/7VEMdI.jpg" alt="7VEMdI.jpg"></a></p><p>接下来，我们的代码就是这样。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let status = 5;</span><br><span class="line"></span><br><span class="line">if (status == 1 || status == 2 || status == 3 || status == 4 || status == 5) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即便后端哥们不再过来改接口，添加状态。你也觉得这段代码不妥了把。</p><p>includes方法就可以完美解决这个问题。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let status = 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5];</span><br><span class="line">if (arr.includes(status)) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>includes</strong>会找数组的成员，找到了就是true，找不到就是false。</p><p>可可可，有indexof，呀。为什么要使用includes。</p><p>的确。indexof能实现这个问题。。</p><p>可是，如果数组里面存在NaN呢。indexof是否还能找得到？</p><p>例子如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let status = NaN;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, NaN, null];</span><br><span class="line">if (arr.indexOf(status) != -1) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>alert 出来到是 no。</p><p>而，includes就不会存在这样到问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let status = NaN;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, NaN, null];</span><br><span class="line">if (arr.includes(status)) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>indexof 无法在数组内定位到，NaN的位置。</p><p>结论如下，NaN无敌可能会存在数组的情况下，使用includes。</p>]]></content>
    
    
    <summary type="html">关于ES6，includes</summary>
    
    
    
    <category term="JavaScript" scheme="http://yaru722.gitee.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="http://yaru722.gitee.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>阅读红宝书js中的变量</title>
    <link href="http://yaru722.gitee.io/2021/11/25/%E9%98%85%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%8F%98%E9%87%8F/"/>
    <id>http://yaru722.gitee.io/2021/11/25/%E9%98%85%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%8F%98%E9%87%8F/</id>
    <published>2021-11-25T01:19:27.680Z</published>
    <updated>2021-11-25T01:20:30.315Z</updated>
    
    <content type="html"><![CDATA[<h5 id="var是什么。"><a href="#var是什么。" class="headerlink" title="var是什么。"></a>var是什么。</h5><p>1.js中的操作符，声明一个函数级的变量。<br>2.会存在变量提升的情况。</p><h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">var a = 11;//undefined</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为，变量提升到了最上面，所以虽然没有声明变量a，但是a变量被提到了最前面。</p><p>小知识，声明未使用的变量，默刃值是undefined。</p><h6 id="例子2，在函数里面"><a href="#例子2，在函数里面" class="headerlink" title="例子2，在函数里面"></a>例子2，在函数里面</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a;//undefined</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样也是变量被声明了。</p><p>我在变量提升上面的理解走错了路。声明变量，变量的默认中undefined，所谓的变量提升，就是声明的变量提升。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 11;</span><br><span class="line">代码等于 </span><br><span class="line">var a;</span><br><span class="line">a = 11;</span><br></pre></td></tr></table></figure><h6 id="let，块级作用域"><a href="#let，块级作用域" class="headerlink" title="let，块级作用域"></a>let，块级作用域</h6><p>1.何谓块级作用域啊。<br><code>&#123;&#125;</code><br>指的是只在代码块里有效。</p><p>2.最大的特点是没有变量提升。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * error  index.js:20 Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br><span class="line">    at index.js:20</span><br><span class="line"> * </span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">let a = 11;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不可以先使用！后声明变量。必须得先声明。因为没有变量提升！！！<br>因为let 声明执行的瞬间会存在一个暂缓性死区，不允许先使用后声明。</p><h6 id="3-可否重复声明？？"><a href="#3-可否重复声明？？" class="headerlink" title="3.可否重复声明？？"></a>3.可否重复声明？？</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var a = 11;</span><br><span class="line">var a = 12;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//众所周知，var变量的缺点是提升，与重复声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a = 11;</span><br><span class="line">let a = 12;</span><br><span class="line">console.log(a);//error Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let 在同一作用域下,不允许重复声明。</p><h6 id="关于全局声明。"><a href="#关于全局声明。" class="headerlink" title="关于全局声明。"></a>关于全局声明。</h6><p>var 声明的变量会成为window对象的属性。但是let在全局声明则不然。  </p><p>举个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//全局声明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let a = 11;</span><br><span class="line">console.log(window.a);undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="let-是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。"><a href="#let-是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。" class="headerlink" title="let 是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。"></a>let 是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。</h5><p>举个例子。</p><p>a.js文件里面的代码</p><p>`<br>let a = 11;</p><p>`<br>b.js文件的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// let a = 12;</span><br><span class="line">//条件声明不是一个好的方式。</span><br><span class="line">if (typeof (a) == &#x27;number&#x27;) &#123;</span><br><span class="line">    // 块级作用域下的let 声明的变量a ，无法检测前面有没有同名的变量。也无法在没有什么声明之前使用a。</span><br><span class="line">    let a = 12;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">//此处变量a，是a.js文件下声明的变量a，因为这个变量a是在全局作用域声明的变量。</span><br><span class="line">a = 13;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于js为什么做模块化的。就是因为上面的代码太乱了，都在一个html页面下，依赖于上下关系，而且能够很轻松的访问到全局作用域洗面的全局变量。所以很容易出现变量泄漏的问题。</p><p>且很难理清楚代码的关系。</p><h5 id="在for循环中声明let。"><a href="#在for循环中声明let。" class="headerlink" title="在for循环中声明let。"></a>在for循环中声明let。</h5><p>举个例子，因为for循环中，var 声明的变量会渗透出去。所以let声明的变量只会在代码块中存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt; 3; ++i) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//在这里我们能轻松访问到i</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//如果使用let声明的话则不会。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">for (let i = 1; i &lt; 3; ++i) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//index.js:6 Uncaught ReferenceError: i is not definedat index.js:6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//陷入的误区。</p><p>因为之前习惯使用 var来声明变量，搞不清楚为什么for循环后，var声明的变量比，<br>之前的代码多了1。</p><p>我tm就是脑子不好使，是个傻逼。let是块级作用域当然没这个问题了。</p><p>在js的for循环中只有失败了，才会停止。</p><p>总结，var会变量提升，在for循环中会导致变量渗透。var可以多次被声明，var 任何版本都可以使用。变量都默认值数undefined。<br>var 在windows作为属性。</p><p>let 没有变量提升，因为声明瞬间会暂缓性死区，let必须先声明后使用，在同块级作用域下let 变量不能重复声明。lef使用for循环不会泄漏变量。别使用条件声明let 同名变量。let不在window作为属性。</p><p>for循环只有失败都时候会终止。</p><p>最重要的知识点是弄清楚了for循环失败结束，太蠢了我。和上古时期的前端开发者的苦恼，没有模块化之前很容易全局变量污染。不易维护。</p><p>感同身受。</p>]]></content>
    
    
    <summary type="html">关键字 var let const</summary>
    
    
    
    <category term="css" scheme="http://yaru722.gitee.io/categories/css/"/>
    
    
    <category term="九宫格" scheme="http://yaru722.gitee.io/tags/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>2021年11月22日日报</title>
    <link href="http://yaru722.gitee.io/2021/11/23/2021%E5%B9%B411%E6%9C%8822%E6%97%A5%E6%97%A5%E6%8A%A5/"/>
    <id>http://yaru722.gitee.io/2021/11/23/2021%E5%B9%B411%E6%9C%8822%E6%97%A5%E6%97%A5%E6%8A%A5/</id>
    <published>2021-11-23T12:58:53.124Z</published>
    <updated>2021-11-23T12:59:29.201Z</updated>
    
    <content type="html"><![CDATA[<h4 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h4><h5 id="看js的红宝书"><a href="#看js的红宝书" class="headerlink" title="看js的红宝书"></a>看js的红宝书</h5><p>标识符<br>js中的标识符指的是，变量，属性，方法。最好使用小驼峰写法（首字母小写），标识符开头必须是字母或者_下划线，或者美元符号$来表示。</p><p>语句<br>{}来表示代码块，那怕就一句，;号表示语句的结束，如果不写分号也许。只不过js引擎会解析都时候带上，对性能不好。<br>最好使用控制语句来控制代码块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(true)</span><br><span class="line">log(&#x27;坏的写法&#x27;)</span><br><span class="line"></span><br><span class="line">if(ture)&#123;</span><br><span class="line">    log(&#x27;好的写法&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>es6之后才加了let 与const，任何版本变量都可以使用var 声明。<br>var 自带变量提升。</p><p>关键字是js中定义好的东西，不可以声明为标识符。保留字是不是关键字的关键字。下个版本也许就是关键字了。</p><h5 id="商城项目"><a href="#商城项目" class="headerlink" title="商城项目"></a>商城项目</h5><p>瀑布流的数据push入数组里面，这个时候转成josn字符串再转出来。</p><p>uniapp编译的时候存在问题。（猜测）</p><p>写分页的时候，上拉加载的时候就做判断。</p><h5 id="催宋哥工厂图"><a href="#催宋哥工厂图" class="headerlink" title="催宋哥工厂图"></a>催宋哥工厂图</h5><h4 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h4><p>尽快结束商城<br>给爸爸打电话<br>找媳妇聊天。<br>恢复状态<br>减肥。</p><h5 id="心得。"><a href="#心得。" class="headerlink" title="心得。"></a>心得。</h5><p>调整状态，多学习。经验。勤为径。</p>]]></content>
    
    
    <summary type="html">巩固印象</summary>
    
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/categories/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="开发日记" scheme="http://yaru722.gitee.io/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
