<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始学习vue3-4</title>
    <url>/blogs/2024/03/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0vue3-4/</url>
    <content><![CDATA[<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><h5 id="组件使用插槽"><a href="#组件使用插槽" class="headerlink" title="组件使用插槽"></a>组件使用插槽</h5><p>组件外部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;&quot;&gt;</span><br><span class="line">  &lt;Child&gt;</span><br><span class="line">    &lt;div&gt;123456789&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;先帝创业未半&lt;/p&gt;</span><br><span class="line">  &lt;/Child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件内部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    插槽演示：</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="渲染作用域"><a href="#渲染作用域" class="headerlink" title="渲染作用域"></a>渲染作用域</h5><p>因为插槽模版里面的内容本身就在父组件模版定义的,所以插槽可以访问到父组件数据作用域</p>
<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const msg = ref(&quot;先帝创业未半&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;&quot;&gt;</span><br><span class="line">    &lt;Child&gt;</span><br><span class="line">      &lt;div&gt;123456789&lt;/div&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/Child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;&quot;&gt;</span><br><span class="line">    &lt;Child&gt;</span><br><span class="line">      &lt;div&gt;123456789&lt;/div&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/Child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="插槽的默认内容"><a href="#插槽的默认内容" class="headerlink" title="插槽的默认内容"></a>插槽的默认内容</h5><p>当父组件没有提供插槽内容当时候，在子组件的内部，slot 标签之间，写入内容，就会成为插槽的默认内容。</p>
<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;button&quot;&gt;</span><br><span class="line">    &lt;slot&gt;Submit&lt;/slot&gt;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.button &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  margin: 0 20px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  height: 40px;</span><br><span class="line">  color: #fff;</span><br><span class="line">  line-height: 40px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const msg = ref(&quot;先帝创业未半&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;&quot;&gt;</span><br><span class="line">    &lt;Child&gt; &lt;/Child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认会把 Submit 渲染出来。</p>
<p>当我们在 <Child> </Child>标签之间加入内容 Submit 就会被替换。</p>
<h5 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h5><p>当一个组件里面有多个 slot 的时候，我们就需要给插槽起不同的名字。</p>
<p>使用 template v-slot:xxxx 指定插槽名字，或者#表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Child&gt;</span><br><span class="line">  &lt;template v-slot:header&gt; &lt;div&gt;header&lt;/div&gt; &lt;/template&gt;</span><br><span class="line">  &lt;template #main&gt;&lt;div&gt;main&lt;/div&gt;&lt;/template&gt;</span><br><span class="line">  &lt;template v-slot:footer&gt;&lt;div&gt;footer&lt;/div&gt;&lt;/template&gt;</span><br><span class="line">&lt;/Child&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动态插槽名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const slot1 = ref(&quot;header&quot;);</span><br><span class="line">const slot2 = ref(&quot;main&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;&quot;&gt;</span><br><span class="line">    &lt;Child&gt;</span><br><span class="line">      &lt;template v-slot:[slot1]&gt; &lt;div&gt;header&lt;/div&gt; &lt;/template&gt;</span><br><span class="line">      &lt;template #[slot2]&gt;&lt;div&gt;main&lt;/div&gt;&lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:footer&gt;&lt;div&gt;footer&lt;/div&gt;&lt;/template&gt;</span><br><span class="line">    &lt;/Child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="具名作用域插槽的使用"><a href="#具名作用域插槽的使用" class="headerlink" title="具名作用域插槽的使用"></a>具名作用域插槽的使用</h5><p>写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#slot=&#x27;slotporps&#x27;</span><br><span class="line">:v-slot:slot=&#x27;slotPorps&#x27;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Child :title=&quot;title&quot; :msg=&quot;msg&quot;&gt;</span><br><span class="line">  &lt;template v-slot:header=&quot;slotProps&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; slotProps.title &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;template #main=&quot;slotProps&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; slotProps.msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/Child&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const title = ref(&quot;1122&quot;);</span><br><span class="line">const msg = ref(&quot;hello,word&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;&quot;&gt;</span><br><span class="line">    &lt;Child :title=&quot;title&quot; :msg=&quot;msg&quot;&gt;</span><br><span class="line">      &lt;template v-slot:header=&quot;slotProps&quot;&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123; slotProps.title &#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template #main=&quot;slotProps&quot;&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123; slotProps.msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/Child&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用具名插槽渲染高级列表组件示例"><a href="#使用具名插槽渲染高级列表组件示例" class="headerlink" title="使用具名插槽渲染高级列表组件示例"></a>使用具名插槽渲染高级列表组件示例</h5><p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  tableList: &#123;</span><br><span class="line">    type: Array,</span><br><span class="line">    default: () =&gt; &#123;</span><br><span class="line">      return [];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;list-item&quot;&gt;</span><br><span class="line">    &lt;slot</span><br><span class="line">      v-for=&quot;(item, index) in tableList&quot;</span><br><span class="line">      name=&quot;item&quot;</span><br><span class="line">      :=&quot;item&quot;</span><br><span class="line">      :key=&quot;index&quot;</span><br><span class="line">    &gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const tableList = ref([</span><br><span class="line">  &#123; id: 1, name: &quot;Apple&quot;, price: 10.5 &#125;,</span><br><span class="line">  &#123; id: 2, name: &quot;Banana&quot;, price: 8.25 &#125;,</span><br><span class="line">  &#123; id: 3, name: &quot;Orange&quot;, price: 9.75 &#125;,</span><br><span class="line">  &#123; id: 4, name: &quot;Mango&quot;, price: 12.0 &#125;,</span><br><span class="line">  &#123; id: 5, name: &quot;Grape&quot;, price: 7.5 &#125;,</span><br><span class="line">  &#123; id: 6, name: &quot;Lemon&quot;, price: 6.25 &#125;,</span><br><span class="line">  &#123; id: 7, name: &quot;Strawberry&quot;, price: 11.0 &#125;,</span><br><span class="line">  &#123; id: 8, name: &quot; Kiwi&quot;, price: 9.5 &#125;,</span><br><span class="line">  &#123; id: 9, name: &quot;Pineapple&quot;, price: 13.5 &#125;,</span><br><span class="line">  &#123; id: 10, name: &quot;Melon&quot;, price: 15.0 &#125;,</span><br><span class="line">]);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;</span><br><span class="line">        &lt;Child :tableList=&quot;tableList&quot;&gt;</span><br><span class="line">          &lt;template #item=&quot;itemProps&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;div&gt;id：&#123;&#123; itemProps.id &#125;&#125;&lt;/div&gt;</span><br><span class="line">              &lt;div&gt;名字&#123;&#123; itemProps.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">              &lt;div&gt;价格：&#123;&#123; itemProps.price &#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/Child&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><strong>组件内，slot 标签可以定义插槽</strong><br><strong>插槽拥有默认内容，组件插槽没有被使用的情况下，会展示默认的内容，如果组件外部定义的插槽被使用的情况下，默认展示的内容会隐藏。</strong><br><strong>具名插槽定义方式 可以通过# 或者 v-slot:slotName 来使用，组件内部，使用 slot 标签，name 属性定义 slot 名字，具名插槽需要使用 template 标签</strong><br><strong>动态插槽，根据变量的名字。动态切换插槽的</strong><br><strong>作用域具名插槽，使用 v-slot：slotName=’slotNamePorps,或者简写#slotName=’slotNamePorps’使用，组件内部，slot 标签上接受定义 props 参数</strong><img src="evernotecid://380A18B5-B2B6-49D8-B378-B52EEE14CC18/appyinxiangcom/39592154/ENResource/p84" alt="9c65ca00d56fdc759dcc9d7c69e02405.png"></p>
]]></content>
      <categories>
        <category>vue3学习笔记</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始学习vue3-3</title>
    <url>/blogs/2024/03/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0vue3-3/</url>
    <content><![CDATA[<h4 id="Attributes-继承"><a href="#Attributes-继承" class="headerlink" title="Attributes 继承"></a>Attributes 继承</h4><h5 id="组件根元素继承"><a href="#组件根元素继承" class="headerlink" title="组件根元素继承"></a>组件根元素继承</h5><p>Attributes 继承指的是，当我们的一个<strong>组件</strong>，以根元素为渲染的时候，穿透的 Attributes 会自动被添加到根元素上。。</p>
<p>组件外部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Child</span><br><span class="line">  class=&quot;box&quot;</span><br><span class="line">  ss</span><br><span class="line">  v-model:name=&quot;name&quot;</span><br><span class="line">  v-model:password=&quot;password&quot;</span><br><span class="line">  v-model:model.capitalize=&quot;model&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p>组件内部代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&#x27;child&#x27;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件name输入:&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;password&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件password输入:&#123;&#123; password &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;model&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件model输入:&#123;&#123; model &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>组件的 class box 和组件内部的 class，child，与 ss，都被添加到了根元素上头。</p>
<h5 id="v-on-监听器继承"><a href="#v-on-监听器继承" class="headerlink" title="v-on 监听器继承"></a>v-on 监听器继承</h5><p>如果在组件上通过 v-on 绑定一个事件，在组件内部，根元素也绑定一个相同的事件，2 个事件都会被触发。</p>
<p>组件外部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">function click() &#123;</span><br><span class="line">  console.log(&quot;父亲&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child</span><br><span class="line">    @click=&quot;click&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>组件内部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const name = defineModel(&quot;name&quot;);</span><br><span class="line">const password = defineModel(&quot;password&quot;, &#123; required: true &#125;);</span><br><span class="line">const [model, modifiers] = defineModel(&quot;model&quot;, &#123;</span><br><span class="line">  set(value) &#123;</span><br><span class="line">    if (modifiers.capitalize) &#123;</span><br><span class="line">      return value.charAt(0).toUpperCase() + value.slice(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">function click() &#123;</span><br><span class="line">  console.log(&quot;xxx&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot; @click=&quot;click&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;name&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">      &lt;p&gt;子组件name输入:&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;password&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">      &lt;p&gt;子组件password输入:&#123;&#123; password &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;model&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">      &lt;p&gt;子组件model输入:&#123;&#123; model &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>绑定的 2 个 click 方法都会被触发。</p>
<h5 id="禁用-Attributes-继承"><a href="#禁用-Attributes-继承" class="headerlink" title="禁用 Attributes 继承"></a>禁用 Attributes 继承</h5><p>首先在组件内部，使用 defineOptions，把 inheritAttrs 设置为 false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defineOptions(&#123;</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Attributes 禁用继承的使用场景</strong>通过就是我们希望控制 Attributes 继承到非根元素的元素上。这个时候，穿透进来的，attribute，我们可以在模版里通过表达式中用 <strong>$attrs</strong>访问</p>
<p>透传 attributes 在 js 当中，保留了原始大小写，所以像 box-1，我们需要通过$attrs[‘box-1’]访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件name输入:&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;password&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件password输入:&#123;&#123; password &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;model&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件model输入:&#123;&#123; model &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- v-bind=&quot;$attrs&quot; --&gt;</span><br><span class="line">  &lt;span :class=&quot;$attrs[&#x27;class&#x27;]&quot; @click=&quot;$attrs[&#x27;onClick&#x27;]&quot;</span><br><span class="line">    &gt;Fallthrough attribute:&lt;/span</span><br><span class="line">  &gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="多根节点的-Attributes-继承"><a href="#多根节点的-Attributes-继承" class="headerlink" title="多根节点的 Attributes 继承"></a>多根节点的 Attributes 继承</h5><p>当组件存在多个根节点的情况下，我们没有给穿透的 Attributes 指定继承到那个节点，将会抛出一个运行时警告。</p>
<p>child.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件name输入:&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;password&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件password输入:&#123;&#123; password &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;model&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件model输入:&#123;&#123; model &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样会抛出一个运行警告</p>
<h5 id="在-JavaScript-中访问透传-Attributes"><a href="#在-JavaScript-中访问透传-Attributes" class="headerlink" title="在 JavaScript 中访问透传 Attributes"></a>在 JavaScript 中访问透传 Attributes</h5><script setup> 中使用 useAttrs() API 来访问一个组件的所有透传 attribute：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; useAttrs &#125; from &#x27;vue&#x27;</span><br><span class="line">const attrs = useAttrs()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


总结：
**Attributes默认，组件外部的属性事件和组件内部的属性合并，继承到一起。**

**组件外部定义的事件和组件内部根元素定义的相同时间，会一起触发**

**通过defineOptions，inheritAttrs: false可以禁止组件外部的属性，继承到组件内部合并到一起**

**通过$attrs访问 可以在其他元素上使用，继承到属性，和props不同，大小写，不会转换，事件要访问$attrs.onclick**

**存在多个根节点的情况下的时候，如果$attrs 没有绑定到任何一个元素上，defineOptions，inheritAttrs: false会报一个运行警告**


**通过useAttrs，const attrs = useAttrs()，可以在js当中访问到Attributes的所有属性**
]]></content>
      <categories>
        <category>vue3学习笔记</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始学习vue3-2</title>
    <url>/blogs/2024/03/25/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0vue3-2/</url>
    <content><![CDATA[<h4 id="props-的绑定"><a href="#props-的绑定" class="headerlink" title="props 的绑定"></a>props 的绑定</h4><p>**v-bing 的不指定名字，会把 object 对象当中符合 object 的参数，给作为 props，传递过去。<br>**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;HelloWorld @enlarge-text=&quot;enlarge&quot; :=&quot;object&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;;</span><br><span class="line">const object = ref(&#123;</span><br><span class="line">  title: &quot;泰酷辣&quot;,</span><br><span class="line">  h3: &quot;泰酷辣&quot;,</span><br><span class="line">  msg: &quot;泰酷辣&quot;,</span><br><span class="line">  class: &quot;box&quot;,</span><br><span class="line">  id: &quot;box1&quot;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>*<em>props 是单项数据流，在子组件不要去修改，我们可以根据 props 传递的初始化值，把它给添加到响应式变量里面，去使用。这样不会影响到 props。或者，对 props 使用计算属性。</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  msg: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;hello&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  title: String,</span><br><span class="line">  h3: String,</span><br><span class="line">&#125;);</span><br><span class="line">const msg1 = ref(props.msg);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  msg1.value = &quot;qwertyuiop&quot;;</span><br><span class="line">&#125;, 4000);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123; h3 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;&#123;&#123; msg1 &#125;&#125;&lt;/h4&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.read-the-docs &#123;</span><br><span class="line">  color: #888;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h4><h5 id="事件校验"><a href="#事件校验" class="headerlink" title="事件校验"></a>事件校验</h5><p>如果注册的事件，符合条件就去触发，不符合条件就不触发。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const emit = defineEmits(&#123;</span><br><span class="line">  submit: (&#123; email, password &#125;) =&gt; &#123;</span><br><span class="line">    if (email &amp;&amp; password) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.warn(&quot;Invalid submit event payload!&quot;);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  msg: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;hello&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  title: String,</span><br><span class="line">  h3: String,</span><br><span class="line">&#125;);</span><br><span class="line">const msg1 = ref(props.msg);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  msg1.value = &quot;qwertyuiop&quot;;</span><br><span class="line">&#125;, 4000);</span><br><span class="line">function submitForm(email, password) &#123;</span><br><span class="line">  emit(&quot;submit&quot;, &#123; email, password &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><h5 id="v-model-双向绑定使用"><a href="#v-model-双向绑定使用" class="headerlink" title="v-model 双向绑定使用"></a>v-model 双向绑定使用</h5><p>vue3 当中的双向绑定<br>组合式 api 推荐双向绑定使用 defineModel 宏。</p>
<p>但是在子组件使用了，<strong>defineModel 宏 is not found</strong><br>需要在 vite.config 文件里面，把 defineModel 设置为 true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    vue(&#123;</span><br><span class="line">      script: &#123;</span><br><span class="line">        defineModel: true,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为在 vue3 当中 defineModel 宏 默认是关闭的。</p>
<h5 id="vue3v-model-上的参数"><a href="#vue3v-model-上的参数" class="headerlink" title="vue3v-model 上的参数"></a>vue3v-model 上的参数</h5><p>child.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const model = defineModel(&quot;value&quot;, &#123; required: true &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;model&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">  &lt;p&gt;子组件输入:&#123;&#123; model &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>parent.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const msg = ref(&quot;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;Child v-model:value=&quot;msg&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>defineModel 第一个参数，指定 v-model 的参数，required: true，v-model，必须要在父组件里面指定属性。</p>
<p>defineModel 不要给他默认指定参数，否则父组件默认值和子组件 defineModel 参数不同，会导致不同。</p>
<h5 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 v-model 绑定</h5><p><strong>parent.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const name = ref(&quot;&quot;);</span><br><span class="line">const password = ref(&quot;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;父name：&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;父password：&#123;&#123; password &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;Child v-model:name=&quot;name&quot; v-model:password=&quot;password&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>child.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const name = defineModel(&quot;name&quot;, &#123; required: true, default: &quot;hi&quot; &#125;);</span><br><span class="line">const password = defineModel(&quot;password&quot;, &#123; required: true, default: &quot;hi&quot; &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件name输入:&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;password&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件password输入:&#123;&#123; password &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 v-model 修饰符</h5><p>其实 v-model 的修饰符，会把符合转换的数据，转换成修饰符要求的数据。</p>
<p><strong>自定义修饰符</strong><br>vue3.4 版本的使用</p>
<p><strong>child.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const name = defineModel(&quot;name&quot;);</span><br><span class="line">const password = defineModel(&quot;password&quot;, &#123; required: true &#125;);</span><br><span class="line">const [model, modifiers] = defineModel(&quot;model&quot;, &#123;</span><br><span class="line">  set(value) &#123;</span><br><span class="line">    if (modifiers.capitalize) &#123;</span><br><span class="line">      return value.charAt(0).toUpperCase() + value.slice(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;name&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件name输入:&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;password&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件password输入:&#123;&#123; password &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;model&quot; placeholder=&quot;请输入&quot; /&gt;</span><br><span class="line">    &lt;p&gt;子组件model输入:&#123;&#123; model &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>parent.vue</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import Child from &quot;../../components/Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const name = ref(&quot;&quot;);</span><br><span class="line">const password = ref(&quot;&quot;);</span><br><span class="line">const model = ref(&quot;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;父name：&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;父password：&#123;&#123; password &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;Child</span><br><span class="line">    v-model:name=&quot;name&quot;</span><br><span class="line">    v-model:password=&quot;password&quot;</span><br><span class="line">    v-model:model.capitalize=&quot;model&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue3学习笔记</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始学习vue3-1</title>
    <url>/blogs/2024/03/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0vue3-1/</url>
    <content><![CDATA[<h5 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h5><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h5><p><strong>1. v-bind 可以动态绑定元素，</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;a :=&quot;attribute&quot;&gt;demo&lt;/a&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const attribute = ref(&#123;</span><br><span class="line">  class: &quot;box&quot;,</span><br><span class="line">  id: &quot;demo&quot;,</span><br><span class="line">  style: &quot;color:red&quot;,</span><br><span class="line">  href: &quot;www.baidu.com&quot;,</span><br><span class="line">  msg: &quot;元神怎么你了&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">打开调试模式</span><br><span class="line"></span><br><span class="line">&lt;a class=&quot;box&quot; id=&quot;demo&quot; href=&quot;www.baidu.com&quot; msg=&quot;元神怎么你了&quot; style=&quot;color: red;&quot;&gt;demo&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>id，class 等属性都被绑定到上面了。</p>
<p><strong>2. 包括组件自定义的 props，也可以绑定</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;HelloWorld :=&quot;attribute&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import HelloWorld from &quot;../../components/HelloWorld.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const attribute = ref(&#123;</span><br><span class="line">  class: &quot;box&quot;,</span><br><span class="line">  id: &quot;demo&quot;,</span><br><span class="line">  style: &quot;color:red&quot;,</span><br><span class="line">  href: &quot;www.baidu.com&quot;,</span><br><span class="line">  msg: &quot;元神怎么你了&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>helloword.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">defineProps(&#123;</span><br><span class="line">  msg: String,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;count is &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      Edit</span><br><span class="line">      &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Check out</span><br><span class="line">    &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot;</span><br><span class="line">      &gt;create-vue&lt;/a</span><br><span class="line">    &gt;, the official Vue + Vite starter</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Install</span><br><span class="line">    &lt;a href=&quot;https://github.com/vuejs/language-tools&quot; target=&quot;_blank&quot;&gt;Volar&lt;/a&gt;</span><br><span class="line">    in your IDE for a better DX</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;read-the-docs&quot;&gt;Click on the Vite and Vue logos to learn more&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.read-the-docs &#123;</span><br><span class="line">  color: #888;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="v-bind-和-v-on-进行动态绑定属性和事件"><a href="#v-bind-和-v-on-进行动态绑定属性和事件" class="headerlink" title="v-bind 和 v-on 进行动态绑定属性和事件"></a>v-bind 和 v-on 进行动态绑定属性和事件</h5><p>v-on === @<br>v-bind === :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-on:[argument]=&quot;url&quot;&gt;demo&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button class=&quot;btn&quot; @click=&quot;argument = &#x27;src&#x27;&quot;&gt;设置argument是src&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;btn&quot; @click=&quot;argument = &#x27;href&#x27;&quot;&gt;设置argument是href&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;btn&quot; @click=&quot;setClick&quot;&gt;设置argument是click&lt;/button&gt;</span><br><span class="line">    &lt;button class=&quot;btn&quot; @click=&quot;setDblclick&quot;&gt;设置argument是dblclick&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const url = ref(&quot;www.baidu.com&quot;);</span><br><span class="line">const argument = ref(&quot;src&quot;);</span><br><span class="line">function run() &#123;</span><br><span class="line">  console.log(&quot;run方法！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function setClick() &#123;</span><br><span class="line">  url.value = run;</span><br><span class="line">  argument.value = &quot;click&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function setDblclick() &#123;</span><br><span class="line">  url.value = run;</span><br><span class="line">  argument.value = &quot;dblclick&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.btn &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">  color: #fff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="vue-当中的修饰符"><a href="#vue-当中的修饰符" class="headerlink" title="vue 当中的修饰符"></a>vue 当中的修饰符</h5><p>使用 once 修饰符，事件只能触发一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-on:[argument].once=&quot;url&quot;&gt;demo&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button class=&quot;btn&quot; @click=&quot;setDblclick&quot;&gt;设置argument是dblclick&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const url = ref(&quot;www.baidu.com&quot;);</span><br><span class="line">const argument = ref(&quot;src&quot;);</span><br><span class="line">function run() &#123;</span><br><span class="line">  console.log(&quot;run方法！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function setDblclick() &#123;</span><br><span class="line">  url.value = run;</span><br><span class="line">  argument.value = &quot;dblclick&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="vue-当中的计算属性"><a href="#vue-当中的计算属性" class="headerlink" title="vue 当中的计算属性"></a>vue 当中的计算属性</h4><p>比起用函数计算，计算属性会缓存计算的结果，只要数据变动才会再去计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;priceValue&quot; placeholder=&quot;请输入价格&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;pieceValue&quot; placeholder=&quot;请输入件数&quot; /&gt;</span><br><span class="line">  &lt;div&gt;总价：¥&#123;&#123; totalPirce &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const priceValue = ref(10);</span><br><span class="line">const pieceValue = ref(1);</span><br><span class="line">const totalPirce = computed(() =&gt; &#123;</span><br><span class="line">  return priceValue.value * pieceValue.value;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;priceValue&quot; placeholder=&quot;请输入价格&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;pieceValue&quot; placeholder=&quot;请输入件数&quot; /&gt;</span><br><span class="line">  &lt;div&gt;总价：¥&#123;&#123; totalPirce &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;可读写的计算属性:&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const priceValue = ref(10);</span><br><span class="line">const pieceValue = ref(1);</span><br><span class="line">const totalPirce = computed(() =&gt; &#123;</span><br><span class="line">  return priceValue.value * pieceValue.value;</span><br><span class="line">&#125;);</span><br><span class="line">const firstName = ref(&quot;John&quot;);</span><br><span class="line">const lastName = ref(&quot;Doe&quot;);</span><br><span class="line"></span><br><span class="line">const fullName = computed(&#123;</span><br><span class="line">  // getter</span><br><span class="line">  get() &#123;</span><br><span class="line">    return firstName.value + &quot; &quot; + lastName.value;</span><br><span class="line">  &#125;,</span><br><span class="line">  // setter</span><br><span class="line">  set(newValue) &#123;</span><br><span class="line">    // 注意：我们这里使用的是解构赋值语法</span><br><span class="line">    [firstName.value, lastName.value] = newValue.split(&quot; &quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">fullName.value = &quot;cool faker&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fullName.value = “cool faker”; 会改变计算属性的结果。。</p>
<h5 id="使用-computed-的注意事项"><a href="#使用-computed-的注意事项" class="headerlink" title="使用 computed 的注意事项"></a>使用 computed 的注意事项</h5><ol>
<li>在 getter 当中不要做<strong>异步</strong>请求，不要去<strong>操作 dom</strong>！</li>
<li>避免直接修改计算属性的值。</li>
</ol>
<h4 id="class-与-style-的绑定"><a href="#class-与-style-的绑定" class="headerlink" title="class 与 style 的绑定"></a>class 与 style 的绑定</h4><p>claas 可以绑定一个对象，active 是存在需要根据 isActive 的真假值，class 和使用 v-bind 绑定 class 可以共存</p>
<h5 id="class-的绑定"><a href="#class-的绑定" class="headerlink" title="class 的绑定"></a>class 的绑定</h5><p><strong>通过变量绑定 class</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;&#123; active: isActive &#125;&quot; class=&quot;box&quot;&gt;faker&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const isActive = ref(1);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.active &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">  color: #fff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 3px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>class 绑定数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;demoClass&quot; class=&quot;box&quot;&gt;faker&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">let demoClass = ref([&quot;box&quot;, &quot;active&quot;]);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.active &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">  color: #fff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 3px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>class 绑定计算属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;demoClass&quot; class=&quot;box&quot;&gt;faker&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const isActive = ref(0);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  isActive.value = 1;</span><br><span class="line">&#125;, 4000);</span><br><span class="line">const demoClass = computed(() =&gt; (&#123;</span><br><span class="line">  active: isActive.value,</span><br><span class="line">  box: isActive.value,</span><br><span class="line">&#125;));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.active &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">  color: #fff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 3px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用 class 绑定的类名和 vue 组件的类名会合并到一起。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;HelloWorld :class=&quot;demoClass&quot; msg=&quot;hello,word&quot;&gt;faker&lt;/HelloWorld&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line">import HelloWorld from &quot;../../components/HelloWorld.vue&quot;;</span><br><span class="line">const isActive = ref(0);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  isActive.value = 1;</span><br><span class="line">&#125;, 4000);</span><br><span class="line">const demoClass = computed(() =&gt; (&#123;</span><br><span class="line">  active: isActive.value,</span><br><span class="line">&#125;));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.active &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">  color: #fff;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 3px solid blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">defineProps(&#123;</span><br><span class="line">  msg: String,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">      &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;count is &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Edit</span><br><span class="line">        &lt;code&gt;components/HelloWorld.vue&lt;/code&gt; to test HMR</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      Check out</span><br><span class="line">      &lt;a href=&quot;https://vuejs.org/guide/quick-start.html#local&quot; target=&quot;_blank&quot;</span><br><span class="line">        &gt;create-vue&lt;/a</span><br><span class="line">      &gt;, the official Vue + Vite starter</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      Install</span><br><span class="line">      &lt;a href=&quot;https://github.com/vuejs/language-tools&quot; target=&quot;_blank&quot;</span><br><span class="line">        &gt;Volar&lt;/a</span><br><span class="line">      &gt;</span><br><span class="line">      in your IDE for a better DX</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p class=&quot;read-the-docs&quot;&gt;Click on the Vite and Vue logos to learn more&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.read-the-docs &#123;</span><br><span class="line">  color: #888;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动态添加 active 类名和组件的 box 类名合并到了一起，<br>parents 父组件</p>
<h5 id="style-的绑定"><a href="#style-的绑定" class="headerlink" title="style 的绑定"></a>style 的绑定</h5><p><strong>style 绑定对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style=&quot;boxClass&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const boxClass = ref(&#123;</span><br><span class="line">  width: &quot;100px&quot;,</span><br><span class="line">  height: &quot;100px&quot;,</span><br><span class="line">  &quot;background-color&quot;: &quot;red&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  boxClass.value.width = &quot;200px&quot;;</span><br><span class="line">&#125;, 4000);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>style 绑定数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style=&quot;boxClass&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const boxClass = ref(&#123;</span><br><span class="line">  width: &quot;100px&quot;,</span><br><span class="line">  height: &quot;100px&quot;,</span><br><span class="line">  &quot;background-color&quot;: &quot;red&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  boxClass.value.width = &quot;200px&quot;;</span><br><span class="line">&#125;, 4000);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>style 数组绑定</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style=&quot;[boxClass, boxClass1]&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const boxClass = ref(&#123;</span><br><span class="line">  width: &quot;100px&quot;,</span><br><span class="line">  height: &quot;100px&quot;,</span><br><span class="line">  &quot;background-color&quot;: &quot;red&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">const boxClass1 = ref(&#123;</span><br><span class="line">  border: &quot;1px solid blue&quot;,</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  boxClass.value.width = &quot;200px&quot;;</span><br><span class="line">&#125;, 4000);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="模版的引用"><a href="#模版的引用" class="headerlink" title="模版的引用"></a>模版的引用</h4><h5 id="ref-可以访问到底层的-dom-元素"><a href="#ref-可以访问到底层的-dom-元素" class="headerlink" title="ref 可以访问到底层的 dom 元素"></a>ref 可以访问到底层的 dom 元素</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; ref=&quot;input&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;;</span><br><span class="line">const input = ref(null);</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  input.value.focus();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ref，父组件调用子组件"><a href="#ref，父组件调用子组件" class="headerlink" title="ref，父组件调用子组件"></a>ref，父组件调用子组件</h5><p><strong>如果是选项式 api 的话，父可以对每个子组件都有完全都访问权限，如果使用了 <script setup> 的话，就是私有的，除非子组件去通过 defineExpose 宏显式暴露。</strong></p>
<p><strong>父组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;HelloWorld msg=&quot;123456789&quot; ref=&quot;childRef&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import HelloWorld from &quot;../../components/HelloWorld.vue&quot;;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;;</span><br><span class="line">const childRef = ref(null);</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  childRef.value.childMethod();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>子组件通过 defineExpose 暴露</strong></p>
<figure class="highlight plaintext"><figcaption><span>setup></span></figcaption><table><tr><td class="code"><pre><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  msg: String,</span><br><span class="line">&#125;);</span><br><span class="line">const childMethod = () =&gt; &#123;</span><br><span class="line">  console.log(&quot;Child method called&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">const count = ref(0);</span><br><span class="line">defineExpose(&#123;</span><br><span class="line">  childMethod,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h4><h5 id="组件的-props-传递和-emit-事件注册"><a href="#组件的-props-传递和-emit-事件注册" class="headerlink" title="组件的 props 传递和 emit 事件注册"></a>组件的 props 传递和 emit 事件注册</h5><p>子组件自定义事件，在标签里面，可以通过$emit,<br>在组合式 api 里面，只能通过，<strong>defineEmits</strong>定义事件。<br>在组合式 api 当中，<strong>defineProps</strong>定义子组件的属性参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  msg: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;hello&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  title: String,</span><br><span class="line">  h3: String,</span><br><span class="line">&#125;);</span><br><span class="line">const emit = defineEmits([&quot;enlarge-text&quot;]);</span><br><span class="line"></span><br><span class="line">function run() &#123;</span><br><span class="line">  emit(&quot;enlarge-text&quot;, &#123; data: &quot;这是自定义数据&quot; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123; h3 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;run&quot;&gt;enlarge-text&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue3学习笔记</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员必会的单词表</title>
    <url>/blogs/2024/03/21/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8D%95%E8%AF%8D%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul>
<li>plugins(插件)</li>
<li>vite(极速)</li>
<li>layout(布局)</li>
<li>manifest(表明)</li>
<li>README(自述文件)</li>
<li>LICENSE(执照)</li>
</ul>
<h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><ul>
<li>abstract 抽象的</li>
<li>abstract base class (ABC)抽象基类</li>
<li>abstract class 抽象类</li>
<li>abstraction 抽象、抽象物、抽象性</li>
<li>access 存取、访问</li>
<li>access function 访问函数</li>
<li>access level 访问级别</li>
<li>account 账户</li>
<li>action 动作</li>
<li>activate 激活</li>
<li>active 活动的</li>
<li>actual parameter 实参</li>
<li>adapter 适配器</li>
<li>add-in 插件</li>
<li>address 地址</li>
<li>address space 地址空间</li>
<li>ADO(ActiveX Data Object)ActiveX 数据对象</li>
<li>advanced 高级的</li>
<li>aggregation 聚合、聚集</li>
<li>algorithm 算法</li>
<li>alias 别名</li>
<li>align 排列、对齐</li>
<li>allocate 分配、配置</li>
<li>allocator 分配器、配置器</li>
<li>angle bracket 尖括号</li>
<li>annotation 注解、评注</li>
<li>API (Application Programming Interface) 应</li>
<li>用(程序)编程接口</li>
<li>appearance 外观</li>
<li>append 附加</li>
<li>application 应用、应用程序</li>
<li>application framework 应用程序框架</li>
<li>Approximate String Matching 模糊匹配</li>
<li>architecture 架构、体系结构</li>
<li>archive file 归档文件、存档文件</li>
<li>argument 参数。</li>
<li>array 数组</li>
<li>arrow operator 箭头操作符</li>
<li>assert(ion) 断言</li>
<li>assign 赋值</li>
<li>assignment 赋值、分配</li>
<li>assignment operator 赋值操作符</li>
<li>associated 相关的、相关联的</li>
<li>asynchronous 异步的</li>
<li>attribute 特性、属性</li>
<li>authentication service 验证服务</li>
<li>authorization 授权</li>
<li></li>
</ul>
<h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><ul>
<li>background 背景、后台(进程)</li>
<li>backup 备份</li>
<li>backup device 备份设备</li>
<li>backup file 备份文件</li>
<li>backward compatible 向后兼容、向下兼容</li>
<li>base class 基类</li>
<li>base type 基类型</li>
<li>batch 批处理</li>
<li>BCL (base class library)基类库</li>
<li>Bin Packing 装箱问题</li>
<li>binary 二进制</li>
<li>binding 绑定</li>
<li>bit 位</li>
<li>bitmap 位图</li>
<li>block 块、区块、语句块</li>
<li>boolean 布林值(真假值，true 或 false)</li>
<li>border 边框</li>
<li>bounds checking 边界检查</li>
<li>boxing 装箱、装箱转换</li>
<li>brace (curly brace) 大括号、花括号</li>
<li>bracket (square brakcet) 中括号、方括号</li>
<li>breakpoint 断点</li>
<li>browser applications 浏览器应用(程序)</li>
<li>browser-accessible application 可经由浏览器访问的应用程序</li>
<li>bug 缺陷错误</li>
<li>build 编连(专指编译和连接)</li>
<li>built-in 内建、内置</li>
<li>bus 总线</li>
<li>business 业务、商务(看场合)</li>
<li>business Logic 业务逻辑</li>
<li>business rules 业务规则</li>
<li>buttons 按钮</li>
<li>by/through 通过</li>
<li>byte 位元组(由 8 bits 组成)</li>
<li></li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><ul>
<li>cache 高速缓存</li>
<li>calendar 日历</li>
<li>Calendrical Calculations 日期</li>
<li>call 调用</li>
<li>call operator 调用操作符</li>
<li>callback 回调</li>
<li>candidate key 候选键 (for database)</li>
<li>cascading delete 级联删除 (for database)</li>
<li>cascading update 级联更新 (for database)</li>
<li>casting 转型、造型转换</li>
<li>catalog 目录</li>
<li>chain 链(function calls)</li>
<li>character 字符</li>
<li>character format 字符格式</li>
<li>character set 字符集</li>
<li>check box 复选框</li>
<li>check button 复选按钮</li>
<li>CHECK constraints CHECK 约束 (for database)</li>
<li>checkpoint 检查点 (for database)</li>
<li>child class 子类</li>
<li>CIL (common intermediate language)通用中间语言、通用中介语言</li>
<li>class 类</li>
<li>class declaration 类声明</li>
<li>class definition 类定义</li>
<li>class derivation list 类继承列表</li>
<li>class factory 类厂</li>
<li>class hierarchy 类层次结构</li>
<li>class library 类库</li>
<li>class loader 类装载器</li>
<li>class template 类模板</li>
<li>class template partial specializations 类模板部分特化</li>
<li>class template specializations 类模板特化</li>
<li>classification 分类</li>
<li>clause 子句</li>
<li>cleanup 清理、清除</li>
<li>CLI (Common Language Infrastructure) 通用语言基础设施</li>
<li>client 客户、客户端</li>
<li>client application 客户端应用程序</li>
<li>client area 客户区</li>
<li>client cursor 客户端游标 (for database)</li>
<li>client-server 客户机/服务器、客户端/服务器</li>
<li>clipboard 剪贴板</li>
<li>clone 克隆</li>
<li>CLS (common language specification) 通用语言规范</li>
<li>code access security 代码访问安全</li>
<li>code page 代码页</li>
<li>COFF (Common Object File Format) 通用对象文件格式</li>
<li>collection 集合</li>
<li>COM (Component Object Model) 组件对象模型</li>
<li>combo box 组合框</li>
<li>command line 命令行</li>
<li>comment 注释</li>
<li>commit 提交 (for database)</li>
<li>communication 通讯</li>
<li>compatible 兼容</li>
<li>compile time 编译期、编译时</li>
<li>compiler 编译器</li>
<li>component 组件</li>
<li>composite index 复合索引、组合索引 (for database)</li>
<li>composite key 复合键、组合键 (for database)</li>
<li>composition 复合、组合</li>
<li>concept 概念</li>
<li>concrete 具体的</li>
<li>concrete class 具体类</li>
<li>concurrency 并发、并发机制</li>
<li>configuration 配置、组态</li>
<li>Connected Components 连通分支</li>
<li>connection 连接 (for database)</li>
<li>connection pooling 连接池</li>
<li>console 控制台</li>
<li>constant 常量</li>
<li>Constrained and Unconstrained Optimization 最值问题</li>
<li>constraint 约束 (for database)</li>
<li>construct 构件、成分、概念、构造（for language）</li>
<li>constructor (ctor) 构造函数、构造器</li>
<li>container 容器</li>
<li>containment 包容</li>
<li>context 环境、上下文</li>
<li>control 控件</li>
<li>cookie</li>
<li>copy 拷贝</li>
<li>CORBA 通用对象请求中介架构(Common Object Request Broker Architecture)</li>
<li>cover 覆盖、涵盖</li>
<li>create/creation 创建、生成</li>
<li>crosstab query 交叉表查询 (for database)</li>
<li>Cryptography 密码</li>
<li>CTS (common type system)通用类型系统</li>
<li>cube 多维数据集 (for database)</li>
<li>cursor 光标</li>
<li>cursor 游标 (for database)</li>
<li>custom 定制、自定义</li>
</ul>
<h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><ul>
<li>data 数据</li>
<li>data connection 数据连接 (for database)</li>
<li>data dictionary 数据字典 (for database)</li>
<li>data file 数据文件 (for database)</li>
<li>data integrity 数据完整性 (for database)</li>
<li>data manipulation language (DML)数据操作语言(DML) (for database)</li>
<li>data member 数据成员、成员变量</li>
<li>data source 数据源 (for database)</li>
<li>Data source name (DSN) 数据源名称(DSN) (for database)</li>
<li>data structure 数据结构</li>
<li>Data Structures 基本数据结构</li>
<li>data table 数据表 (for database)</li>
<li>data-bound 数据绑定 (for database)</li>
<li>database 数据库 (for database)</li>
<li>database catalog 数据库目录 (for database)</li>
<li>database diagram 数据关系图 (for database)</li>
<li>database file 数据库文件 (for database)</li>
<li>database object 数据库对象 (for database)</li>
<li>database owner 数据库所有者 (for database)</li>
<li>database project 数据库工程 (for database)</li>
<li>database role 数据库角色 (for database)</li>
<li>database schema 数据库模式、数据库架构 (for database)</li>
<li>database script 数据库脚本 (for database)</li>
<li>datagram 数据报文</li>
<li>dataset 数据集 (for database)</li>
<li>dataset 数据集 (for database)</li>
<li>DBMS (database management system)数据库管理系统 (for database)</li>
<li>DCOM (distributed COM)分布式 COM</li>
<li>dead lock 死锁 (for database)</li>
<li>deallocate 归还</li>
<li>debug 调试</li>
<li>debugger 调试器</li>
<li>decay 退化</li>
<li>declaration 声明</li>
<li>default 缺省、默认值</li>
<li>DEFAULT constraint 默认约束 (for database)</li>
<li>default database 默认数据库 (for database)</li>
<li>default instance 默认实例 (for database)</li>
<li>default result set 默认结果集 (for database)</li>
<li>defer 推迟</li>
<li>definition 定义</li>
<li>delegate 委托</li>
<li>delegation 委托</li>
<li>deploy 部署</li>
<li>derived class 派生类</li>
<li>design pattern 设计模式</li>
<li>destroy 销毁</li>
<li>destructor(dtor)析构函数、析构器</li>
<li>device 设备</li>
<li>DHTML (dynamic HyperText Markup Language)动态超文本标记语言</li>
<li>dialog 对话框</li>
<li>Dictionaries 字典</li>
<li>digest 摘要</li>
<li>digital 数字的</li>
<li>directive (编译)指示符</li>
<li>directory 目录</li>
<li>disassembler 反汇编器</li>
<li>DISCO (Discovery of Web Services)Web Services 的查找</li>
<li>dispatch 调度、分派、派发</li>
<li>distributed computing 分布式计算</li>
<li>distributed query 分布式查询 (for database)</li>
<li>DNA (Distributed interNet Application) 分布式网间应用程序</li>
<li>document 文档</li>
<li>DOM (Document Object Model)文档对象模型</li>
<li>dot operator (圆)点操作符</li>
<li>double-byte character set (DBCS)双字节字符集(DBCS)</li>
<li>driver 驱动(程序)</li>
<li>DTD (document type definition) 文档类型定义</li>
<li>dump 转储</li>
<li>dump file 转储文件</li>
<li></li>
</ul>
<h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><p>-</p>
<ul>
<li>e-business 电子商务</li>
<li>efficiency 效率</li>
<li>efficient 高效</li>
<li>encapsulation 封装</li>
<li>end user 最终用户</li>
<li>end-to-end authentication 端对端身份验证</li>
<li>engine 引擎</li>
<li>entity 实体</li>
<li>enum (enumeration) 枚举</li>
<li>enumerators 枚举成员、枚举器</li>
<li>equal 相等</li>
<li>equality 相等性</li>
<li>equality operator 等号操作符</li>
<li>error log 错误日志 (for database)</li>
<li>escape character 转义符、转义字符</li>
<li>escape code 转义码</li>
<li>evaluate 评估</li>
<li>event 事件</li>
<li>event driven 事件驱动的</li>
<li>event handler 事件处理器</li>
<li>evidence 证据</li>
<li>exception 异常</li>
<li>exception declaration 异常声明</li>
<li>exception handling 异常处理、异常处理机制</li>
<li>exception specification 异常规范</li>
<li>exception-safe 异常安全的</li>
<li>exit 退出</li>
<li>explicit 显式</li>
<li>explicit specialization 显式特化</li>
<li>explicit transaction 显式事务 (for database)</li>
<li>export 导出</li>
<li>expression 表达式</li>
<li></li>
</ul>
<h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><ul>
<li>fat client 胖客户端</li>
<li>feature 特性、特征</li>
<li>fetch 提取</li>
<li>field 字段 (for database)</li>
<li>field 字段(java)</li>
<li>field length 字段长度 (for database)</li>
<li>file 文件</li>
<li>filter 筛选 (for database)</li>
<li>finalization 终结</li>
<li>finalizer 终结器</li>
<li>firewall 防火墙</li>
<li>flag 标记</li>
<li>flash memory 闪存</li>
<li>flush 刷新</li>
<li>font 字体</li>
<li>foreign key (FK) 外键(FK) (for database)</li>
<li>form 窗体</li>
<li>formal parameter 形参</li>
<li>forward declaration 前置声明</li>
<li>forward-only 只向前的</li>
<li>forward-only cursor 只向前游标 (for database)</li>
<li>framework 框架</li>
<li>full specialization 完全特化</li>
<li>function 函数</li>
<li>function call operator (即 operator ()) 函数调用操作符</li>
<li>function object 函数对象</li>
<li>function template 函数模板</li>
<li>functionality 功能</li>
<li>functor 仿函数</li>
<li></li>
</ul>
<h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p>-</p>
<ul>
<li>GC (Garbage collection) 垃圾回收(机制)、垃圾收集(机制)</li>
<li>generate 生成</li>
<li>generic 泛化的、一般化的、通用的</li>
<li>generic algorithm 通用算法</li>
<li>genericity 泛型</li>
<li>getter (相对于 setter)取值函数</li>
<li>global 全局的</li>
<li>global object 全局对象</li>
<li>grant 授权 (for database)</li>
<li>group 组、群</li>
<li>group box 分组框</li>
<li>GUI 图形界面</li>
<li>GUID (Globally Unique Identifier) 全球唯一标识符</li>
</ul>
<h4 id="H"><a href="#H" class="headerlink" title="H"></a>H</h4><p>-</p>
<ul>
<li>handle 句柄，处理</li>
<li>handler 处理器</li>
<li>hard disk 硬盘</li>
<li>hard-coded 硬编码的</li>
<li>hard-copy 截屏图</li>
<li>hardware 硬件</li>
<li>hash table 散列表、哈希表</li>
<li>header file 头文件</li>
<li>heap 堆</li>
<li>help file 帮助文件</li>
<li>hierarchical data 阶层式数据、层次式数据</li>
<li>hierarchy 层次结构、继承体系</li>
<li>high level 高阶、高层</li>
<li>hook 钩子</li>
<li>Host (application)宿主(应用程序)</li>
<li>hot key 热键</li>
<li>HTML (HyperText Markup Language) 超文本标记语言</li>
<li>HTTP (HyperText Transfer Protocol) 超文本传输协议</li>
<li>HTTP pipeline HTTP 管道</li>
<li>hyperlink 超链接</li>
<li></li>
</ul>
<h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><ul>
<li>icon 图标</li>
<li>IDE (Integrated Development Environment)集成开发环境</li>
<li>identifier 标识符</li>
<li>IDL (Interface Definition Language) 接口定义语言</li>
<li>idle time 空闲时间</li>
<li>if and only if 当且仅当</li>
<li>IL (Intermediate Language) 中间语言、中介语言</li>
<li>image 图象</li>
<li>IME 输入法</li>
<li>immediate base 直接基类</li>
<li>immediate derived 直接派生类</li>
<li>immediate updating 即时更新 (for database)</li>
<li>implement 实现</li>
<li>implementation 实现、实现品</li>
<li>implicit 隐式</li>
<li>implicit transaction 隐式事务 (for database)</li>
<li>import 导入</li>
<li>incremental update 增量更新 (for database)</li>
<li>Independent Set 独立集</li>
<li>index 索引 (for database)</li>
<li>infinite loop 无限循环</li>
<li>infinite recursive 无限递归</li>
<li>information 信息</li>
<li>inheritance 继承、继承机制</li>
<li>initialization 初始化</li>
<li>initialization list 初始化列表、初始值列表</li>
<li>initialize 初始化</li>
<li>inline 内联</li>
<li>inline expansion 内联展开</li>
<li>inner join 内联接 (for database)</li>
<li>instance 实例</li>
<li>instantiated 具现化、实体化(常应用于 template)</li>
<li>instantiation 具现体、具现化实体(常应用于 template)</li>
<li>integrate 集成、整合</li>
<li>integrity 完整性、一致性</li>
<li>integrity constraint 完整性约束 (for database)</li>
<li>interacts 交互</li>
<li>interface 接口</li>
<li>interoperability 互操作性、互操作能力</li>
<li>interpreter 解释器</li>
<li>introspection 自省</li>
<li>invariants 不变性</li>
<li>invoke 调用</li>
<li>isolation level 隔离级别 (for database)</li>
<li>item 项、条款、项目</li>
<li>iterate 迭代</li>
<li>iteration 迭代(回圈每次轮回称为一个 iteration)</li>
<li>iterative 反复的、迭代的</li>
<li>iterator 迭代器</li>
<li></li>
</ul>
<h4 id="J"><a href="#J" class="headerlink" title="J"></a>J</h4><p>-</p>
<ul>
<li>JIT compilation JIT 编译即时编译</li>
<li>Job Scheduling 工程安排</li>
<li>K</li>
<li>key 键 (for database)</li>
<li>key column 键列 (for database)</li>
<li></li>
</ul>
<h4 id="L"><a href="#L" class="headerlink" title="L"></a>L</h4><p>-</p>
<ul>
<li>left outer join 左向外联接 (for database)</li>
<li>level 阶、层例</li>
<li>library 库</li>
<li>lifetime 生命期、寿命</li>
<li>Linear Programming 线性规划</li>
<li>link 连接、链接</li>
<li>linkage 连接、链接</li>
<li>linker 连接器、链接器</li>
<li>list 列表、表、链表</li>
<li>list box 列表框</li>
<li>literal constant 字面常数</li>
<li>livelock 活锁 (for database)</li>
<li>load 装载、加载</li>
<li>download 下载</li>
<li>load balancing 负载平衡</li>
<li>loader 装载器、载入器</li>
<li>local 局部的</li>
<li>local object 局部对象</li>
<li>lock 锁</li>
<li>log 日志</li>
<li>login 登录</li>
<li>login security mode 登录安全模式 (for database)</li>
<li>lookup table 查找表 (for database)</li>
<li>loop 循环</li>
<li>loose coupling 松散耦合</li>
<li>lvalue 左值</li>
<li></li>
</ul>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>-</p>
<ul>
<li>machine code 机器码、机器代码</li>
<li>macro 宏</li>
<li>maintain 维护</li>
<li>managed code 受控代码、托管代码</li>
<li>Managed Extensions 受控扩充件、托管扩展</li>
<li>managed object 受控对象、托管对象</li>
<li>manifest 清单</li>
<li>many-to-many relationship 多对多关系 (for database)</li>
<li>many-to-one relationship 多对一关系 (for database)</li>
<li>marshal 列集</li>
<li>Matching 匹配</li>
<li>member 成员</li>
<li>member access operator 成员取用运算子(有 dot 和 arrow 两种)</li>
<li>member function 成员函数</li>
<li>member initialization list 成员初始值列表</li>
<li>memory 内存</li>
<li>memory leak 内存泄漏</li>
<li>menu 菜单</li>
<li>message 消息</li>
<li>message based 基于消息的</li>
<li>message loop 消息环</li>
<li>message queuing 消息队列</li>
<li>metadata 元数据</li>
<li>metaprogramming 元编程</li>
<li>method 方法</li>
<li>micro 微</li>
<li>middle tier 中间层</li>
<li>middleware 中间件</li>
<li>modeling 建模</li>
<li>modeling language 建模语言</li>
<li>modem 调制解调器</li>
<li>modifier 修饰字、修饰符</li>
<li>module 模块</li>
<li>most derived class 最底层的派生类</li>
<li>mouse 鼠标</li>
<li>multi-tasking 多任务</li>
<li>multi-thread 多线程</li>
<li>multicast delegate 组播委托、多点委托</li>
<li>multithreaded server application 多线程服务器应用程序</li>
<li>multiuser 多用户</li>
<li>mutable 可变的</li>
<li>mutex 互斥元、互斥体</li>
<li></li>
</ul>
<h4 id="N"><a href="#N" class="headerlink" title="N"></a>N</h4><p>-</p>
<ul>
<li>named parameter 命名参数</li>
<li>named pipe 命名管道</li>
<li>namespace 名字空间、命名空间</li>
<li>native 原生的、本地的</li>
<li>native code 本地码、本机码</li>
<li>nested class 嵌套类</li>
<li>nested query 嵌套查询 (for database)</li>
<li>nested table 嵌套表 (for database)</li>
<li>network 网络</li>
<li>network card 网卡</li>
<li>Network Flow 网络流</li>
<li></li>
</ul>
<h4 id="O"><a href="#O" class="headerlink" title="O"></a>O</h4><p>-</p>
<ul>
<li>object 对象</li>
<li>object based 基于对象的</li>
<li>object model 对象模型</li>
<li>object oriented 面向对象的</li>
<li>ODBC data source ODBC 数据源 (for database)</li>
<li>ODBC driver ODBC 驱动程序 (for database)</li>
<li>one-to-many relationship 一对多关系 (for database)</li>
<li>one-to-one relationship 一对一关系 (for database)</li>
<li>operating system (OS) 操作系统</li>
<li>operation 操作</li>
<li>operator 操作符、运算符</li>
<li>option 选项</li>
<li>outer join 外联接 (for database)</li>
<li>overflow 上限溢位(相对于 underflow)</li>
<li>overload 重载</li>
<li>override 覆写、重载、重新定义</li>
<li></li>
</ul>
<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>-</p>
<ul>
<li>package 包</li>
<li>packaging 打包</li>
<li>palette 调色板</li>
<li>parallel 并行</li>
<li>parameter 参数、形式参数、形参</li>
<li>parameter list 参数列表</li>
<li>parameterize 参数化</li>
<li>parent class 父类</li>
<li>parentheses 圆括弧、圆括号</li>
<li>parse 解析</li>
<li>parser 解析器</li>
<li>part 零件、部件</li>
<li>partial specialization 局部特化</li>
<li>pass by reference 引用传递</li>
<li>pass by value 值传递</li>
<li>pattern 模式</li>
<li>persistence 持久性</li>
<li>pixel 像素</li>
<li>placeholder 占位符</li>
<li>platform 平台</li>
<li>Point Location 位置查询</li>
<li>pointer 指针</li>
<li>polymorphism 多态</li>
<li>pooling 池化</li>
<li>pop up 弹出式</li>
<li>port 端口</li>
<li>postfix 后缀</li>
<li>precedence 优先序(通常用于运算子的优先执行次序)</li>
<li>prefix 前缀</li>
<li>preprocessor 预处理器</li>
<li>primary key (PK)主键(PK) (for database)</li>
<li>primary table 主表 (for database)</li>
<li>primitive type 原始类型</li>
<li>print 打印</li>
<li>printer 打印机</li>
<li>procedure 过程</li>
<li>process 进程</li>
<li>program 程序</li>
<li>programmer 程序员</li>
<li>programming 编程、程序设计</li>
<li>progress bar 进度指示器</li>
<li>project 项目、工程</li>
<li>property 属性</li>
<li>protocol 协议</li>
<li>pseudo code 伪码</li>
<li></li>
</ul>
<h4 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h4><ul>
<li>qualified 合格的</li>
<li>qualifier 修饰符</li>
<li>quality 质量</li>
<li>queue 队列</li>
<li></li>
</ul>
<h4 id="R"><a href="#R" class="headerlink" title="R"></a>R</h4><p>-</p>
<ul>
<li>radio button 单选按钮</li>
<li>random number 随机数</li>
<li>Random Number Generation 随机数生成</li>
<li>range 范围、区间</li>
<li>rank 等级</li>
<li>raw 未经处理的</li>
<li>re-direction 重定向</li>
<li>readOnly 只读</li>
<li>record 记录 (for database)</li>
<li>recordset 记录集 (for database</li>
<li>recursion 递归</li>
<li>recursive 递归</li>
<li>refactoring 重构</li>
<li>refer 引用、参考</li>
<li>reference 引用、参考</li>
<li>reflection 反射</li>
<li>refresh data 刷新数据 (for database)</li>
<li>register 寄存器</li>
<li>regular expression 正则表达式</li>
<li>relational database 关系数据库</li>
<li>remote 远程</li>
<li>remote request 远程请求</li>
<li>represent 表述，表现</li>
<li>resolution 解析过程</li>
<li>resolve 解析、决议</li>
<li>result set 结果集 (for database)</li>
<li>retrieve data 检索数据</li>
<li>return 返回</li>
<li>return type 返回类型</li>
<li>return value 返回值</li>
<li>revoke 撤销</li>
<li>right outer join 右向外联接 (for database)</li>
<li>robust 健壮</li>
<li>robustness 健壮性</li>
<li>roll back 回滚 (for database)</li>
<li>roll forward 前滚 (for database)</li>
<li>routine 例程</li>
<li>row 行 (for database)</li>
<li>rowset 行集 (for database)</li>
<li>RPC (remote procedure call)RPC(远程过程调用)</li>
<li>runtime 执行期、运行期、执行时、运行时</li>
<li>rvalue 右值</li>
<li></li>
</ul>
<h4 id="S"><a href="#S" class="headerlink" title="S"></a>S</h4><p>-</p>
<ul>
<li>Satisfiability 可满足性</li>
<li>save 保存</li>
<li>savepoint 保存点 (for database)</li>
<li>SAX (Simple API for XML)</li>
<li>scalable 可伸缩的、可扩展的</li>
<li>schedule 调度</li>
<li>scheduler 调度程序</li>
<li>schema 模式、纲目结构</li>
<li>scope 作用域、生存空间</li>
<li>screen 屏幕</li>
<li>scroll bar 滚动条</li>
<li>SDK (Software Development Kit)软件开发包</li>
<li>sealed class 密封类</li>
<li>search 查找</li>
<li>Searching 查找</li>
<li>semantics 语义</li>
<li>sequential container 序列式容器</li>
<li>serial 串行</li>
<li>serialization/serialize 序列化</li>
<li>server 服务器、服务端</li>
<li>session 会话 (for database)</li>
<li>Set and String Problems 集合与串的问题</li>
<li>Set Cover 集合覆盖</li>
<li>Set Data Structures 集合</li>
<li>Set Packing 集合配置</li>
<li>setter 设值函数</li>
<li>side effect 副作用</li>
<li>signature 签名</li>
<li>single-threaded 单线程</li>
<li>slider 滑块</li>
<li>slot 槽</li>
<li>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议</li>
<li>snapshot 截屏图</li>
<li>snapshot 快照 (for database)</li>
<li>SOAP (simple object access protocol) 简单对象访问协议</li>
<li>software 软件</li>
<li>Sorting 排序</li>
<li>source code 源码、源代码</li>
<li>specialization 特化</li>
<li>specification 规范、规格</li>
<li>splitter 切分窗口</li>
<li>SQL (Structured Query Language) 结构化查询语言 (for database)</li>
<li>stack 栈、堆栈</li>
<li>standard library 标准库</li>
<li>standard template library 标准模板库</li>
<li>stateless 无状态的</li>
<li>statement 语句、声明</li>
<li>static cursor 静态游标 (for database)</li>
<li>static SQL statements 静态 SQL 语句 (for database)</li>
<li>status bar 状态条</li>
<li>stored procedure 存储过程 (for database)</li>
<li>stream 流</li>
<li>string 字符串</li>
<li>String Matching 模式匹配</li>
<li>stub 存根</li>
<li>subobject 子对象</li>
<li>subquery 子查询 (for database)</li>
<li>subscript operator 下标操作符</li>
<li>support 支持</li>
<li>suspend 挂起</li>
<li>symbol 记号</li>
<li>syntax 语法</li>
<li>system databases 系统数据库 (for database)</li>
<li>system tables 系统表 (for database)</li>
<li></li>
</ul>
<h4 id="T"><a href="#T" class="headerlink" title="T"></a>T</h4><ul>
<li>table 表 (for database)</li>
<li>table-level constraint 表级约束 (for database)</li>
<li>target 标的,目标</li>
<li>task switch 工作切换</li>
<li>TCP (Transport Control Protocol) 传输控制协议</li>
<li>template 模板</li>
<li>temporary object 临时对象</li>
<li>temporary table 临时表 (for database)</li>
<li>text 文本</li>
<li>Text Compression 压缩</li>
<li>text file 文本文件</li>
<li>thin client 瘦客户端</li>
<li>third-party 第三方</li>
<li>thread 线程</li>
<li>thread-safe 线程安全的</li>
<li>throw 抛出、引发(常指发出一个 exception)</li>
<li>trace 跟踪</li>
<li>transaction 事务 (for database)</li>
<li>transaction log 事务日志 (for database)</li>
<li>transaction rollback 事务回滚 (for database)</li>
<li>traverse 遍历</li>
<li>trigger 触发器 (for database)</li>
<li>type 类型</li>
<li></li>
</ul>
<h4 id="U"><a href="#U" class="headerlink" title="U"></a>U</h4><ul>
<li>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成</li>
<li>UML (unified modeling language)统一建模语言</li>
<li>unary function 单参函数</li>
<li>unary operator 一元操作符</li>
<li>unboxing 拆箱、拆箱转换</li>
<li>underflow 下限溢位(相对于 overflow)</li>
<li>Unicode 统一字符编码标准，采用双字节对字符进行编码</li>
<li>Union query 联合查询 (for database)</li>
<li>UNIQUE constraints UNIQUE 约束 (for database)</li>
<li>unique index 唯一索引 (for database)</li>
<li>unmanaged code 非受控代码、非托管代码</li>
<li>unmarshal 散集</li>
<li>unqualified 未经限定的、未经修饰的</li>
<li>URI (Uniform Resource identifier) 统一资源标识符</li>
<li>URL (Uniform Resource Locator) 统一资源定位器</li>
<li>user 用户</li>
<li>user interface 用户界面</li>
<li></li>
</ul>
<h4 id="V"><a href="#V" class="headerlink" title="V"></a>V</h4><ul>
<li>value types 值类型</li>
<li>variable 变量</li>
<li>vector 向量(一种容器，有点类似 array)</li>
<li>vendor 厂商</li>
<li>viable 可行的</li>
<li>video 视频</li>
<li>view 视图 (for database)</li>
<li>view 视图</li>
<li>virtual function 虚函数</li>
<li>virtual machine 虚拟机</li>
<li>virtual memory 虚拟内存</li>
</ul>
<h4 id="W"><a href="#W" class="headerlink" title="W"></a>W</h4><ul>
<li>Web Services web 服务</li>
<li>WHERE clause WHERE 子句 (for database)</li>
<li>wildcard characters 通配符字符 (for database)</li>
<li>wildcard search 通配符搜索 (for database)</li>
<li>window 窗口</li>
<li>window function 窗口函数</li>
<li>window procedure 窗口过程</li>
<li>Windows authentication Windows 身份验证</li>
<li>wizard 向导</li>
<li>word 单词</li>
<li>write enable 写启用 (for database)</li>
<li>write-only 只写</li>
<li>WSDL (Web Service Description Language)Web Service 描述语言</li>
<li></li>
</ul>
<h4 id="X"><a href="#X" class="headerlink" title="X"></a>X</h4><ul>
<li>XML (eXtensible Markup Language) 可扩展标记语言</li>
<li>XML Message Interface (XMI) XML 消息接口</li>
<li>XSD (XML Schema Definition) XML 模式定义语言</li>
<li>XSL (eXtensible Stylesheet Language) 可扩展样式表语言</li>
<li>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换</li>
<li>xxx based 基于 xxx 的</li>
<li>xxx oriented 面向 xxx**</li>
</ul>
]]></content>
      <categories>
        <category>单词表</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>前端播放rtsp视频流遇到的坑</title>
    <url>/blogs/2023/11/07/%E5%89%8D%E7%AB%AF%E6%92%AD%E6%94%BErtsp%E8%A7%86%E9%A2%91%E6%B5%81%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h4 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a>需求阶段</h4><p>由于我们公司，在内网开发，后端也不愿意去替我处理 rtsp 文档流。前端也对 rtsp 文档流，没有办法使用，所以有了这篇博客。</p>
<h4 id="能播放-rtsp-流的播放器，"><a href="#能播放-rtsp-流的播放器，" class="headerlink" title="能播放 rtsp 流的播放器，"></a>能播放 rtsp 流的播放器，</h4><p>VLC media playe，和海康自家的 vsplayer。都可以播放。</p>
<h4 id="开发经历"><a href="#开发经历" class="headerlink" title="开发经历"></a>开发经历</h4><p>因为我们内网开发很麻烦，我想在我的电脑下，就把处理 rtsp 流的方案去解决了，但是，完全找不到公共我可以使用的 rtsp 公共流。所以，我只能在我们内网环境下，对播放进行验证。。</p>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ol>
<li><p>下载 flash，据说 flash 完全兼容，但是我谷歌浏览器都降级到了 52 版本，ie11，浏览器，也没发现可以看。这个时候，要么是 flash 下载的插件不行，要么就是，我的浏览器版本还是要降级。flash，而且兼容性也不好。所以我选择了放弃 flash 方案。</p>
</li>
<li><p>使用 VLC media playe，在浏览器调用 vlc 组件进行实现。参考的文档，但是发现下载出来的 vlc media playe 根本就没有这个插件 js 文件，而且，我也无法使用，只能作罢。</p>
</li>
<li><p>海康提供的 web 插件，我们后端说内网无法进行开发。</p>
</li>
<li><p>webrtc-streamer，运行起来，启动一个服务，我们把 rtsp 流，给 webrtc-streamer，然后 webrtc-streamer 进行解码，转码，推流，给我们使用，这样就可以实现 rtsp 流播放。</p>
</li>
<li><p>猿大师，这个是付费方案，暂不考虑。</p>
</li>
<li><p>萤石云，如果不考虑内网环境，萤石云可以提供 rtsp 转码服务的。</p>
</li>
</ol>
<h4 id="关于-rtsp-文档流疑难杂症"><a href="#关于-rtsp-文档流疑难杂症" class="headerlink" title="关于 rtsp 文档流疑难杂症"></a>关于 rtsp 文档流疑难杂症</h4><p>rtsp 视频流复杂的地方在于，前端无法进行接受，至少对于现代前端来说。所以就很麻烦。需要去把 rtsp 进行解码，转码，推流。这个工程本来就不应该前端去实现的。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>我采取了方案 4， webrtc-streamer，下载 exe，他会直接在我本地启动一个服务，负责解码转码推流。然后我们部署到了一台电脑上，让他转跑这个服务。。</p>
<p><a href="https://blog.csdn.net/qq_44843983/article/details/129159279">解决方案参考链接</a></p>
]]></content>
      <categories>
        <category>rtsp</category>
      </categories>
      <tags>
        <tag>webrtc-streamer转码推流</tag>
      </tags>
  </entry>
  <entry>
    <title>vue当中的nextTick</title>
    <url>/blogs/2023/11/07/%E5%AD%A6%E4%B9%A0vue%E5%BD%93%E4%B8%AD%E7%9A%84nextTick/</url>
    <content><![CDATA[<pre><code>vue的dom是异步更新的，当监测到数据变动的时候，vue会开启一个队列，并且缓冲同一事件下循环当中的所有数据变更，哪怕一个数据我们在这个事件里面做了n次更新，只会被vue推入队列中一次。



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;div ref=&quot;list&quot;&gt;</span><br><span class="line">      &lt;div v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;say &#123;&#123; title &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HelloWorld&quot;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: &quot;项目1&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: &quot;项目2&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: &quot;项目3&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: &quot;项目4&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      title: &quot;hello&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      this.list.push(&#123;</span><br><span class="line">        name: Math.random(),</span><br><span class="line">      &#125;);</span><br><span class="line">      this.list.push(&#123;</span><br><span class="line">        name: Math.random(),</span><br><span class="line">      &#125;);</span><br><span class="line">      this.list.push(&#123;</span><br><span class="line">        name: Math.random(),</span><br><span class="line">      &#125;);</span><br><span class="line">      this.title = &quot;Hello Word&quot;;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        console.log(this.$refs.list.childNodes.length);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    setList(time) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        this.list.push(&#123;</span><br><span class="line">          name: Math.random(),</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

在nexttick当中我们能够获取到最新的dom。。


应用场景，比如，数据更新后，计算这个列表的高度。比如我们使用的组件，遇到了获取数据的问题。这个时候，nexttick 能获取到dom更新后的状态。
</code></pre>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue当中的nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域是什么？</title>
    <url>/blogs/2023/11/07/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<pre><code>#### 理解作用域

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 11;</span><br></pre></td></tr></table></figure>

在处理 let a = 11；这段代码当中，需要三个角色。

1. 编译器，对js代码块，进行语法分析，词法分析，把分析出来的代码，转换成js引擎能执行的代码。
2. 作用域，负责收集维护所有声明的变量，并且实施一套严格的规则，确定当前的代码对变量的访问权限。
3. 从头到尾负责整个js的编译和执行过程。


编译器和引擎作用域是如何协同工作的，比如，**let a = 11**；这段代码。首先，出场的，编译器，**let a**，编译器，会找到作用域，问他，是否存在a这个变量，在同一作用域环境当中，如果作用域告诉，编译器，存在，那么，编译器就会忽略，**let a**，否则，就会他会要求，作用域在当天的作用域当中重新声明一个新变量为a。


接下来，编译器就会为，js引擎生成做需要代码，这些代码被用来处理，**a = 11**这个赋值操作，引擎在运行的时候，会找到作用域问，当前作用域下面也没有声明变量a的变量，如果有，引擎就会使用这个变量，如果没有，那就向上寻找，最终找到，变量a，将11赋值给他，如果寻找不到，那就会抛出异常。


js**引擎的查询分为** LHS查询和RHS查询。
LHS查询，会查询当前作用域当中该变量是否存在，如果不存在就向上查找。查找不到就会抛出错误。

RHS查询，当前变量一定存在且被声明，RHS查询是为了获取到变量的值。




作用域的嵌套

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 11;</span><br><span class="line">funtion foo(b)&#123;</span><br><span class="line">console.log(a+b)</span><br><span class="line">&#125;</span><br><span class="line">foo(2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

引擎：作用域老兄，变量a是否被声明
作用域：哈哈，我找到了，变量a。
引擎：作用域老兄，foo函数是否存在。
作用域，foo在呢
引擎：console.log是内部方法，作用域老兄，变量a+b，a存在当前作用域不？b存在当前作用域不？
作用域：b是一个参数，在呢，变量a不熟！
引擎：想上寻找，全局作用域老兄你见过，变量a吗。
全局作用域：引擎老弟，变量a在呢。
引擎：好的！




关于作用域的规则

1. 外部作用域无法访问到内部作用域
2. 内部作用域能访问外部作用域
3. 所谓词法作用域，就是一层一层的作用域像楼层一样进行嵌套。最外部的作用域在高层，最内部的作用域在底层。当前的作用域，去向上寻找就是作用域链条，作用域和作用域的这栋大楼是由最顶层的全局作用域+词法作用域+当前作用域。




总结，编译器负责词法语法分析，编译代码给引擎使用，作用域，负责管理js当中的标识符，编译器会和引擎都会找作用域去确定，标识符在当前作用域是否存在，不存在那就会继续想上查找，直到找到或不存在。

作用域的嵌套起来，就是一个词法作用域。就像楼层一样。
</code></pre>
]]></content>
      <categories>
        <category>你不知道的javascript</category>
      </categories>
      <tags>
        <tag>你不知道的javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习vue3 计算属性</title>
    <url>/blogs/2023/08/08/%E5%AD%A6%E4%B9%A0vue3%E5%BD%93%E4%B8%AD%E7%9A%84computed/</url>
    <content><![CDATA[<h5 id="vue3-当中的计算属性"><a href="#vue3-当中的计算属性" class="headerlink" title="vue3 当中的计算属性"></a>vue3 当中的计算属性</h5><p>例子 1.我们有一些价格，条件等着计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;价格:&#123;&#123; price &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;总价格：&#123;&#123; totalPirce &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;优惠价格:&#123;&#123; discountPrice &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;input type=&quot;number&quot; min=&quot;1&quot; step=&quot;5&quot; v-model=&quot;num&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const price = ref(10);</span><br><span class="line">const num = ref(1);</span><br><span class="line">const discount = ref(0.8);</span><br><span class="line">const totalPirce = computed(() =&gt; &#123;</span><br><span class="line">  return num.value * price.value;</span><br><span class="line">&#125;);</span><br><span class="line">const discountPrice = computed(() =&gt; &#123;</span><br><span class="line">  return num.value * price.value * discount.value;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>计算属性</strong>，返回值为计算属性 ref，和普通的 ref 一样。在模板里面，会自动解包，我们也可以.value,给他手动解包。</p>
<h5 id="使用计算属性-vs-方法。"><a href="#使用计算属性-vs-方法。" class="headerlink" title="使用计算属性 vs 方法。"></a>使用计算属性 vs 方法。</h5><p>计算属性会基于响应式依赖被缓存，只有响应式依赖发生了改变，计算属性才会重新计算。这也就意味着，只要响应式依赖的值不变，无论多少次访问，都会返回之前的结果。不会重复执行 getter 函数。</p>
<p>方法每次都会执行一次 getter 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;价格:&#123;&#123; price &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-for=&quot;(item, index) in 10&quot; :key=&quot;index&quot;&gt;总价格：&#123;&#123; totalPirce &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-for=&quot;(item, index) in 10&quot; :key=&quot;index&quot;&gt;&#123;&#123; getTotalPirce() &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;input type=&quot;number&quot; min=&quot;1&quot; step=&quot;1&quot; v-model=&quot;num&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const price = ref(10);</span><br><span class="line">const num = ref(1);</span><br><span class="line">const totalPirce = computed(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;计算属性执行了&quot;);</span><br><span class="line">  return num.value * price.value;</span><br><span class="line">&#125;);</span><br><span class="line">function getTotalPirce() &#123;</span><br><span class="line">  console.log(&quot;getTotalPirce性执行了&quot;);</span><br><span class="line">  return num.value * price.value;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h5><p>computed 计算属性默认的只读的，只有在特殊情况下，我们才会用到<strong>可写属性</strong>，我们可以通过提供 getter，和 setter 来创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;价格:&#123;&#123; price &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;总价格：&#123;&#123; totalPirce &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;单个优惠价格：&#123;&#123; discountsPrice &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;input type=&quot;number&quot; min=&quot;1&quot; step=&quot;1&quot; v-model=&quot;num&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br><span class="line">  &lt;button @click=&quot;setDiscounts&quot;&gt;设置折扣&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick, computed &#125; from &quot;vue&quot;;</span><br><span class="line">const price = ref(10);</span><br><span class="line">const num = ref(1);</span><br><span class="line">const discounts = ref(0.8);</span><br><span class="line">const totalPirce = computed(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;计算属性执行了&quot;);</span><br><span class="line">  return num.value * price.value; //只去执行一次discounts</span><br><span class="line">&#125;);</span><br><span class="line">const discountsPrice = computed(&#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    return price.value * discounts.value;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newValue) &#123;</span><br><span class="line">    console.log(newValue);</span><br><span class="line">    discounts.value = newValue;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">function setDiscounts() &#123;</span><br><span class="line">  discounts.value = 0.4;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://naotu.baidu.com/file/024e1df1914ca675571460b922442a99">百度脑图</a></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>学习vue3 响应式基础</title>
    <url>/blogs/2023/08/08/%E5%AD%A6%E4%B9%A0vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="vue-响应式基础"><a href="#vue-响应式基础" class="headerlink" title="vue 响应式基础"></a>vue 响应式基础</h4><h5 id="我们可以使用-reactive，创建出一个响应式的对象。"><a href="#我们可以使用-reactive，创建出一个响应式的对象。" class="headerlink" title="我们可以使用 reactive，创建出一个响应式的对象。"></a>我们可以使用 reactive，创建出一个响应式的对象。</h5><p>这里的响应指的是，如同 vue2 一样，我们在 data 函数里面创建的数据，都能被实时的更新到，模板里面。</p>
<p>例子如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;state.count&quot; /&gt;</span><br><span class="line">    &lt;button id=&quot;Dim&quot; class=&quot;num&quot; @click=&quot;increment&quot;&gt;&#123;&#123; state.count &#125;&#125;++&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">const state = reactive(&#123; count: 0 &#125;);</span><br><span class="line">function increment() &#123;</span><br><span class="line">  state.count++;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="响应数据具备深层响应性，响应式的引用类型数据的任何变动，vue-响应式都能检测得到。"><a href="#响应数据具备深层响应性，响应式的引用类型数据的任何变动，vue-响应式都能检测得到。" class="headerlink" title="响应数据具备深层响应性，响应式的引用类型数据的任何变动，vue 响应式都能检测得到。"></a>响应数据具备深层响应性，响应式的引用类型数据的任何变动，vue 响应式都能检测得到。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">const state = reactive(&#123; count: 0, list: [&#123; data: [&#123; name: &quot;li&quot; &#125;] &#125;] &#125;);</span><br><span class="line">const object = ref(&#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    list: [</span><br><span class="line">      &#123;</span><br><span class="line">        key: &quot;name&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">object.value.name.list[0].key = &quot;王五&quot;;</span><br><span class="line">state.list[0].data[0].name = &quot;赵四&quot;;</span><br><span class="line">console.log(object.value.name.list[0].key, state.list[0].data[0].name); //王五，赵四</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="响应式对象与原始对象，并不相等，虽然数据结构一样"><a href="#响应式对象与原始对象，并不相等，虽然数据结构一样" class="headerlink" title="响应式对象与原始对象，并不相等，虽然数据结构一样"></a>响应式对象与原始对象，并不相等，虽然数据结构一样</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">const state = reactive(&#123; count: 0, list: [&#123; data: [&#123; name: &quot;li&quot; &#125;] &#125;] &#125;);</span><br><span class="line">let object = &#123; count: 0, list: [&#123; data: [&#123; name: &quot;li&quot; &#125;] &#125;] &#125;;</span><br><span class="line">//响应式对象与原始对象并不相等</span><br><span class="line">console.log(state === object, state == object);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>reactive API 有两条局限性</strong></p>
<ol>
<li><p>只对集合类型，像 array，set，map，object 有效，不支持 string，number 这样的。</p>
</li>
<li><p>vue 响应系统是根据，属性访问进行追踪的，，这意味着我们必须保持对响应式对象的相同引用，这意味着我们不可以随意替换一个响应式对象。这将导致响应性连接的丢失。</p>
</li>
</ol>
<p>对响应式对象追踪断开的例子如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let state = reactive(&#123; count: 101 &#125;); //这个响应对象已经被断开</span><br><span class="line">state = reactive(&#123; count: 102 &#125;);</span><br><span class="line">console.log(state.count);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们将响应式对象，赋值或者解构给，变量的话，那么我们会失去响应性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">let state = reactive(&#123; count: 101 &#125;); //这个响应对象已经被断开</span><br><span class="line">let count = state.count;</span><br><span class="line">state.count = 102;</span><br><span class="line">console.log(count, state.count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用-ref-来定义响应式变量"><a href="#使用-ref-来定义响应式变量" class="headerlink" title="使用 ref 来定义响应式变量"></a>使用 ref 来定义响应式变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const count = ref(0);</span><br></pre></td></tr></table></figure>

<p><strong>ref()会把参数，包装成为一个带.value 的对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const count = ref(0);</span><br><span class="line">console.log(count.value);//0</span><br></pre></td></tr></table></figure>

<p><strong>ref()在模板当中会存在解包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;number&quot; v-model=&quot;count&quot; /&gt;</span><br><span class="line">    &lt;!--模板里面使用count不需要带上value--&gt;</span><br><span class="line">    &lt;button id=&quot;Dim&quot; class=&quot;num&quot;&gt;&#123;&#123; count &#125;&#125;++&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">const count = ref(0);</span><br><span class="line">console.log(count.value);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>ref 作为渲染模板上下文的顶层属性的情况下，才会自动解包</strong><br>此处顶层属性是，object，所以，object.foo,才是 ref 响应变量。所以无法进行解包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; object.foo + 1 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">//ref 作为模板渲染上下文的顶层属性的话，才会自动解包。</span><br><span class="line">const object = &#123;</span><br><span class="line">  foo: ref(1),</span><br><span class="line">&#125;;</span><br><span class="line">object.foo.value++; //[object Object]1</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>我们把 object.foo 作为渲染模板上下文的顶层就可以自动解包了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; object.foo &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">//ref 作为模板渲染上下文的顶层属性的话，才会自动解包。</span><br><span class="line">const object = &#123;</span><br><span class="line">  foo: ref(1),</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; foo + 1 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">//ref 作为模板渲染上下文的顶层属性的话，才会自动解包。</span><br><span class="line">const object = &#123;</span><br><span class="line">  foo: ref(1),</span><br><span class="line">&#125;;</span><br><span class="line">object.foo.value++;</span><br><span class="line">const &#123; foo &#125; = object; //3</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>当 ref 响应变量，作为响应对象内部的值，那么会在响应对象内部进行自己解包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; state.count + 11 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">const count = ref(0);</span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">  count,</span><br><span class="line">&#125;);</span><br><span class="line">state.count = 10;</span><br><span class="line">state.count = count;</span><br><span class="line">console.log(state.count);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>如果把 ref 属性替换掉已经关联响应式对象的 ref 属性，那么就会把旧的换掉。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; state.count + 11 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">const count = ref(0);</span><br><span class="line">const state = reactive(&#123;</span><br><span class="line">  count,</span><br><span class="line">&#125;);</span><br><span class="line">// const count1 = ref(1);</span><br><span class="line">state.count = 10;</span><br><span class="line">state.count = count1;</span><br><span class="line">console.log(state.count);//12</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ref 作 reactive，或者其他集合的一部分的时候，无法自动解包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; array[2].value + 1 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref, nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">let array = reactive([1, 1, ref(1)]);</span><br><span class="line">let num = ref(0);</span><br><span class="line">console.log(array[2].value);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://naotu.baidu.com/file/0dd37b5d9b398c8b8353960406e49141">脑图</a></p>
]]></content>
      <categories>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>学习vue router</title>
    <url>/blogs/2023/08/08/%E5%AD%A6%E4%B9%A0vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h4 id="vue-的组件通讯都有那些方式？"><a href="#vue-的组件通讯都有那些方式？" class="headerlink" title="vue 的组件通讯都有那些方式？"></a>vue 的组件通讯都有那些方式？</h4><ol>
<li>props 父组件的数据，自动流向子组件。但是，子组件无法修改父组件的传参。</li>
<li>使用 vuex，组件之间进行通讯。</li>
<li>父组件使用 ref，通过$refs 获取到组件实例，在组件实例当中修改数据。一般情况下不推荐。</li>
<li>通过$root 访问组件节点，直接修改数据。</li>
<li>子组件通过$parent 可以访问到父组件实例，修改父组件的数据。</li>
<li>如果子组件的子组件想要访问到，vue 的父组件实例的话，需要通过，provide 进行注入，iinject 可选择想要注入的项。</li>
<li>使用 new vue 建立一条总线，通过 emit 提交可以实现，兄弟组件之间的通讯。</li>
<li>子组件想要改变父组件的值，必须通过$emit 进行提交。</li>
</ol>
<h5 id="父向子进行通讯"><a href="#父向子进行通讯" class="headerlink" title="父向子进行通讯"></a>父向子进行通讯</h5><h6 id="例子-1-props-通讯。"><a href="#例子-1-props-通讯。" class="headerlink" title="例子 1.props 通讯。"></a>例子 1.props 通讯。</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我的子组件</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;子组件:&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    message: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;ChildItem /&gt;</span><br><span class="line">    &lt;button @click=&quot;changeChildItem&quot;&gt;更改childitem组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildItem from &quot;@/components/child-item.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildItem,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;props是一个单向数据流，会自动流向子组件。&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="例子-2-使用-ref，-refs，进行通讯。"><a href="#例子-2-使用-ref，-refs，进行通讯。" class="headerlink" title="例子 2 使用 ref，$refs，进行通讯。"></a>例子 2 使用 ref，$refs，进行通讯。</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子组件</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;子组件:&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // props: &#123;</span><br><span class="line">  //   message: &#123;</span><br><span class="line">  //     type: String,</span><br><span class="line">  //     default: &quot;&quot;,</span><br><span class="line">  //   &#125;,</span><br><span class="line">  // &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">父组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;uForm&gt;</span><br><span class="line">      &lt;uFormItem&gt;</span><br><span class="line">        &lt;uInput&gt;&lt;/uInput&gt;</span><br><span class="line">      &lt;/uFormItem&gt;</span><br><span class="line">    &lt;/uForm&gt;</span><br><span class="line">    &lt;ChildItem ref=&quot;ChildItem&quot; /&gt;</span><br><span class="line">    &lt;button @click=&quot;changeChildItem&quot;&gt;父组件通过ref修改数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildItem from &quot;@/components/child-item.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildItem,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeChildItem() &#123;</span><br><span class="line">      this.$refs.ChildItem.message = &quot;hello，word&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="例子-3-使用-root-修改子组件的值"><a href="#例子-3-使用-root-修改子组件的值" class="headerlink" title="例子 3.使用$root 修改子组件的值"></a>例子 3.使用$root 修改子组件的值</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子组件</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;子组件:&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // props: &#123;</span><br><span class="line">  //   message: &#123;</span><br><span class="line">  //     type: String,</span><br><span class="line">  //     default: &quot;&quot;,</span><br><span class="line">  //   &#125;,</span><br><span class="line">  // &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">父组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;uForm&gt;</span><br><span class="line">      &lt;uFormItem&gt;</span><br><span class="line">        &lt;uInput&gt;&lt;/uInput&gt;</span><br><span class="line">      &lt;/uFormItem&gt;</span><br><span class="line">    &lt;/uForm&gt;</span><br><span class="line">    &lt;ChildItem ref=&quot;ChildItem&quot; /&gt;</span><br><span class="line">    &lt;button @click=&quot;changeChildItem&quot;&gt;父组件通过ref修改数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildItem from &quot;@/components/child-item.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildItem,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeChildItem() &#123;</span><br><span class="line">      this.$root.$children[0].$children[0].$children[1].message =</span><br><span class="line">        &quot;212121211111111111111111111111111111111111111111111111111111&quot;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="子向父组件进行通讯"><a href="#子向父组件进行通讯" class="headerlink" title="子向父组件进行通讯"></a>子向父组件进行通讯</h5><p>例子 1. $emit 进行通讯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;changeChildItem&quot;&gt;&#123;&#123; totalNum &#125;&#125;++&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    totalNum: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeChildItem() &#123;</span><br><span class="line">      this.$emit(&quot;on-change&quot;, this.totalNum);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">父组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;ChildItem ref=&quot;ChildItem&quot; @on-change=&quot;changeParent&quot; :totalNum=&quot;totalNum&quot; /&gt;</span><br><span class="line">    &lt;button&gt;父组件通过ref修改数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildItem from &quot;@/components/child-item.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildItem,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      totalNum: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeParent(totalNum) &#123;</span><br><span class="line">      this.totalNum = ++totalNum;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子 2.子组件通过$parent 修改父组件的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;changeChildItem&quot;&gt;&#123;&#123; totalNum &#125;&#125;++&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    totalNum: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 0,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeChildItem() &#123;</span><br><span class="line">      this.$parent.totalNum++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="子组件的子组件访问父组件传参。"><a href="#子组件的子组件访问父组件传参。" class="headerlink" title="子组件的子组件访问父组件传参。"></a>子组件的子组件访问父组件传参。</h5><p>使用 provide，iinject，进行注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件方法</span><br><span class="line"></span><br><span class="line">  provide: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      getMap: this.getMap,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">子组件接受</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;uInput&quot;&gt;</span><br><span class="line">    &lt;input /&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;send&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  inject: [&quot;getMap&quot;],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    send() &#123;</span><br><span class="line">      this.getMap();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mian.js文件</span><br><span class="line"></span><br><span class="line">Vue.prototype.$bus = new Vue();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">兄弟组件A，</span><br><span class="line"></span><br><span class="line"> changeChildItem() &#123;</span><br><span class="line">      this.$bus.$emit(&quot;brotherEvent&quot;, &quot;123&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">兄弟组件B</span><br><span class="line"></span><br><span class="line">  created() &#123;</span><br><span class="line">    this.$bus.$on(&quot;brotherEvent&quot;, (res) =&gt; &#123;</span><br><span class="line">      this.value = res;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结，vue 的组件通讯是，vue 框架最重要最核心的点。之前我对 vue 的理解不够深，觉得 vuex 和 props 就能打出一片天，这个想法观念是错误的。</p>
<p>因为项目的大小，实际需求出发，才能制定出合适的通讯方案。一味 vuex 反而会导致项目缺乏维护。不够灵活。</p>
]]></content>
      <categories>
        <category>vue router</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>学些canvas的使用</title>
    <url>/blogs/2023/02/23/%E5%AD%A6%E4%BA%9Bcanvas%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="学习如何使用-canvas。"><a href="#学习如何使用-canvas。" class="headerlink" title="学习如何使用 canvas。"></a>学习如何使用 canvas。</h4><h5 id="绘制一条直线。"><a href="#绘制一条直线。" class="headerlink" title="绘制一条直线。"></a>绘制一条直线。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建canvas</span><br><span class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;200px&quot;&gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">获取canvas对象</span><br><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">绘制图形</span><br><span class="line">cxt.moveTo(100, 120); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(200, 120); // 终点坐标 (x, y)</span><br><span class="line">cxt.stroke(); // 将起点和终点连接起来</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>canvas 有着自己的默认宽高，宽 300，高 150.可以在 canvas 标签上进行设置。如果在 css 里面进行设置的话，会导致 canvas 默认本身的宽高出现拉伸的情况。</p>
<p>默认 canvas，是黑色，线条宽度 1px，但是默认的 canvas 线条在底部，像素之间会堆叠，产生了 2px 的效果。</p>
<h5 id="canvas-的坐标系"><a href="#canvas-的坐标系" class="headerlink" title="canvas 的坐标系"></a>canvas 的坐标系</h5><p>canvas 的坐标系问题。canvas 遵守的是，w3c 坐标系，从左往右是 x 轴。从上到下是 y 轴，这个跟数学坐标系是不同的。我们使用 canvas，画 2 条线条。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(100, 120); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(200, 120); // 终点坐标 (x, y)</span><br><span class="line">cxt.stroke(); // 将起点和终点连接起来</span><br><span class="line">cxt.moveTo(10, 10);</span><br><span class="line">cxt.lineTo(200, 30);</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二条线，是一条斜线，是因为，y 坐标轴，从 10，30 是一个从上到下的关系。</p>
<h4 id="修改线条的样式"><a href="#修改线条的样式" class="headerlink" title="修改线条的样式"></a>修改线条的样式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(100, 120); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(200, 120); // 终点坐标 (x, y)</span><br><span class="line">cxt.moveTo(10, 10);</span><br><span class="line">cxt.lineTo(200, 30);</span><br><span class="line">cxt.lineWidth = 10; //设置线条宽度</span><br><span class="line">cxt.strokeStyle = &quot;red&quot;; //设置线条颜色</span><br><span class="line">cxt.lineCap = &quot;round&quot;; //修改直线两端样式</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>新开路径</strong></p>
<p>上面的例子，我们把 2 根线条都设置成了，红色。但是我们只想设置一条红色。其他的设置为其他颜色该怎么办呢？</p>
<p>此刻我们需要做两件事</p>
<ol>
<li>新开路径</li>
<li>设置新线段的样式</li>
</ol>
<p>两步少了一步都不行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(100, 120); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(200, 120); // 终点坐标 (x, y)</span><br><span class="line">cxt.lineWidth = 10; //设置线条宽度</span><br><span class="line">cxt.strokeStyle = &quot;red&quot;; //设置线条颜色</span><br><span class="line">cxt.lineCap = &quot;round&quot;; //修改直线两端样式</span><br><span class="line">cxt.stroke();</span><br><span class="line">//新开路径</span><br><span class="line">cxt.beginPath();</span><br><span class="line">cxt.lineWidth = 1;</span><br><span class="line">cxt.strokeStyle = &quot;blue&quot;;</span><br><span class="line">cxt.lineCap = &quot;round&quot;;</span><br><span class="line">cxt.moveTo(10, 10);</span><br><span class="line">cxt.lineTo(200, 30);</span><br><span class="line">cxt.stroke();</span><br></pre></td></tr></table></figure>

<h5 id="绘制折线"><a href="#绘制折线" class="headerlink" title="绘制折线"></a>绘制折线</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(20, 300); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(100, 50);</span><br><span class="line">cxt.lineTo(200, 200);</span><br><span class="line">cxt.lineTo(250, 100);</span><br><span class="line">cxt.lineTo(270, 180);</span><br><span class="line"></span><br><span class="line">cxt.lineWidth = 1; //设置线条宽度</span><br><span class="line">cxt.lineCap = &quot;round&quot;; //修改直线两端样式</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>成功绘制几条折线。</p>
<h4 id="canvas-绘制矩形"><a href="#canvas-绘制矩形" class="headerlink" title="canvas 绘制矩形"></a>canvas 绘制矩形</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(20, 100); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(200, 100);</span><br><span class="line">cxt.lineTo(200, 200);</span><br><span class="line">cxt.lineTo(200, 300);</span><br><span class="line">cxt.lineTo(20, 300);</span><br><span class="line">cxt.lineTo(20, 100);</span><br><span class="line"></span><br><span class="line">cxt.lineWidth = 1; //设置线条宽度</span><br><span class="line">cxt.lineCap = &quot;round&quot;; //修改直线两端样式</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对矩形进行描边</p>
<p>strokeStyle 属性要先设置描边颜色，再去设置要描边的属性的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(20, 100); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(120, 100);</span><br><span class="line">cxt.lineTo(120, 200);</span><br><span class="line">cxt.lineTo(20, 200);</span><br><span class="line">cxt.lineTo(20, 100);</span><br><span class="line"></span><br><span class="line">cxt.lineWidth = 1; //设置线条宽度</span><br><span class="line">cxt.lineCap = &quot;round&quot;; //修改直线两端样式</span><br><span class="line">cxt.stroke();</span><br><span class="line">cxt.strokeStyle = &quot;blue&quot;;</span><br><span class="line">cxt.strokeRect(20, 100, 100, 100); //(x,y,width，height)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="填充矩形"><a href="#填充矩形" class="headerlink" title="填充矩形"></a>填充矩形</h4><p>fillStyle 先设置颜色<br>在使用，fillRect 设置大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(20, 100); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(120, 100);</span><br><span class="line">cxt.lineTo(120, 200);</span><br><span class="line">cxt.lineTo(20, 200);</span><br><span class="line">cxt.lineTo(20, 100);</span><br><span class="line"></span><br><span class="line">cxt.lineWidth = 1; //设置线条宽度</span><br><span class="line">cxt.lineCap = &quot;round&quot;; //修改直线两端样式</span><br><span class="line">cxt.stroke();</span><br><span class="line">cxt.strokeStyle = &quot;blue&quot;;</span><br><span class="line">cxt.strokeRect(20, 100, 100, 100); //(x,y,width，height)</span><br><span class="line">cxt.fillStyle = &quot;yellow&quot;;</span><br><span class="line">cxt.fillRect(20, 100, 100, 100);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 react 填充矩形</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(20, 100); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(120, 100);</span><br><span class="line">cxt.lineTo(120, 200);</span><br><span class="line">cxt.lineTo(20, 200);</span><br><span class="line">cxt.lineTo(20, 100);</span><br><span class="line"></span><br><span class="line">cxt.lineWidth = 1; //设置线条宽度</span><br><span class="line">cxt.lineCap = &quot;round&quot;; //修改直线两端样式</span><br><span class="line">cxt.stroke();</span><br><span class="line">cxt.strokeStyle = &quot;blue&quot;;</span><br><span class="line">cxt.strokeRect(20, 100, 100, 100); //(x,y,width，height)</span><br><span class="line">cxt.fillStyle = &quot;yellow&quot;;</span><br><span class="line">cxt.rect(20, 100, 100, 100);</span><br><span class="line">cxt.fill();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="清空矩形和清空矩形"><a href="#清空矩形和清空矩形" class="headerlink" title="清空矩形和清空矩形"></a>清空矩形和清空矩形</h4><p>//可以清空当前的画布，和当前矩形。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cxt.clearRect(20, 100, 100, 100);//x,y,width,height</span><br><span class="line">cxt.clearRect(0, 0, canvas.width, canvas.height);</span><br></pre></td></tr></table></figure>

<h4 id="canvas-画一个三角形"><a href="#canvas-画一个三角形" class="headerlink" title="canvas 画一个三角形"></a>canvas 画一个三角形</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(20, 100); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(120, 100);</span><br><span class="line">cxt.lineTo(120, 200);</span><br><span class="line">cxt.lineTo(20, 100);</span><br><span class="line"></span><br><span class="line">cxt.lineWidth = 10; //设置线条宽度</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后一条 lineTo，和 moveTo 的 xy，一样，就可以闭合。缺点就是，三角形并没有实现完全的闭合效果。</p>
<p><strong>完全闭合</strong> closePath 方法可以让三角形完全闭合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制图形</span><br><span class="line">cxt.moveTo(20, 100); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(120, 100);</span><br><span class="line">cxt.lineTo(120, 200);</span><br><span class="line">cxt.lineTo(20, 100);</span><br><span class="line">cxt.lineJoin = &quot;miter&quot;; // 线条连接的样式。miter: 默认; bevel: 斜面; round: 圆角</span><br><span class="line">cxt.lineWidth = 10; //设置线条宽度</span><br><span class="line">cxt.closePath();</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="canvas-画一个菱形。"><a href="#canvas-画一个菱形。" class="headerlink" title="canvas 画一个菱形。"></a>canvas 画一个菱形。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">// 4、绘制棱形</span><br><span class="line">cxt.moveTo(20, 110); // 起点坐标 (x, y)</span><br><span class="line">cxt.lineTo(160, 50);</span><br><span class="line">cxt.lineTo(240, 150);</span><br><span class="line">cxt.lineTo(20, 240);</span><br><span class="line">cxt.lineTo(20, 110);</span><br><span class="line">cxt.closePath();</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-canvas-画一个圆"><a href="#使用-canvas-画一个圆" class="headerlink" title="使用 canvas 画一个圆"></a>使用 canvas 画一个圆</h4><p>绘制圆形必须使用，beginPath();<br>arc 绘制圆形，参数分别是，x 轴，y 轴坐标，r 半径,开始角度，结束角度，顺势转还是你是转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">cxt.beginPath();</span><br><span class="line">cxt.arc(200, 200, 100, 0, (360 * Math.PI) / 180, true);</span><br><span class="line"></span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>半圆</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">cxt.beginPath();</span><br><span class="line">cxt.arc(200, 200, 100, 0, (180 * Math.PI) / 180, false);</span><br><span class="line">cxt.closePath();</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="画一条弧线"><a href="#画一条弧线" class="headerlink" title="画一条弧线"></a>画一条弧线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">cxt.beginPath();</span><br><span class="line">cxt.arc(200, 200, 100, 0, (300 * Math.PI) / 180, true);</span><br><span class="line">// cxt.closePath();</span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="canvas-设置文字"><a href="#canvas-设置文字" class="headerlink" title="canvas 设置文字"></a>canvas 设置文字</h4><p>font 属性设置文字样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cxt.font = &#x27;font-style font-variant font-weight font-size/line-height font-family&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>strokeText 属性对文字进行描边，参数分别是，文字，x 轴坐标，y 轴坐标。<br>strokeStyle，设置描边文字颜色<br>fillText 属性，对文字进行填充，参数，文字，x 轴坐标，y 轴坐标。<br>fillStyle，设置填充文字颜色<br>textAlign 属性设置文本对齐，<br>textBaseline 属性设置文本垂直对齐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">cxt.fillStyle = &quot;pink&quot;;</span><br><span class="line">// cxt.setLineDash([10, 20]); //设置虚线</span><br><span class="line">cxt.font = &quot;60px Arial&quot;; // 将字号设置成 60px，方便观察</span><br><span class="line">cxt.strokeText(&quot;雷猴&quot;, 30, 90);</span><br><span class="line">cxt.textAlign = &quot;left&quot;;</span><br><span class="line">cxt.fillText(&quot;雷猴&quot;, 50, 200);</span><br><span class="line"></span><br><span class="line">cxt.stroke();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="canvas-设置图片"><a href="#canvas-设置图片" class="headerlink" title="canvas 设置图片"></a>canvas 设置图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">cxt.beginPath();</span><br><span class="line"></span><br><span class="line">let imgae = new Image();</span><br><span class="line">const image = new Image();</span><br><span class="line"></span><br><span class="line">// 2 引入图片</span><br><span class="line">image.src = &quot;https://s2.ax1x.com/2019/11/28/QPviTA.jpg&quot;;</span><br><span class="line"></span><br><span class="line">// 3 等待图片加载完成</span><br><span class="line">image.onload = () =&gt; &#123;</span><br><span class="line">  // 4 使用 drawImage() 方法渲染图片</span><br><span class="line">  cxt.drawImage(image, 0, 0, 400, 400);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>drawImage</strong>方法参数</p>
<ul>
<li>image: 图片对象</li>
<li>sx: 开始截取的横坐标</li>
<li>sy: 开始截取的纵坐标</li>
<li>sw: 截取的宽度</li>
<li>sh: 截取的高度</li>
<li>dx: 图片左上角的横坐标位置</li>
<li>dy: 图片左上角的纵坐标位置</li>
<li>dw: 图片宽度</li>
<li>dh: 图片高度</li>
</ul>
<p>//截取图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line"></span><br><span class="line">// 3、获取 canvas 上下文环境对象</span><br><span class="line">const cxt = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">cxt.beginPath();</span><br><span class="line"></span><br><span class="line">let imgae = new Image();</span><br><span class="line">const image = new Image();</span><br><span class="line"></span><br><span class="line">// 2 引入图片</span><br><span class="line">image.src = &quot;https://s2.ax1x.com/2019/11/28/QPviTA.jpg&quot;;</span><br><span class="line"></span><br><span class="line">// 3 等待图片加载完成</span><br><span class="line">image.onload = () =&gt; &#123;</span><br><span class="line">  // 4 使用 drawImage() 方法渲染图片</span><br><span class="line">cxt.drawImage(image, 200, 200, 100, 100, 0, 0, 400, 400);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>今天先初步认识一下，canvas 的使用。</p>
<p>canvas 的宽高，需要写在标签里面，或者使用 js 对宽高进行定义，css 设置宽高，会存在拉伸效果。</p>
<p>canvas 使用的是 w3c 坐标系，从上到下，是 y 轴，从左到右是 x 轴。和数学里面的坐标轴不同。</p>
<p>可以通过 canvas 去画一些简单的图形。</p>
<p>canvas 的 api 有。</p>
<ul>
<li>moveTo，代表 canvas 坐标的起点。</li>
<li>lineTo，代表下个坐标的位置。</li>
<li>stroke，把 canvas 的坐标给连接起来。</li>
<li>lineWidth，设置线的粗细，</li>
<li>strokeStyle，设置线的颜色</li>
<li>lineCap 线帽：默认: butt; 圆形: round; 方形: square</li>
<li>beginPath，当我们要设置多条线条样式的时候，必须用它。</li>
<li>strokeRect，可以对 canvas 周围进行描边。</li>
<li>strokeStyle，设置描边颜色。</li>
<li>fillRect，填充到整 canvas，</li>
<li>fillStyle，设置填充颜色</li>
<li>rect，设置矩形，但是必须通过 fill 来渲染。</li>
<li>fill，渲染矩形。</li>
<li>clearRect，清除 canvas 上的线段，矩形，或者整个画布。</li>
<li>closePath，解决多边形闭合问题。</li>
<li>arc，设置圆形。设置圆形必须先使用，beginPath</li>
<li>arcTo 画弧线。</li>
<li>font 设置文本</li>
<li>strokeText 对文本进行描边</li>
<li>strokeStyle，设置描边文本颜色</li>
<li>fillText，对文本进行填充</li>
<li>fillStyle，设置填充文本颜色。</li>
<li>获取文本长度，measureText</li>
<li>textAlign，文本对齐方式</li>
<li>textBaseline，设置文本垂直方式</li>
<li>drawImage，canvas 加载图片，截取图片。</li>
</ul>
<p>参考文章<a href="https://juejin.cn/post/7116784455561248775#heading-48">Canvas 从入门到劝朋友放弃（图解版）</a></p>
]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>vue配置内网环境</title>
    <url>/blogs/2023/02/21/vue%E9%85%8D%E7%BD%AE%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h4 id="前景提要"><a href="#前景提要" class="headerlink" title="前景提要"></a>前景提要</h4><p>我需要在内网配置 node npm yarn 顺便把 vue cli 安装上去。</p>
<p>遇到的问题，csdn 能够参考的文章不多。而且，极为拉胯，所以我就先写一篇。如何配置环境。</p>
<h5 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h5><ol>
<li>确保环境一致，比如内网的设备是 windows，那么我们准备一台有网的 windows。</li>
<li>准备一个 u 盘。</li>
</ol>
<p>确保内网的设备，没有任何开发环境，如果他已经被安装了 node，那么我们就把他给卸载掉。</p>
<h5 id="外网设备需要做的事情"><a href="#外网设备需要做的事情" class="headerlink" title="外网设备需要做的事情"></a>外网设备需要做的事情</h5><ul>
<li>node -v，查看外网设备的 node 版本，下载对应的 node 版本。（这个是要放到内网使用的 node）</li>
<li>下载内网所需要的环境</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">npm install -g webpack</span><br><span class="line">npm install -g webpack-cli</span><br><span class="line">npm install -g yarn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看外网设备的 npm 缓存包放到了那里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config get cache</span><br></pre></td></tr></table></figure>

<p>通用路径<br><code>C:\Users\lc19990308_157557654\AppData\Roaming\npm-cache</code></p>
<p>把 node 版本，和，npm-cache，放入 u 盘。</p>
<h4 id="内网设备要做的事情"><a href="#内网设备要做的事情" class="headerlink" title="内网设备要做的事情"></a>内网设备要做的事情</h4><p>插入 u 盘，安装 node。<br>查看 node 是否安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>把 npm-cache，放到 C:\Users\lc19990308_157557654\AppData\Roaming 目录下。</p>
<p>查看当前 npm 全局安装目录；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用npm root -g</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把 npm-cache 放到，npm root -g 获取到的路径下的 npm 文件下面。</p>
<p>最后命令行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --cache ./npm-cache --optional --cache-min 99999999999 --shrinkwrap false @vue/cli</span><br><span class="line">npm install --cache ./npm-cache --optional --cache-min 99999999999 --shrinkwrap false webpack</span><br><span class="line">npm install --cache ./npm-cache --optional --cache-min 99999999999 --shrinkwrap false webpack-cli</span><br><span class="line">npm install --cache ./npm-cache --optional --cache-min 99999999999 --shrinkwrap false yarn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，客户 vue 项目在内网 git 上，项目就不用新建，但是 fetch 下来之后无法启动，因为 git 上没有 node_modules，得，在外网机上新建一个 vue 项目，进行 install 操作之后，把生成的 node_modules 复制到内网，这才把内网 vue 项目启动起来。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读vue的风格指南</title>
    <url>/blogs/2023/02/03/%E9%98%85%E8%AF%BBvue%E7%9A%84%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h4 id="规则-A"><a href="#规则-A" class="headerlink" title="规则 A"></a>规则 A</h4><p><strong>vue 当中的组件名当为多个单词。</strong><br>例子</p>
<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order-list.vue</span><br><span class="line">order-list-item.vue</span><br><span class="line">OrderList.vue</span><br><span class="line">OrderListItem.vue</span><br></pre></td></tr></table></figure>

<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order.vue</span><br><span class="line">ORDER.vue</span><br></pre></td></tr></table></figure>

<p><strong>data 必须是一个函数</strong></p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    name:11,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        name:11</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>prop 定义尽量详细</strong></p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop:[&#x27;name&#x27;,&#x27;value&#x27;],</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop:&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:string,</span><br><span class="line">        default：&#x27;2&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更好的做法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop:&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:string,</span><br><span class="line">        default:&#x27;2&#x27;,</span><br><span class="line">        required: true,</span><br><span class="line">        validator: function (value) &#123;</span><br><span class="line">        return [</span><br><span class="line">            &#x27;syncing&#x27;,</span><br><span class="line">            &#x27;synced&#x27;,</span><br><span class="line">            &#x27;version-conflict&#x27;,</span><br><span class="line">            &#x27;error&#x27;</span><br><span class="line">        ].indexOf(value) !== -1</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>避免 v-for 与 v-if 用在一起</strong></p>
<p>v-for 的优先级要高于 v-for。<br>最好使用计算属性，返回过滤后的列表</p>
<p><strong>为组件样式设置私有的作用域</strong><br>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.box&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.box&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="规则-B"><a href="#规则-B" class="headerlink" title="规则 B"></a>规则 B</h4><p><strong>只要有拼接组件的构建系统，就把每个组件单独分成文件。</strong></p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue.component(&#x27;TodoList&#x27;);</span><br><span class="line">vue.component(&#x27;TodoListItem&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.js</span><br><span class="line">|- TodoItem.js</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoListItem.vue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>单文件组件文件名大小写</strong><br>要么，单文件组件的文件名，始终首字母大写，要么全部小写，下划线分割。</p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- todolistitem.vue</span><br><span class="line">|- todolistItem.vue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- todo-list-item.vue</span><br><span class="line">|- TodoListItem.vue</span><br></pre></td></tr></table></figure>

<p><strong>基础组件名</strong></p>
<p>应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V</p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- list.vue</span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- v-list.vue</span><br><span class="line">|- VList.vue</span><br><span class="line">|- BaseList.vue</span><br><span class="line">|- base-list.vue</span><br></pre></td></tr></table></figure>

<p><strong>紧耦合的组件名</strong><br>和父组件紧密耦合的组件，需要以父组件的前缀来命名。。</p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- ItemTodoList.vue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoListItem.vue</span><br><span class="line">|- todo-list.vue</span><br><span class="line">|- todo-list-item.vue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>组件名中的单词顺序</strong></p>
<p>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</p>
<p>bod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- ClearSearchInput.vue</span><br><span class="line">|- WarpSearchBOX.vue</span><br><span class="line">|- RunSearchButton.vue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- SearchInput.vue</span><br><span class="line">|- SearchInputButton.vue</span><br><span class="line">|- SearchButtonClaer.vue</span><br></pre></td></tr></table></figure>

<p><strong>自闭合组件</strong></p>
<p>在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</p>
<p>bod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//dom模版</span><br><span class="line"></span><br><span class="line">&lt;my-components /&gt;</span><br><span class="line"></span><br><span class="line">//单页面，字符串模版，jsx中</span><br><span class="line"></span><br><span class="line">&lt;my-components&gt;&lt;/my-components&gt;</span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//dom模版</span><br><span class="line">&lt;my-components&gt;&lt;my-components/&gt;</span><br><span class="line"></span><br><span class="line">//单页面，字符串模版，jsx中</span><br><span class="line">&lt;my-components/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>模板中的组件名大小写</strong></p>
<p>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。</p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在dom模版里</span><br><span class="line"></span><br><span class="line">&lt;mycomponetns&gt;&lt;/mycomponetns&gt;</span><br><span class="line"></span><br><span class="line">在单文件，jsx，字符串模版里面</span><br><span class="line"></span><br><span class="line">&lt;myComponent/&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-component /&gt;</span><br><span class="line">&lt;MyComponent /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>完整单词的组件名</strong><br>组件名应该倾向于完整单词而不是缩写。<br>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- UCheckbox.vue</span><br><span class="line">|- UCheckboxItem.vue</span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- UserCheckbox.vue</span><br><span class="line">|- UserCheckboxItem.vue</span><br></pre></td></tr></table></figure>

<p><strong>Prop 名大小写</strong><br>组件 prop 命名，小驼峰，在模版，jsx 里面，kebab-case 命名。<br>bod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop:&#123;</span><br><span class="line">    &#x27;greeting-text&#x27;:String</span><br><span class="line">&#125;</span><br><span class="line">&lt;WelcomeMessage greetingText=&quot;hi&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop:&#123;</span><br><span class="line">    greetingText:</span><br><span class="line">&#125;</span><br><span class="line">&lt;WelcomeMessage greetingText=&quot;hi&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>多个 attribute 的元素</strong></p>
<p>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&#x27;../../xxx/xxx&#x27; alit=&#x27;xxxx&#x27;&gt;</span><br><span class="line">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&#x27;../../xxx/xxx&#x27;</span><br><span class="line">    alit=&#x27;xxxx&#x27;</span><br><span class="line">&gt;</span><br><span class="line">&lt;MyComponent</span><br><span class="line">  foo=&quot;a&quot;</span><br><span class="line">  bar=&quot;b&quot;</span><br><span class="line">  baz=&quot;c&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>模板中简单的表达式</strong></p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;</span><br><span class="line">  fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class="line">    return word[0].toUpperCase() + word.slice(1)</span><br><span class="line">  &#125;).join(&#x27; &#x27;)</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; normalizedFullName &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂的表达式移到计算属性上面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  normalizedFullName: function () &#123;</span><br><span class="line">    return this.fullName.split(&#x27; &#x27;).map(function (word) &#123;</span><br><span class="line">      return word[0].toUpperCase() + word.slice(1)</span><br><span class="line">    &#125;).join(&#x27; &#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>简单的计算属性</strong></p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  price: function () &#123;</span><br><span class="line">    var basePrice = this.manufactureCost / (1 - this.profitMargin)</span><br><span class="line">    return (</span><br><span class="line">      basePrice -</span><br><span class="line">      basePrice * (this.discountPercent || 0)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  basePrice: function () &#123;</span><br><span class="line">    return this.manufactureCost / (1 - this.profitMargin)</span><br><span class="line">  &#125;,</span><br><span class="line">  discount: function () &#123;</span><br><span class="line">    return this.basePrice * (this.discountPercent || 0)</span><br><span class="line">  &#125;,</span><br><span class="line">  finalPrice: function () &#123;</span><br><span class="line">    return this.basePrice - this.discount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>带引号的 attribute 值</strong></p>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=text&gt;</span><br><span class="line">&lt;input :style=&#123;width:inputWidth+&#x27;px&#x27;&#125;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&#x27;text&#x27;&gt;</span><br><span class="line">&lt;input :style=&#x27;&#123;width:inputWidth+&#x27;px&#x27;&#125;&#x27;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>指令缩写</strong></p>
<p><strong>:</strong> 来表示:v-bind<br><strong>@</strong> 来表示:v-on<br><strong>#</strong> 来表示:v-slot</p>
<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&#x27;sumbit&#x27;</span><br><span class="line">       :width=&#x27;100px&#x27;&gt;</span><br><span class="line">提交&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>总结下来大概是。</p>
<p>prop 必须写全。<br>prop 的属性，必须要 buttonText。组件使用的时候 :button-text</p>
<p>组件必须是多个单词。<br>组件文件命名，要么遵守大驼峰，要么遵守短横线。<br>组件名在 dom 里面，要写闭合标签，在 jsx，模版里面，自闭合就行了。</p>
<p>组件在模版里面，要么短横线使用，要么大驼峰。<br>紧密耦合性组件，前缀必须带父组件。<br>模版里面不要放复杂表达式。<br>scoped 样式，不要对标签使用。要用 class，速度快。<br>组件 attribute，必须分行。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue风格指南</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转sass</title>
    <url>/blogs/2023/02/01/%E7%8E%A9%E8%BD%ACsass/</url>
    <content><![CDATA[<h4 id="作为一个前端工程师，对sass的使用。只停留在嵌套是不够的。这次好好阅读一下sass的使用。"><a href="#作为一个前端工程师，对sass的使用。只停留在嵌套是不够的。这次好好阅读一下sass的使用。" class="headerlink" title="作为一个前端工程师，对sass的使用。只停留在嵌套是不够的。这次好好阅读一下sass的使用。"></a>作为一个前端工程师，对sass的使用。只停留在嵌套是不够的。这次好好阅读一下sass的使用。</h4><h4 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h4><p>当我们使用css写的时候，要表明上下级关系，就需要用 <strong>.</strong> 父级选择,然后后面跟上子级选择器。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.app-container &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.app-container .box &#123;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">.app-container .box span &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用sass嵌套，不仅可以更加清楚的表明上下级关系，也方便不再疯狂写父级选择器名字了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.app-container &#123;</span><br><span class="line">  text-align: left;</span><br><span class="line">  .box &#123;</span><br><span class="line">    color: white;</span><br><span class="line">    span &#123;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="sass当中的父选择器"><a href="#sass当中的父选择器" class="headerlink" title="sass当中的父选择器"></a>sass当中的父选择器</h4><p>**&amp;**代表嵌套当中父级外层的父级选择器   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.app-container &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  background-color: orange;</span><br><span class="line">  .box &#123;</span><br><span class="line">    color: #000;</span><br><span class="line">    span &#123;</span><br><span class="line">      color: red;</span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        color: aqua;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;:hover .box &#123;</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="sass当中属性嵌套"><a href="#sass当中属性嵌套" class="headerlink" title="sass当中属性嵌套"></a>sass当中属性嵌套</h4><p>css当中使用font开头的属性，sass允许属性嵌套在命名空间里</p>
<p><strong>font</strong>只需要写一次就够了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  font: &#123;</span><br><span class="line">    size: 40px;</span><br><span class="line">    weight: 700;</span><br><span class="line">    font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="sass变量。"><a href="#sass变量。" class="headerlink" title="sass变量。"></a>sass变量。</h4><p>sass的变量，如果在选择器之外定义，那就是全局变量，如果在选择器内部定义的话，那么就是块级作用域。使用 <strong>!global</strong>,可以变成全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.app-container &#123;</span><br><span class="line">  $bg: #666 !global;</span><br><span class="line">  text-align: center;</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  background-color: $bg;</span><br><span class="line">  .box &#123;</span><br><span class="line">    color: $bg;</span><br><span class="line">    font: &#123;</span><br><span class="line">      size: 40px;</span><br><span class="line">      weight: 700;</span><br><span class="line">      font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于sass的变量数据类型</p>
<p>sass支持字符串，数字，布尔，null，list，map(map,类似于js当中的object);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$test: (</span><br><span class="line">  color: #666666,</span><br><span class="line">  bg: #000000,</span><br><span class="line">);</span><br><span class="line">.app-container &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  background-color: map-get($map: $test, $key: bg);</span><br><span class="line">  .box &#123;</span><br><span class="line">    color: map-get($map: $test, $key: color);</span><br><span class="line">    font: &#123;</span><br><span class="line">      size: 40px;</span><br><span class="line">      weight: 700;</span><br><span class="line">      font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="sass支持运算。"><a href="#sass支持运算。" class="headerlink" title="sass支持运算。"></a>sass支持运算。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size: 20px / 2px;</span><br></pre></td></tr></table></figure>


<h4 id="sass的插值语句。"><a href="#sass的插值语句。" class="headerlink" title="sass的插值语句。"></a>sass的插值语句。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$test: (</span><br><span class="line">  color: #666666,</span><br><span class="line">  bg: #000000,</span><br><span class="line">);</span><br><span class="line">$border: border;</span><br><span class="line">$box: box;</span><br><span class="line">.appContainer &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  background-color: map-get($map: $test, $key: bg);</span><br><span class="line">  .#&#123;$box&#125; &#123;</span><br><span class="line">    color: map-get($map: $test, $key: color);</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    #&#123;$border&#125;-bottom: 1px solid red;</span><br><span class="line">    font: &#123;</span><br><span class="line">      size: 20px / 2px;</span><br><span class="line">      weight: 700;</span><br><span class="line">      font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>#{}</strong>,插值语法的使用，可以作为选择器的名，也可以作为，属性名，虽然使用起来，不如直接使用对象方面。但是，他可以避免，sass对表达式进行运算，直接编译sass。</p>
<h4 id="sass中的，-default。"><a href="#sass中的，-default。" class="headerlink" title="sass中的，!default。"></a>sass中的，!default。</h4><p>如果一个变量已经被赋值了，就不能再去对他进行赋值。如果该变量，没有值，才能进行赋值。变量的值是null的话，视作没有被赋值。</p>
<h4 id="sass当中的，群组选择器嵌套。"><a href="#sass当中的，群组选择器嵌套。" class="headerlink" title="sass当中的，群组选择器嵌套。"></a>sass当中的，群组选择器嵌套。</h4><p>在css当中我们使用h1，h2，元素选择器的时候，会同时命中h1，h2元素。这个时候，我们如果使用sass当中的群组选择器，.btn.h1.h2{}的话，只会对btn class下面的h1，h2，元素起作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.appContainer .box &#123;</span><br><span class="line">  h1,</span><br><span class="line">  h2,</span><br><span class="line">  h3,</span><br><span class="line">  h4,</span><br><span class="line">  h5,</span><br><span class="line">  h6 &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="子组合选择器和同层组合选择器：-gt-、-和"><a href="#子组合选择器和同层组合选择器：-gt-、-和" class="headerlink" title="子组合选择器和同层组合选择器：&gt;、+和~;"></a>子组合选择器和同层组合选择器：&gt;、+和~;</h4><p><strong>&gt;</strong> sass子组合选择器。<br><strong>+</strong> sass兄弟选择器<br><strong>～</strong> sass除了自己的后代选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &gt; h1,</span><br><span class="line">h2,</span><br><span class="line">h3,</span><br><span class="line">h4,</span><br><span class="line">h5,</span><br><span class="line">h6 &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">.box + .box1 &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  border: 1px solid #000;</span><br><span class="line">&#125;</span><br><span class="line">p ~ p &#123;</span><br><span class="line">  border-top: 1px dashed #ccc;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="sass当中的混合器"><a href="#sass当中的混合器" class="headerlink" title="sass当中的混合器"></a>sass当中的混合器</h4><p><strong>mixin</strong>把一段重复的样式，给复用混入到我们的class当中。</p>
<p>混合器的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@mixin circle &#123;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  border: 1px solid #000;</span><br><span class="line">&#125;</span><br><span class="line">@mixin font &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: white;</span><br><span class="line">  line-height: 100px;</span><br><span class="line">  font: &#123;</span><br><span class="line">    size: 12px;</span><br><span class="line">    font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  @include circle;</span><br><span class="line">  background-color: red;</span><br><span class="line">  @include font;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>混合器不仅可以包含属性也可以包含父css的规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@mixin no-bullets &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">  li &#123;</span><br><span class="line">    list-style-image: none;</span><br><span class="line">    list-style-type: none;</span><br><span class="line">    margin-left: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  @include no-bullets;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sass混合器可以传参</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@mixin no-bullets($color, $width, $height) &#123;</span><br><span class="line">  color: $color;</span><br><span class="line">  width: $width;</span><br><span class="line">  height: $height;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">  @include no-bullets(blue, 200px, 200px);</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="sass当中的继承"><a href="#sass当中的继承" class="headerlink" title="sass当中的继承"></a>sass当中的继承</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line">ul &#123;</span><br><span class="line">  @extend .box;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>sass的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>css的公共样式与reset.css</title>
    <url>/blogs/2023/02/01/css%E7%9A%84%E5%85%AC%E5%85%B1%E6%A0%B7%E5%BC%8F%E4%B8%8Ereset.css/</url>
    <content><![CDATA[<h4 id="浏览器内核不同，导致标签在浏览器当中，渲染的不一样。"><a href="#浏览器内核不同，导致标签在浏览器当中，渲染的不一样。" class="headerlink" title="浏览器内核不同，导致标签在浏览器当中，渲染的不一样。"></a>浏览器内核不同，导致标签在浏览器当中，渲染的不一样。</h4><p>reset.css能够把 css默认的标签样式给分离出去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body,</span><br><span class="line">h1,</span><br><span class="line">h2,</span><br><span class="line">h3,</span><br><span class="line">h4,</span><br><span class="line">h5,</span><br><span class="line">h6,</span><br><span class="line">hr,</span><br><span class="line">p,</span><br><span class="line">blockquote,</span><br><span class="line">dl,</span><br><span class="line">dt,</span><br><span class="line">dd,</span><br><span class="line">ul,</span><br><span class="line">ol,</span><br><span class="line">li,</span><br><span class="line">button,</span><br><span class="line">input,</span><br><span class="line">textarea,</span><br><span class="line">th,</span><br><span class="line">td &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul,</span><br><span class="line">ol &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  background-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover,</span><br><span class="line">a:active &#123;</span><br><span class="line">  outline-width: 0;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table &#123;</span><br><span class="line">  border-collapse: collapse;</span><br><span class="line">  border-spacing: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr &#123;</span><br><span class="line">  border: 0;</span><br><span class="line">  height: 1px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img &#123;</span><br><span class="line">  border-style: none;</span><br><span class="line">  vertical-align: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img:not([src]) &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">svg:not(:root) &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">  -webkit-text-size-adjust: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input,</span><br><span class="line">textarea,</span><br><span class="line">button,</span><br><span class="line">a &#123;</span><br><span class="line">  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">article,</span><br><span class="line">aside,</span><br><span class="line">details,</span><br><span class="line">figcaption,</span><br><span class="line">figure,</span><br><span class="line">footer,</span><br><span class="line">header,</span><br><span class="line">main,</span><br><span class="line">menu,</span><br><span class="line">nav,</span><br><span class="line">section,</span><br><span class="line">summary &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">audio,</span><br><span class="line">canvas,</span><br><span class="line">progress,</span><br><span class="line">video &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">audio:not([controls]),</span><br><span class="line">video:not([controls]) &#123;</span><br><span class="line">  display: none;</span><br><span class="line">  height: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">progress &#123;</span><br><span class="line">  vertical-align: baseline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark &#123;</span><br><span class="line">  background-color: #ff0;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub,</span><br><span class="line">sup &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  font-size: 75%;</span><br><span class="line">  line-height: 0;</span><br><span class="line">  vertical-align: baseline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub &#123;</span><br><span class="line">  bottom: -0.25em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sup &#123;</span><br><span class="line">  top: -0.5em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button,</span><br><span class="line">input,</span><br><span class="line">select,</span><br><span class="line">textarea &#123;</span><br><span class="line">  font-size: 100%;</span><br><span class="line">  outline: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button,</span><br><span class="line">input &#123;</span><br><span class="line">  overflow: visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button,</span><br><span class="line">select &#123;</span><br><span class="line">  text-transform: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">textarea &#123;</span><br><span class="line">  overflow: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button,</span><br><span class="line">html [type=&quot;button&quot;],</span><br><span class="line">[type=&quot;reset&quot;],</span><br><span class="line">[type=&quot;submit&quot;] &#123;</span><br><span class="line">  -webkit-appearance: button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button::-moz-focus-inner,</span><br><span class="line">[type=&quot;button&quot;]::-moz-focus-inner,</span><br><span class="line">[type=&quot;reset&quot;]::-moz-focus-inner,</span><br><span class="line">[type=&quot;submit&quot;]::-moz-focus-inner &#123;</span><br><span class="line">  border-style: none;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button:-moz-focusring,</span><br><span class="line">[type=&quot;button&quot;]:-moz-focusring,</span><br><span class="line">[type=&quot;reset&quot;]:-moz-focusring,</span><br><span class="line">[type=&quot;submit&quot;]:-moz-focusring &#123;</span><br><span class="line">  outline: 1px dotted ButtonText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[type=&quot;checkbox&quot;],</span><br><span class="line">[type=&quot;radio&quot;] &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[type=&quot;number&quot;]::-webkit-inner-spin-button,</span><br><span class="line">[type=&quot;number&quot;]::-webkit-outer-spin-button &#123;</span><br><span class="line">  height: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[type=&quot;search&quot;] &#123;</span><br><span class="line">  -webkit-appearance: textfield;</span><br><span class="line">  outline-offset: -2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[type=&quot;search&quot;]::-webkit-search-cancel-button,</span><br><span class="line">[type=&quot;search&quot;]::-webkit-search-decoration &#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-input-placeholder &#123;</span><br><span class="line">  color: inherit;</span><br><span class="line">  opacity: 0.54;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-file-upload-button &#123;</span><br><span class="line">  -webkit-appearance: button;</span><br><span class="line">  font: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearFix:after &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  /*height: 0;*/</span><br><span class="line">  /*overflow: hidden;*/</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearFix &#123;</span><br><span class="line">  *zoom: 1; /*兼容低版本浏览器*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>common.css 使用通用原子类，方便复用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@charset &quot;UTF-8&quot;;</span><br><span class="line"></span><br><span class="line">/*间距*/</span><br><span class="line">.m-4 &#123;</span><br><span class="line">  margin: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-4 &#123;</span><br><span class="line">  padding-top: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-4 &#123;</span><br><span class="line">  padding-right: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-4 &#123;</span><br><span class="line">  padding-bottom: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-4 &#123;</span><br><span class="line">  padding-left: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-4 &#123;</span><br><span class="line">  padding: 0 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-4 &#123;</span><br><span class="line">  padding: 4px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-4 &#123;</span><br><span class="line">  padding: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-4 &#123;</span><br><span class="line">  padding-top: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-4 &#123;</span><br><span class="line">  padding-right: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-4 &#123;</span><br><span class="line">  padding-bottom: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-4 &#123;</span><br><span class="line">  padding-left: 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-4 &#123;</span><br><span class="line">  padding: 0 4px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-4 &#123;</span><br><span class="line">  padding: 4px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-5 &#123;</span><br><span class="line">  margin: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-5 &#123;</span><br><span class="line">  margin-top: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-5 &#123;</span><br><span class="line">  margin-right: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-5 &#123;</span><br><span class="line">  margin-bottom: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-5 &#123;</span><br><span class="line">  margin-left: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-5 &#123;</span><br><span class="line">  margin: 0 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-5 &#123;</span><br><span class="line">  margin: 5px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-5 &#123;</span><br><span class="line">  padding: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-5 &#123;</span><br><span class="line">  padding-top: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-5 &#123;</span><br><span class="line">  padding-right: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-5 &#123;</span><br><span class="line">  padding-bottom: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-5 &#123;</span><br><span class="line">  padding-left: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-5 &#123;</span><br><span class="line">  padding: 0 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-5 &#123;</span><br><span class="line">  padding: 5px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-6 &#123;</span><br><span class="line">  margin: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-6 &#123;</span><br><span class="line">  margin-top: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-6 &#123;</span><br><span class="line">  margin-right: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-6 &#123;</span><br><span class="line">  margin-bottom: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-6 &#123;</span><br><span class="line">  margin-left: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-6 &#123;</span><br><span class="line">  margin: 0 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-6 &#123;</span><br><span class="line">  margin: 6px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-6 &#123;</span><br><span class="line">  padding: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-6 &#123;</span><br><span class="line">  padding-top: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-6 &#123;</span><br><span class="line">  padding-right: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-6 &#123;</span><br><span class="line">  padding-bottom: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-6 &#123;</span><br><span class="line">  padding-left: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-6 &#123;</span><br><span class="line">  padding: 0 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-6 &#123;</span><br><span class="line">  padding: 6px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-7 &#123;</span><br><span class="line">  margin: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-7 &#123;</span><br><span class="line">  margin-top: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-7 &#123;</span><br><span class="line">  margin-right: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-7 &#123;</span><br><span class="line">  margin-bottom: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-7 &#123;</span><br><span class="line">  margin-left: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-7 &#123;</span><br><span class="line">  margin: 0 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-7 &#123;</span><br><span class="line">  margin: 7px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-7 &#123;</span><br><span class="line">  padding: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-7 &#123;</span><br><span class="line">  padding-top: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-7 &#123;</span><br><span class="line">  padding-right: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-7 &#123;</span><br><span class="line">  padding-bottom: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-7 &#123;</span><br><span class="line">  padding-left: 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-7 &#123;</span><br><span class="line">  padding: 0 7px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-7 &#123;</span><br><span class="line">  padding: 7px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-10 &#123;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-10 &#123;</span><br><span class="line">  margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-10 &#123;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-10 &#123;</span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-10 &#123;</span><br><span class="line">  margin-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-10 &#123;</span><br><span class="line">  margin: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-10 &#123;</span><br><span class="line">  margin: 10px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-10 &#123;</span><br><span class="line">  padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-10 &#123;</span><br><span class="line">  padding-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-10 &#123;</span><br><span class="line">  padding-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-10 &#123;</span><br><span class="line">  padding-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-10 &#123;</span><br><span class="line">  padding-left: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-10 &#123;</span><br><span class="line">  padding: 0 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-10 &#123;</span><br><span class="line">  padding: 10px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-12 &#123;</span><br><span class="line">  margin: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-12 &#123;</span><br><span class="line">  margin-top: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-12 &#123;</span><br><span class="line">  margin-right: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-12 &#123;</span><br><span class="line">  margin-bottom: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-12 &#123;</span><br><span class="line">  margin-left: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-12 &#123;</span><br><span class="line">  margin: 0 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-12 &#123;</span><br><span class="line">  margin: 12px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-12 &#123;</span><br><span class="line">  padding: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-12 &#123;</span><br><span class="line">  padding-top: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-12 &#123;</span><br><span class="line">  padding-right: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-12 &#123;</span><br><span class="line">  padding-bottom: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-12 &#123;</span><br><span class="line">  padding-left: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-12 &#123;</span><br><span class="line">  padding: 0 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-12 &#123;</span><br><span class="line">  padding: 12px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-14 &#123;</span><br><span class="line">  margin: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-14 &#123;</span><br><span class="line">  margin-top: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-14 &#123;</span><br><span class="line">  margin-right: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-14 &#123;</span><br><span class="line">  margin-bottom: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-14 &#123;</span><br><span class="line">  margin-left: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-14 &#123;</span><br><span class="line">  margin: 0 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-14 &#123;</span><br><span class="line">  margin: 14px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-14 &#123;</span><br><span class="line">  padding: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-14 &#123;</span><br><span class="line">  padding-top: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-14 &#123;</span><br><span class="line">  padding-right: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-14 &#123;</span><br><span class="line">  padding-bottom: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-14 &#123;</span><br><span class="line">  padding-left: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-14 &#123;</span><br><span class="line">  padding: 0 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-14 &#123;</span><br><span class="line">  padding: 14px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-16 &#123;</span><br><span class="line">  margin: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-16 &#123;</span><br><span class="line">  margin-top: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-16 &#123;</span><br><span class="line">  margin-right: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-16 &#123;</span><br><span class="line">  margin-bottom: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-16 &#123;</span><br><span class="line">  margin-left: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-16 &#123;</span><br><span class="line">  margin: 0 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-16 &#123;</span><br><span class="line">  margin: 16px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-16 &#123;</span><br><span class="line">  padding: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-16 &#123;</span><br><span class="line">  padding-top: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-16 &#123;</span><br><span class="line">  padding-right: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-16 &#123;</span><br><span class="line">  padding-bottom: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-16 &#123;</span><br><span class="line">  padding-left: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-16 &#123;</span><br><span class="line">  padding: 0 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-16 &#123;</span><br><span class="line">  padding: 16px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-18 &#123;</span><br><span class="line">  margin: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-18 &#123;</span><br><span class="line">  margin-top: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-18 &#123;</span><br><span class="line">  margin-right: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-18 &#123;</span><br><span class="line">  margin-bottom: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-18 &#123;</span><br><span class="line">  margin-left: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-18 &#123;</span><br><span class="line">  margin: 0 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-18 &#123;</span><br><span class="line">  margin: 18px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-18 &#123;</span><br><span class="line">  padding: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-18 &#123;</span><br><span class="line">  padding-top: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-18 &#123;</span><br><span class="line">  padding-right: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-18 &#123;</span><br><span class="line">  padding-bottom: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-18 &#123;</span><br><span class="line">  padding-left: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-18 &#123;</span><br><span class="line">  padding: 0 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-18 &#123;</span><br><span class="line">  padding: 18px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-20 &#123;</span><br><span class="line">  margin: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-20 &#123;</span><br><span class="line">  margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-20 &#123;</span><br><span class="line">  margin-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-20 &#123;</span><br><span class="line">  margin-bottom: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-20 &#123;</span><br><span class="line">  margin-left: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-20 &#123;</span><br><span class="line">  margin: 0 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-20 &#123;</span><br><span class="line">  margin: 20px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-20 &#123;</span><br><span class="line">  padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-20 &#123;</span><br><span class="line">  padding-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-20 &#123;</span><br><span class="line">  padding-right: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-20 &#123;</span><br><span class="line">  padding-bottom: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-20 &#123;</span><br><span class="line">  padding-left: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-20 &#123;</span><br><span class="line">  padding: 0 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-20 &#123;</span><br><span class="line">  padding: 20px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-22 &#123;</span><br><span class="line">  margin: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-22 &#123;</span><br><span class="line">  margin-top: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-22 &#123;</span><br><span class="line">  margin-right: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-22 &#123;</span><br><span class="line">  margin-bottom: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-22 &#123;</span><br><span class="line">  margin-left: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-22 &#123;</span><br><span class="line">  margin: 0 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-22 &#123;</span><br><span class="line">  margin: 22px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-22 &#123;</span><br><span class="line">  padding: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-22 &#123;</span><br><span class="line">  padding-top: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-22 &#123;</span><br><span class="line">  padding-right: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-22 &#123;</span><br><span class="line">  padding-bottom: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-22 &#123;</span><br><span class="line">  padding-left: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-22 &#123;</span><br><span class="line">  padding: 22px 0px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-22 &#123;</span><br><span class="line">  padding: 22px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-24 &#123;</span><br><span class="line">  margin: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-24 &#123;</span><br><span class="line">  margin-top: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-24 &#123;</span><br><span class="line">  margin-right: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-24 &#123;</span><br><span class="line">  margin-bottom: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-24 &#123;</span><br><span class="line">  margin-left: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-24 &#123;</span><br><span class="line">  margin: 0 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-24 &#123;</span><br><span class="line">  margin: 24px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-24 &#123;</span><br><span class="line">  padding: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-24 &#123;</span><br><span class="line">  padding-top: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-24 &#123;</span><br><span class="line">  padding-right: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-24 &#123;</span><br><span class="line">  padding-bottom: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-24 &#123;</span><br><span class="line">  padding-left: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-24 &#123;</span><br><span class="line">  padding: 0 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-24 &#123;</span><br><span class="line">  padding: 24px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-26 &#123;</span><br><span class="line">  margin: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-26 &#123;</span><br><span class="line">  margin-top: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-26 &#123;</span><br><span class="line">  margin-right: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-26 &#123;</span><br><span class="line">  margin-bottom: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-26 &#123;</span><br><span class="line">  margin-left: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-26 &#123;</span><br><span class="line">  margin: 0 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-26 &#123;</span><br><span class="line">  margin: 26px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-26 &#123;</span><br><span class="line">  padding: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-26 &#123;</span><br><span class="line">  padding-top: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-26 &#123;</span><br><span class="line">  padding-right: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-26 &#123;</span><br><span class="line">  padding-bottom: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-26 &#123;</span><br><span class="line">  padding-left: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-26 &#123;</span><br><span class="line">  padding: 0 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-26 &#123;</span><br><span class="line">  padding: 26px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-28 &#123;</span><br><span class="line">  margin: 28px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-28 &#123;</span><br><span class="line">  margin-top: 28px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-28 &#123;</span><br><span class="line">  margin-right: 28px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-28 &#123;</span><br><span class="line">  margin-bottom: 28px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-28 &#123;</span><br><span class="line">  margin-left: 28px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-28 &#123;</span><br><span class="line">  margin: 0 28px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-28 &#123;</span><br><span class="line">  margin: 28px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-30 &#123;</span><br><span class="line">  padding: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-30 &#123;</span><br><span class="line">  padding-top: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-30 &#123;</span><br><span class="line">  padding-right: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-30 &#123;</span><br><span class="line">  padding-bottom: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-30 &#123;</span><br><span class="line">  padding-left: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-30 &#123;</span><br><span class="line">  padding: 0 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-30 &#123;</span><br><span class="line">  padding: 30px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-30 &#123;</span><br><span class="line">  margin: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-t-30 &#123;</span><br><span class="line">  margin-top: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-r-30 &#123;</span><br><span class="line">  margin-right: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-b-30 &#123;</span><br><span class="line">  margin-bottom: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-l-30 &#123;</span><br><span class="line">  margin-left: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-lr-30 &#123;</span><br><span class="line">  margin: 0 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.m-tb-30 &#123;</span><br><span class="line">  margin: 30px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-30 &#123;</span><br><span class="line">  padding: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-t-30 &#123;</span><br><span class="line">  padding-top: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-r-30 &#123;</span><br><span class="line">  padding-right: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-b-30 &#123;</span><br><span class="line">  padding-bottom: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-l-30 &#123;</span><br><span class="line">  padding-left: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-lr-30 &#123;</span><br><span class="line">  padding: 0 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.p-tb-30 &#123;</span><br><span class="line">  padding: 30px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*字体大小*/</span><br><span class="line">.font-10 &#123;</span><br><span class="line">  font-size: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-12 &#123;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-14 &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-16 &#123;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-18 &#123;</span><br><span class="line">  font-size: 18px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-20 &#123;</span><br><span class="line">  font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-22 &#123;</span><br><span class="line">  font-size: 22px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-24 &#123;</span><br><span class="line">  font-size: 24px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-26 &#123;</span><br><span class="line">  font-size: 26px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-28 &#123;</span><br><span class="line">  font-size: 28px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-30 &#123;</span><br><span class="line">  font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-32 &#123;</span><br><span class="line">  font-size: 32px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-34 &#123;</span><br><span class="line">  font-size: 34px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-36 &#123;</span><br><span class="line">  font-size: 36px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-38 &#123;</span><br><span class="line">  font-size: 38px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-40 &#123;</span><br><span class="line">  font-size: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-42 &#123;</span><br><span class="line">  font-size: 42px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-44 &#123;</span><br><span class="line">  font-size: 44px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-46 &#123;</span><br><span class="line">  font-size: 46px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-48 &#123;</span><br><span class="line">  font-size: 46px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-50 &#123;</span><br><span class="line">  font-size: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-52 &#123;</span><br><span class="line">  font-size: 52px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-54 &#123;</span><br><span class="line">  font-size: 54px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-56 &#123;</span><br><span class="line">  font-size: 56px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-42 &#123;</span><br><span class="line">  font-size: 42px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-58 &#123;</span><br><span class="line">  font-size: 58px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-60 &#123;</span><br><span class="line">  font-size: 60px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-62 &#123;</span><br><span class="line">  font-size: 62px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-64 &#123;</span><br><span class="line">  font-size: 64px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-66 &#123;</span><br><span class="line">  font-size: 66px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*字体重量*/</span><br><span class="line">.font-weight-100 &#123;</span><br><span class="line">  font-weight: 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-weight-200 &#123;</span><br><span class="line">  font-weight: 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-weight-300 &#123;</span><br><span class="line">  font-weight: 300;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-weight-400 &#123;</span><br><span class="line">  font-weight: 400;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-weight-500 &#123;</span><br><span class="line">  font-weight: 500;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-weight-600 &#123;</span><br><span class="line">  font-weight: 600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-weight-700 &#123;</span><br><span class="line">  font-weight: 700;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**文字对齐方式**/</span><br><span class="line">.font-left &#123;</span><br><span class="line">  text-align: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-right &#123;</span><br><span class="line">  text-align: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.font-center &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*布局*/</span><br><span class="line">.flex &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-1 &#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-2 &#123;</span><br><span class="line">  flex: 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-3 &#123;</span><br><span class="line">  flex: 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-4 &#123;</span><br><span class="line">  flex: 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-5 &#123;</span><br><span class="line">  flex: 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-6 &#123;</span><br><span class="line">  flex: 6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-warp &#123;</span><br><span class="line">  flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-nowarp &#123;</span><br><span class="line">  flex-wrap: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.align-center &#123;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.align-left &#123;</span><br><span class="line">  align-items: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.align-right &#123;</span><br><span class="line">  align-items: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.align-content-center &#123;</span><br><span class="line">  align-content: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.align-content-space-around &#123;</span><br><span class="line">  align-content: space-around;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.align-content-space-between &#123;</span><br><span class="line">  align-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.align-center-left &#123;</span><br><span class="line">  align-content: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.align-center-right &#123;</span><br><span class="line">  align-content: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.justify-left &#123;</span><br><span class="line">  justify-content: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.justify-right &#123;</span><br><span class="line">  justify-content: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.justify-center &#123;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.justify-between &#123;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.justify-space-around &#123;</span><br><span class="line">  justify-content: space-around;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.justify-items-center &#123;</span><br><span class="line">  justify-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.justify-items-left &#123;</span><br><span class="line">  justify-items: flex-start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.justify-items-right &#123;</span><br><span class="line">  justify-items: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-column &#123;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-column-reverse &#123;</span><br><span class="line">  flex-direction: column-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*超出省略号单行*/</span><br><span class="line">.ellipsis &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*超出省略号多行*/</span><br><span class="line">.ellipsis2 &#123;</span><br><span class="line">  display: -webkit-box;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  -webkit-line-clamp: 3;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">/*隐藏与显示*/</span><br><span class="line">.hide &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line">.show &#123;</span><br><span class="line">  display: show;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*人民币符号*/</span><br><span class="line">.text-price::before &#123;</span><br><span class="line">  content: &quot;¥&quot;;</span><br><span class="line">  font-size: 80%;</span><br><span class="line">  margin-right: 4upx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text-Abc &#123;</span><br><span class="line">  text-transform: Capitalize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text-ABC &#123;</span><br><span class="line">  text-transform: Uppercase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.text-abc &#123;</span><br><span class="line">  text-transform: Lowercase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>移动端当中的reset.css。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* m-reset.css v1.0.3 | MIT License | https://gitee.com/bugeiguojiatuohoutui/m-reset.css */</span><br><span class="line"></span><br><span class="line">/* 引用 minireset.css v0.0.6 | MIT License | github.com/jgthms/minireset.css */html,body,p,ol,ul,li,dl,dt,dd,blockquote,figure,fieldset,legend,textarea,pre,iframe,hr,h1,h2,h3,h4,h5,h6&#123;margin:0;padding:0&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;font-weight:normal&#125;ul&#123;list-style:none&#125;button,input,select&#123;margin:0&#125;html&#123;box-sizing:border-box&#125;*,*::before,*::after&#123;box-sizing:inherit&#125;img,video&#123;height:auto;max-width:100%&#125;iframe&#123;border:0&#125;table&#123;border-collapse:collapse;border-spacing:0&#125;td,th&#123;padding:0&#125;</span><br><span class="line"></span><br><span class="line">/* 上面的开源项目全部用 border-box，这个看习惯是否更改，因为有的设计稿给的时候就单独标注了 padding width，默认样式更方便 */</span><br><span class="line">html &#123;box-sizing: content-box;&#125;</span><br><span class="line"></span><br><span class="line">/* 上面的开源项目没写 ol，个人用的挺多的 */</span><br><span class="line">ol &#123;list-style: none&#125;</span><br><span class="line"></span><br><span class="line">/* 需要时拷贝到点击元素上，这个属性不能继承，这里只是备注 */</span><br><span class="line">html &#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;</span><br><span class="line"></span><br><span class="line">/* 处理刘海屏，看需求是否使用</span><br><span class="line">body &#123;</span><br><span class="line">  padding-bottom: constant(safe-area-inset-bottom);</span><br><span class="line">  padding-bottom: env(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">constant：小于IOS11.2版本生效</span><br><span class="line">env：大于IOS11.2版本生效</span><br><span class="line">还需要配合 &lt;meta name=&quot;viewport&quot; content=&quot;viewport-fit=cover&gt;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/* iOS 下修改字号导致页面文本溢出问题 和 通用字体字号 */</span><br><span class="line">body &#123;-webkit-text-size-adjust:100% !important; -webkit-font-smoothing: antialiased; font-size:14px; line-height: 1.5;&#125;</span><br><span class="line"></span><br><span class="line">/* 去除 iOS 默认 input 样式 */</span><br><span class="line">input[type=&quot;submit&quot;], input[type=&quot;reset&quot;], input[type=&quot;button&quot;], input:focus, button:focus, select:focus, textarea:focus &#123;outline: none;&#125;</span><br><span class="line">input &#123;-webkit-appearance: none; resize: none; border-radius: 0;&#125;</span><br><span class="line"></span><br><span class="line">/* 1px 边框问题，关键属性已完成，只需添加边框颜色、圆角弧度属性即可 */</span><br><span class="line">/* 推荐 mixins 方式传参 */</span><br><span class="line">.border-top-1px,</span><br><span class="line">.border-right-1px,</span><br><span class="line">.border-bottom-1px,</span><br><span class="line">.border-left-1px,</span><br><span class="line">.border-all &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.border-top-1px::before,</span><br><span class="line">.border-right-1px::before,</span><br><span class="line">.border-bottom-1px::before,</span><br><span class="line">.border-left-1px::before,</span><br><span class="line">.border-all::before &#123;</span><br><span class="line">  content: &#x27;&#x27;;</span><br><span class="line">  display: block;</span><br><span class="line">  position: absolute;</span><br><span class="line">  transform-origin: 0 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.border-top-1px::before &#123;</span><br><span class="line">  border-top: 1px solid #000;</span><br><span class="line">  left: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  transform-origin: 0 top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.border-right-1px::before &#123;</span><br><span class="line">  border-right: 1px solid #000;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  height: 100%;</span><br><span class="line">  transform-origin: right 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.border-bottom-1px::before &#123;</span><br><span class="line">  border-bottom: 1px solid #000;</span><br><span class="line">  left: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  transform-origin: 0 bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.border-left-1px::before &#123;</span><br><span class="line">  border-left: 1px solid #000;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  height: 100%;</span><br><span class="line">  transform-origin: left 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.border-all::before &#123;</span><br><span class="line">  border: 1px solid #000;</span><br><span class="line">  border-radius: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (min-resolution: 2dppx) &#123;</span><br><span class="line"></span><br><span class="line">  .border-top-1px::before,</span><br><span class="line">  .border-right-1px::before,</span><br><span class="line">  .border-bottom-1px::before,</span><br><span class="line">  .border-left-1px::before,</span><br><span class="line">  .border-all::before &#123;</span><br><span class="line">    transform: scale(.5) translateZ(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .border-top-1px::before,</span><br><span class="line">  .border-bottom-1px::before,</span><br><span class="line">  .border-all::before &#123;</span><br><span class="line">    width: 200%;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .border-right-1px::before,</span><br><span class="line">  .border-left-1px::before,</span><br><span class="line">  .border-all::before &#123;</span><br><span class="line">    height: 200%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@media (min-resolution: 3dppx) &#123;</span><br><span class="line"></span><br><span class="line">  .border-top-1px::before,</span><br><span class="line">  .border-right-1px::before,</span><br><span class="line">  .border-bottom-1px::before,</span><br><span class="line">  .border-left-1px::before,</span><br><span class="line">  .border-all::before &#123;</span><br><span class="line">    transform: scale(.3333) translateZ(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .border-top-1px::before,</span><br><span class="line">  .border-bottom-1px::before,</span><br><span class="line">  .border-all::before &#123;</span><br><span class="line">    width: 300%;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .border-right-1px::before,</span><br><span class="line">  .border-left-1px::before,</span><br><span class="line">  .border-all::before &#123;</span><br><span class="line">    height: 300%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 此外还可以设置通用字体颜色，链接颜色等，根据需求增减 */</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css公共样式</tag>
      </tags>
  </entry>
  <entry>
    <title>css BEM命名规范</title>
    <url>/blogs/2023/02/01/css%20BEM%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h4 id="为什么要使用BEM命名规范"><a href="#为什么要使用BEM命名规范" class="headerlink" title="为什么要使用BEM命名规范"></a>为什么要使用BEM命名规范</h4><p>当我们写css，参与到大项目的时候，需要一种统一的方式来书写css。BEM（block element modifier）是一种命名规范，使用这种方式让css代码更容易进行维护。</p>
<p>标准的BEM写法是，.block-name__element-name–modifier-name。</p>
<h4 id="和–，-，都代表什么意思。。"><a href="#和–，-，都代表什么意思。。" class="headerlink" title="__和–，-，都代表什么意思。。"></a>__和–，-，都代表什么意思。。</h4><p><strong>–</strong> 符号，需要连接的是，modifier。</p>
<p><strong>__</strong> 符号，需要连接的是，element。<br><strong>-</strong> 符号，需要连接的是，block-name，elenemt-name，modifier-name。</p>
<h4 id="使用BEM命名class的例子。"><a href="#使用BEM命名class的例子。" class="headerlink" title="使用BEM命名class的例子。"></a>使用BEM命名class的例子。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;new-list&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;new-list__item new-list__item--active&quot;&gt;这是一段新闻呀&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;new-list__item&quot;&gt;这是一段新闻呀&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;new-list__item&quot;&gt;这是一段新闻呀&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;new-list__item&quot;&gt;这是一段新闻呀&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;new-list__item&quot;&gt;这是一段新闻呀&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>new-list是block<br>new-list__item,是element，<br>new-list__item–active,是modifier</p>
<h4 id="常用的Class命名"><a href="#常用的Class命名" class="headerlink" title="常用的Class命名"></a>常用的Class命名</h4><h5 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h5><p>容器: container<br>页头：header<br>内容：content/container<br>页面主体：main<br>页尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体布局宽度：wrapper<br>左右中：left right center</p>
<h5 id="导航栏相关"><a href="#导航栏相关" class="headerlink" title="导航栏相关"></a>导航栏相关</h5><p>导航：nav<br>主导航：mainnav<br>子导航：subnav<br>顶导航：topnav<br>边导航：sidebar<br>左导航：leftsidebar<br>右导航：rightsidebar<br>菜单：menu<br>子菜单：submenu<br>标题: heading<br>子标题：subHeading<br>摘要: summary</p>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>标志：logo<br>广告：banner<br>登陆：login<br>登录条：loginbar<br>注册：regsiter<br>搜索：search<br>功能区：shop<br>标题：title<br>加入：joinus<br>状态：status<br>按钮：btn<br>滚动：scroll<br>标签页：tab<br>文章列表：list<br>提示信息：message<br>当前的: current<br>小技巧：tips<br>图标: icon<br>注释：note<br>指南：guild<br>服务：service<br>热点：hot<br>新闻：news<br>下载：download<br>投票：vote<br>合作伙伴：partner<br>友情链接：friendlink<br>版权：copyright</p>
<h5 id="样式文件命名"><a href="#样式文件命名" class="headerlink" title="样式文件命名"></a>样式文件命名</h5><p>主要的 main.css<br>模块 module.css<br>基本共用 base.css<br>布局 layout.css<br>主题 themes.css<br>专栏 columns.css<br>文字 font.css<br>表单 forms.css<br>补丁 mend.css<br>打印 print.css</p>
<h4 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h4><p><a href="https://blog.csdn.net/m0_37585915/article/details/79570571">简单总结前端CSS常用语义类名</a><br><a href="https://juejin.cn/post/6844903601127555085">BEM命名规范入门及常用CSS class 命名</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>BEM命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title>学习vue router</title>
    <url>/blogs/2022/12/26/%E5%AD%A6%E4%B9%A0vue-router/</url>
    <content><![CDATA[<p>一直都没老老实实的看过 vue router 的文档。</p>
<p>今天详细的过一遍 vue router 文档。</p>
<h4 id="router-当中的动态路由匹配"><a href="#router-当中的动态路由匹配" class="headerlink" title="router 当中的动态路由匹配"></a>router 当中的动态路由匹配</h4><p>假设我们有一个页面，需要传递参数。我们看一下动态路由如何进行匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView/:id&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/UserView.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;app-container&quot;&gt;</span><br><span class="line">  &lt;div&gt;user页面获取到的id:&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>使用 vue router 动态路由匹配的话，接收参数必须使用，<strong>route.params</strong>来接收参数。</p>
<p>vue 使用 $router.push(),跳转同一个页面会导致报错。</p>
<p>在 router 文件夹下面的 index.js 文件，添加一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const originalPush = VueRouter.prototype.push;</span><br><span class="line">VueRouter.prototype.push = function push(location) &#123;</span><br><span class="line">  return originalPush.call(this, location).catch((err) =&gt; err);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>跳转同一个页面就不会报错了。</p>
<p>捕捉 router 没有，匹配到 404 Not found 路由。</p>
<p>使用 router path 的通配符，可以匹配任何路径。</p>
<p>当然在这里之前，我们首先得有一个，所谓的 404 页面。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/404Page&quot;,</span><br><span class="line">  name: &quot;404&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/404Page.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>path 使用通配符，匹配没有被匹配到的路径，使用 redirect，把它给重定向到，/404Page 页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 会匹配所有路径</span><br><span class="line">  path: &quot;*&quot;,</span><br><span class="line">  redirect: &quot;/404Page&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="router-嵌套路由。"><a href="#router-嵌套路由。" class="headerlink" title="router 嵌套路由。"></a>router 嵌套路由。</h4><p>router-view，会渲染匹配到组件。一个渲染组件同样也可以包涵自己的 router-view 嵌套。。</p>
<p>路由嵌套，需要多个 router-view。顶层的 router-view 渲染出的是顶层，高级路由所匹配到的组件。高级路由所匹配到的组件，内部加载 router-view，渲染，router 嵌套所匹配到的组件。。</p>
<p>这个概念很绕。</p>
<p>假设以，A 组件，需要嵌套 B,C 组件。顶层的 router-view 渲染出的仅仅是，A 组件。A 组件的内部的 router-view，用来渲染，B,C 组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/user/UserView.vue&quot;),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;NavbarView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;FooterView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/FooterView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还是，A 组件嵌套 B,C 组件。B.C 组件。假设，我们跳转/A/B,再跳转到/A/C，那么，B,C 组件的生命周期是完整的。</p>
<p>可是，A 组件已然被复用了，不会在重复的执行生命周期了。。</p>
<p>那么，A 组件的路由，参数发生变动，A 组件的，created 生命周期，只会加载一次。如何拿到变动的，参数呢？</p>
<p>答案，是使用 watch 监听。router 的变动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  $route(to) &#123;</span><br><span class="line">    this.id = to.params.id;</span><br><span class="line">    // 对路由变化作出响应...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们跳转/A 的路由，A 组件内部的 router-view，没有匹配到组件，就不会渲染。。</p>
<p>如果跳转/A，A 组件内部的，router-view，我们想要渲染的话。咱们可以提高一个空的子路由。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">children: [</span><br><span class="line">     &#123;</span><br><span class="line">       path: &quot;&quot;,</span><br><span class="line">       component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       path: &quot;NavbarView&quot;,</span><br><span class="line">       component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       path: &quot;FooterView&quot;,</span><br><span class="line">       component: () =&gt; import(&quot;../views/user/FooterView.vue&quot;),</span><br><span class="line">     &#125;,</span><br><span class="line">   ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者，也可以，进行重定向。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView/:id&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  redirect: &quot;/UserView/:id/NavbarView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/user/UserView.vue&quot;),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;NavbarView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;FooterView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/FooterView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关于-vue-router-的命名路由。"><a href="#关于-vue-router-的命名路由。" class="headerlink" title="关于 vue router 的命名路由。"></a>关于 vue router 的命名路由。</h4><p>这里做个假设，假设，我要跳一个嵌套路由。是一个二级嵌套。。</p>
<p>那么，肯定是这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$router.push(&#123;path:&#x27;/a/b&#x27;&#125;)</span><br><span class="line">或者 &lt;router-link :to=&#123;path:&#x27;/a/b&#x27;&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>命名路由，就是给路由起一个名字。</p>
<p>例子如下，，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView/:id&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  redirect: &quot;/UserView/:id/NavbarView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/user/UserView.vue&quot;),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &quot;UserView-NavbarView&quot;,</span><br><span class="line">      path: &quot;NavbarView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/NavbarView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;FooterView&quot;,</span><br><span class="line">      component: () =&gt; import(&quot;../views/user/FooterView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">    &lt;router-link :to=&quot;&#123; name: &#x27;UserView-NavbarView&#x27;, params: &#123; id: &#x27;11&#x27; &#125; &#125;&quot;</span><br><span class="line">      &gt;UserView/NavbarView&lt;/router-link</span><br><span class="line">    &gt;|</span><br></pre></td></tr></table></figure>

<p>router-link，使用 name 进行跳转，要简便多了。。</p>
<p>当然，缺陷就是，router，是一个匹配的关系。所以！！！<br>name 是唯一的。就像 id 一样。。不要乱跳！</p>
<p>params 传参的缺点就是，需要用动态路由。参数在路由上面定义。route.params 接收。。</p>
<p>query 接收参数，就是一段查询字符串。。</p>
<h4 id="关于命名视图"><a href="#关于命名视图" class="headerlink" title="关于命名视图."></a>关于命名视图.</h4><p>在 app.vue 里面的<router-view />是一个未命名的视图。router 只要匹配到了，就会把组件渲染到这里。。</p>
<p>可是，我们要完成一些复杂的布局。</p>
<p>例子，在 app.vue 里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;el-container&gt;</span><br><span class="line">    &lt;el-aside width=&quot;200px&quot;&gt;</span><br><span class="line">      &lt;transition name=&quot;slide&quot;&gt;</span><br><span class="line">        &lt;router-view name=&quot;aside&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/transition&gt;</span><br><span class="line">    &lt;/el-aside&gt;</span><br><span class="line">    &lt;el-main&gt;</span><br><span class="line">      &lt;transition name=&quot;slide&quot;&gt;</span><br><span class="line">        &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/transition&gt;</span><br><span class="line">    &lt;/el-main&gt;</span><br><span class="line">  &lt;/el-container&gt;</span><br><span class="line">  &lt;transition name=&quot;slide&quot;&gt;</span><br><span class="line">    &lt;router-view /&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们对 router-view 的 name 进行了命名。</p>
<p>因为我们要在同级嵌套 视图。</p>
<p>router 挂载组件的时候。就不能使用，component 了，需要使用 components。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/LayoutIndex&quot;,</span><br><span class="line">  name: &quot;LayoutIndex&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    default: () =&gt; import(&quot;../layout/LayoutIndex.vue&quot;),</span><br><span class="line">    main: () =&gt; import(&quot;../layout/MainView.vue&quot;),</span><br><span class="line">    aside: () =&gt; import(&quot;../layout/AsideView.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们使用 router 跳转到 LayoutIndex 页面时，命名路由会得到匹配。。</p>
<p>那么嵌套路由如果是嵌套路由命名视图呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/UserView&quot;,</span><br><span class="line">  name: &quot;UserView&quot;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/UserView.vue&quot;),</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &quot;DefaultView&quot;,</span><br><span class="line">      name: &quot;DefaultView&quot;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        default: () =&gt; import(&quot;../views/user/DefaultView.vue&quot;),</span><br><span class="line">        header: () =&gt; import(&quot;../views/user/HeaderView.vue&quot;),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>嵌套命名视图。就是把命名视图藏入，要嵌套的页面里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--&lt;router-view /&gt;</span><br><span class="line">    &lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt; --&gt;</span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">      &lt;el-aside width=&quot;200px&quot;&gt;</span><br><span class="line">        &lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;, &#x27;3&#x27;]&quot;&gt;</span><br><span class="line">          &lt;el-submenu index=&quot;1&quot;&gt;</span><br><span class="line">            &lt;template slot=&quot;title&quot;</span><br><span class="line">              &gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;导航一&lt;/template</span><br><span class="line">            &gt;</span><br><span class="line">            &lt;el-menu-item-group&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item-group title=&quot;分组2&quot;&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-submenu index=&quot;1-4&quot;&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;1-4-1&quot;&gt;选项4-1&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">          &lt;/el-submenu&gt;</span><br><span class="line">          &lt;el-submenu index=&quot;2&quot;&gt;</span><br><span class="line">            &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;导航二&lt;/template&gt;</span><br><span class="line">            &lt;el-menu-item-group&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;2-1&quot;&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;2-2&quot;&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item-group title=&quot;分组2&quot;&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;2-3&quot;&gt;选项3&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-submenu index=&quot;2-4&quot;&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;2-4-1&quot;&gt;选项4-1&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">          &lt;/el-submenu&gt;</span><br><span class="line">          &lt;el-submenu index=&quot;3&quot;&gt;</span><br><span class="line">            &lt;template slot=&quot;title&quot;</span><br><span class="line">              &gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;导航三&lt;/template</span><br><span class="line">            &gt;</span><br><span class="line">            &lt;el-menu-item-group&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;3-1&quot;&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;3-2&quot;&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item-group title=&quot;分组2&quot;&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;3-3&quot;&gt;选项3&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-submenu index=&quot;3-4&quot;&gt;</span><br><span class="line">              &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index=&quot;3-4-1&quot;&gt;选项4-1&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">          &lt;/el-submenu&gt;</span><br><span class="line">        &lt;/el-menu&gt;</span><br><span class="line">      &lt;/el-aside&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-header&gt;</span><br><span class="line">          &lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/el-header&gt;</span><br><span class="line">        &lt;el-main&gt;</span><br><span class="line">          &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">        &lt;/el-main&gt;</span><br><span class="line">      &lt;/el-container&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="重定向与别名"><a href="#重定向与别名" class="headerlink" title="重定向与别名"></a>重定向与别名</h4><p>比如，我们要访问 home 页面，但是 home 页面没有被 router 所匹配到，那么使用，router 的 redirect，把它给重定向到 404 页面。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 会匹配所有路径</span><br><span class="line">  path: &quot;*&quot;,</span><br><span class="line">  redirect: &quot;/404Page&quot;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>router 中的别名，alias，比如我们访问首页，path 是 “/”，这个时候，我们如果使用，router，跳转到/index，页面。就会匹配到 404 页面。</p>
<p>这个时候，我们设置别名，path：“/”的，alias：“/index”，这样的话，router.push 跳转到 /，/index，都会匹配到首页。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/&quot;,</span><br><span class="line">  name: &quot;home&quot;,</span><br><span class="line">  alias: &quot;/index&quot;,</span><br><span class="line">  component: HomeView,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="router-路由组件传参"><a href="#router-路由组件传参" class="headerlink" title="router 路由组件传参"></a>router 路由组件传参</h4><p>每次 url 传递的参数，都在 route.params，里面拿到。组件与 router 之间会存在高度耦合性。</p>
<p>我们可以使用，组件当中的 props 来降低解耦。</p>
<p>布尔模式下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: &quot;/about/:id&quot;,</span><br><span class="line">  name: &quot;about&quot;,</span><br><span class="line">  props: true,</span><br><span class="line">  component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>props 为 true，router 上的 params，会自动绑定到组件的 props，上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;HomeNavbar&quot;&gt;组件:&#123;&#123; id &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;id&quot;],</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$route.params);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.HomeNavbar &#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象模式，如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。</p>
<p>静态指的是，route.params,和，route.query 的参数都无法传递到，props 上面去。</p>
<p>参数被定义在 router 上写死了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: &quot;/about&quot;,</span><br><span class="line">  name: &quot;about&quot;,</span><br><span class="line">  props: &#123; id: 1212121, name: &quot;章三&quot; &#125;,</span><br><span class="line">  // props: (route) =&gt; (&#123; ...route.query &#125;),</span><br><span class="line">  component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数模式，我们可以创建一个函数返回 props，这样可以把静态的值，路由的值结合到一起。。</p>
<p>比如，我们要把 route.query 的值，返回到 props，上。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/about&quot;,</span><br><span class="line">    name: &quot;about&quot;,</span><br><span class="line">    props: (route) =&gt; (&#123; ...route.query &#125;),</span><br><span class="line">    component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;about&quot;&gt;</span><br><span class="line">    &lt;h1&gt;This is an about page&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;id=&gt; &#123;&#123; id &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;name=&gt; &#123;&#123; name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;id&quot;, &quot;name&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="router-当中的路由守卫"><a href="#router-当中的路由守卫" class="headerlink" title="router 当中的路由守卫"></a>router 当中的路由守卫</h4><p>使用全局路由守卫来，来判断 token 是否存在。不存在就去登录页。</p>
<p>beforeEach,有三个参数，to，from，next。<br>to，从哪来来，from，要到哪里去。</p>
<p>next，是否同意。。</p>
<p>next 写的一定要符合逻辑。确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import router from &quot;@/router/index&quot;;</span><br><span class="line">const whiteList = [&quot;/login&quot;];</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  const Token = localStorage.getItem(&quot;Token&quot;);</span><br><span class="line">  if (Token) &#123;</span><br><span class="line">    if (to.path === &quot;/login&quot;) &#123;</span><br><span class="line">      next(&quot;/&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (whiteList.includes(to.path)) &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(`/login?redirect=$&#123;to.fullPath&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全局后置钩子，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全局后置钩子，没有，next 方法。只有 to，from</p>
<p>路由独享的守卫</p>
<p>比如，我有一个特殊的页面，权限只针对这个页面。那么在页面的钩子函数里面，处理不够优雅。在全局守卫里面，处理有小题大做。。</p>
<p>例子如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &quot;/about&quot;,</span><br><span class="line">  name: &quot;about&quot;,</span><br><span class="line">  props: (route) =&gt; (&#123; ...route.query &#125;),</span><br><span class="line">  beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">    if (localStorage.getItem(&quot;Token&quot;)) &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next(`/login?redirect=$&#123;to.fullPath&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>beforeEntaer,路由上的守卫就特别好使。</p>
<p>组件内也有路由守卫给我们使用。<br>分别是，beforeRouteEnter<br>beforeRouteUpdate (2.2 新增)<br>beforeRouteLeave</p>
<p>我们把在 router 上的，beforEnter，守卫拿掉。</p>
<p>例子如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">  // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">  // 不！能！获取组件实例 `this`</span><br><span class="line">  // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">  if (localStorage.getItem(&quot;Token&quot;)) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next(`/login?redirect=$&#123;to.fullPath&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当页面被复用的时候。beforeRouteUpdate 守卫会被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeRouteUpdate(to, from) &#123;</span><br><span class="line">  // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line">  console.log(to.path, from.path);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>beforeRouteLeave 路由守卫，更像一个全局后置守卫，但是他有 next 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">  // 导航离开该组件的对应路由时调用</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="路由的元信息"><a href="#路由的元信息" class="headerlink" title="路由的元信息"></a>路由的元信息</h4><p>我们可以在路由上定义 mate 字段，存储一些路由信息，比如是否要身份验证…</p>
<p>router.js，路由元信息添加到，router 里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/404Page&quot;,</span><br><span class="line">    name: &quot;404&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&quot;../views/404Page.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/&quot;,</span><br><span class="line">    name: &quot;home&quot;,</span><br><span class="line">    alias: &quot;/index&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&quot;../views/HomeView.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/about&quot;,</span><br><span class="line">    name: &quot;about&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    props: (route) =&gt; (&#123; ...route.query &#125;),</span><br><span class="line">    component: () =&gt; import(&quot;../views/AboutView.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/LayoutIndex&quot;,</span><br><span class="line">    name: &quot;LayoutIndex&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      default: () =&gt; import(&quot;../layout/LayoutIndex.vue&quot;),</span><br><span class="line">      main: () =&gt; import(&quot;../layout/MainView.vue&quot;),</span><br><span class="line">      aside: () =&gt; import(&quot;../layout/AsideView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/login&quot;,</span><br><span class="line">    name: &quot;login&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    component: () =&gt; import(&quot;../views/LoginPage.vue&quot;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/UserView&quot;,</span><br><span class="line">    name: &quot;UserView&quot;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      authentication: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      default: () =&gt; import(&quot;../views/UserView.vue&quot;),</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: &quot;DefaultView&quot;,</span><br><span class="line">        name: &quot;DefaultView&quot;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          authentication: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">          default: () =&gt; import(&quot;../views/user/DefaultView.vue&quot;),</span><br><span class="line">          header: () =&gt; import(&quot;../views/user/HeaderView.vue&quot;),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    // 会匹配所有路径</span><br><span class="line">    path: &quot;*&quot;,</span><br><span class="line">    redirect: &quot;/404Page&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br><span class="line">const originalPush = VueRouter.prototype.push;</span><br><span class="line">VueRouter.prototype.push = function push(location) &#123;</span><br><span class="line">  return originalPush.call(this, location).catch((err) =&gt; err);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default router;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用路由信息，设置路由守卫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import router from &quot;@/router/index&quot;;</span><br><span class="line">// const whiteList = [&quot;/login&quot;];</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  const Token = localStorage.getItem(&quot;Token&quot;);</span><br><span class="line">  if (Token) &#123;</span><br><span class="line">    if (to.path === &quot;/login&quot;) &#123;</span><br><span class="line">      next(&quot;/&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (to.meta.authentication) &#123;</span><br><span class="line">      next(`/login?redirect=$&#123;to.fullPath&#125;`);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="路由动效"><a href="#路由动效" class="headerlink" title="路由动效"></a>路由动效</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用动态的 transition name --&gt;</span><br><span class="line">&lt;transition :name=&quot;transitionName&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在页面未加载之前获取数据。"><a href="#在页面未加载之前获取数据。" class="headerlink" title="在页面未加载之前获取数据。"></a>在页面未加载之前获取数据。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">    next(vm =&gt; vm.setData(err, post))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结，集中的过了一下，route.parmas，刷新参数会消失的原因是，因为，动态路由传参数，必须要在 router 里面定义。</p>
<p>视图如何嵌套，命名视图如何和嵌套视图，整在一起，路由如何加动效。router 传参。如何更好的解耦，把它整合到 porps 里面。如何使用重定向和别名。</p>
<p>包括路由的 3 个全局守卫，路由独享的守卫，组件路由守卫。路由的 mate 信息，配合全局守卫。</p>
<p>在页面加载之前提前获取到数据。<br>和路由的滚动。等等知识。还是干货满满的。</p>
<p>百度脑图地址，<a href="https://naotu.baidu.com/file/d10fd6077ad17cc07833f7fd0dbdbc19">百度脑图</a></p>
]]></content>
      <categories>
        <category>vue router</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>开发登录人机验证</title>
    <url>/blogs/2022/12/22/%E8%8E%B7%E5%8F%96%E9%AA%8C%E8%AF%81%E7%A0%81--%E4%BA%BA%E6%9C%BA%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p><a href="https://gitee.com/yaru722/vue-monoplasty-slide-verify">人机验证</a></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save vue-monoplasty-slide-verify</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import SlideVerify from &#x27;vue-monoplasty-slide-verify&#x27;;</span><br><span class="line"></span><br><span class="line">Vue.use(SlideVerify);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;slide-verify ref=&quot;slideblock&quot; @again=&quot;onAgain&quot; @fulfilled=&quot;onFulfilled&quot; @success=&quot;onSuccess&quot; @fail=&quot;onFail&quot; @refresh=&quot;onRefresh&quot; :slider-text=&quot;text&quot; :accuracy=&quot;accuracy&quot;&gt;&lt;/slide-verify&gt;</span><br><span class="line">  &lt;button @click=&quot;handleClick&quot;&gt;在父组件可以点我刷新哦&lt;/button&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#x27;App&#x27;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &#x27;&#x27;,</span><br><span class="line">                text: &#x27;向右滑动-&gt;&#x27;,</span><br><span class="line">                // 精确度小，可允许的误差范围小；为1时，则表示滑块要与凹槽完全重叠，才能验证成功。默认值为5</span><br><span class="line">                accuracy: 1,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            onSuccess(times)&#123;</span><br><span class="line">                console.log(&#x27;验证通过，耗时 +&#x27; times + &#x27;毫秒&#x27;);</span><br><span class="line">                this.msg = &#x27;login success, 耗时$&#123;(times / 1000).toFixed(1)&#125;s&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            onFail()&#123;</span><br><span class="line">                console.log(&#x27;验证不通过&#x27;);</span><br><span class="line">                this.msg = &#x27;&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            onRefresh()&#123;</span><br><span class="line">                console.log(&#x27;点击了刷新小图标&#x27;);</span><br><span class="line">                this.msg = &#x27;&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            onFulfilled() &#123;</span><br><span class="line">                console.log(&#x27;刷新成功啦！&#x27;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onAgain() &#123;</span><br><span class="line">                console.log(&#x27;检测到非人为操作的哦！&#x27;);</span><br><span class="line">                this.msg = &#x27;try again&#x27;;</span><br><span class="line">                // 刷新</span><br><span class="line">                this.$refs.slideblock.reset();</span><br><span class="line">            &#125;,</span><br><span class="line">            handleClick() &#123;</span><br><span class="line">                this.$refs.slideblock.reset();</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>vue 插件</tag>
      </tags>
  </entry>
  <entry>
    <title>css当中的BFC</title>
    <url>/blogs/2022/12/21/css%E5%BD%93%E4%B8%AD%E7%9A%84BFC/</url>
    <content><![CDATA[<h5 id="到底什么是bfc"><a href="#到底什么是bfc" class="headerlink" title="到底什么是bfc"></a>到底什么是bfc</h5><p>Block formatting contexts 也叫做”块格式化上下文”。简单来说，bfc容器在内部有一块独立的空间。不管内部的元素如何布局，如何排列，它们都不回影响到外部的布局。就像一个规则。</p>
<p>举个例子，</p>
<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog_bfc1.jpeg" alt="什么是bfc"></p>
<p><strong>孙悟空</strong>画的圈圈，就是<strong>BFC</strong>，而里面的唐僧等人，就是BFC容器内部的子元素。</p>
<p>外部的容器打扰不到BFC内部的布局，BFC容器，也不会影响到外部的布局。。</p>
<h5 id="BFC-有什么用？为什么要使用它。"><a href="#BFC-有什么用？为什么要使用它。" class="headerlink" title="BFC,有什么用？为什么要使用它。"></a>BFC,有什么用？为什么要使用它。</h5><p>为什么要使用bfc</p>
<p>举个例子，</p>
<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog_bfc2.jpeg" alt="如果不使用bfc的话"></p>
<p><strong>子元素</strong>(乘客)，就会<strong>挤出</strong>容器，导致影响到外部的布局。。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;div class=&quot;Container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;p&gt;林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">.Container &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChatb847b01c1e81db03fd5eb205c3048678.png" alt="容器被子元素挤出"></p>
<p>因为，Container，大小只有100px，box1+box2，大小已经超出了100px，那么元素就会溢出。这个时候就会影响到，下面的布局。。</p>
<p>bfc容器，子元素在空间不足的情况下，不会影响到外部布局。。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;div class=&quot;BFC_box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.BFC_box &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>效果图</p>
<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChatb3ca569dc952680bb8ab7b50e2bd73a8.png" alt="bfc容器，子元素不会影响到外部布局"></p>
<h5 id="如何触发bfc"><a href="#如何触发bfc" class="headerlink" title="如何触发bfc"></a>如何触发bfc</h5><ol>
<li><p>根元素；</p>
</li>
<li><p>浮动元素。元素的 float 不是 none；</p>
</li>
<li><p>绝对定位元素。元素的 position 为 absolute 或 fixed；</p>
</li>
<li><p>行内块元素。元素的 display 为 inline-block；</p>
</li>
<li><p>表格单元格。元素的 display为 table-cell，HTML表格单元格默认为该值；</p>
</li>
<li><p>表格标题。元素的 display 为 table-caption，HTML表格标题默认为该值；</p>
</li>
<li><p>匿名表格单元格元素。元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table；</p>
</li>
<li><p>overflow 值不为 visible 的块元素 ；</p>
</li>
<li><p>弹性元素。display为 flex 或 inline-flex元素的直接子元素；</p>
</li>
<li><p>网格元素。display为 grid 或 inline-grid 元素的直接子元素。</p>
</li>
</ol>
<h5 id="bfc都有哪些用处。"><a href="#bfc都有哪些用处。" class="headerlink" title="bfc都有哪些用处。"></a>bfc都有哪些用处。</h5><ol>
<li>出现mrigin重叠。</li>
<li>可以应用到两栏布局。</li>
<li>清除内部的元素的浮动。</li>
</ol>
<p>marigin 重叠。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-bottom: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-top: 40px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>效果图</p>
<p><a href="https://imgse.com/i/zIlvoq"><img src="https://s1.ax1x.com/2022/12/14/zIlvoq.md.png" alt="zIlvoq.md.png"></a></p>
<p>按道理来讲  margin-top: 40px;，margin-bottom: 100px;那么，上下边距得有140px的，但是2个盒子之间的上下边距，会被折叠，取最大的那个。所以。上下只有100px的边距。</p>
<p>bfc可以清除浮动。</p>
<p>现在产生一个浮动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;111&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    width: 600px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    margin: 0 10px;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    margin: 0 10px;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>效果图<br><a href="https://imgse.com/i/zI8use"><img src="https://s1.ax1x.com/2022/12/14/zI8use.md.png" alt="zI8use.md.png"></a></p>
<p>给.box添加 display：flex，</p>
<p>效果图。</p>
<p><a href="https://imgse.com/i/zI8TW6"><img src="https://s1.ax1x.com/2022/12/14/zI8TW6.md.png" alt="zI8TW6.md.png"></a></p>
<p>以下就是bfc格式化块级上下文的理解。bfc容器，不影响到外部容器。marigin会折叠。会清清楚浮动。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css当中的BFC</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始学习vuex</title>
    <url>/blogs/2022/12/21/%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%AD%A6%E4%B9%A0vuex/</url>
    <content><![CDATA[<h4 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h4><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<p>用通俗的话，来说，当一个vue项目，复杂起来的时候，就需要一个vue 组件全局状态管理的工具。vuex就是一个这样的工具。</p>
<h4 id="vuex的state"><a href="#vuex的state" class="headerlink" title="vuex的state"></a>vuex的state</h4><p>把vuex 当中的state，在组件里展示出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    token: &quot;&quot;,</span><br><span class="line">    count: 1,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return this.$store.state.user.count;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用mapState 辅助函数</p>
<p>当我们需要在一个组件state当中获取到，多个状态的时候。</p>
<p>代码如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState &#125; from &quot;vuex&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 10,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    count: (state) =&gt; state.user.count,</span><br><span class="line">    token: (state) =&gt; state.user.token,</span><br><span class="line">    countPlusLocalState(state) &#123;</span><br><span class="line">      return state.user.count + this.num;</span><br><span class="line">    &#125;,</span><br><span class="line">    msg: &quot;msg&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mapState,可以帮助我们更好的生成计算属性，获取到store里面的状态。</p>
<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &#x27;count&#x27;</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>mapState，是一个对象，刚才的那种写法影响到了，我们使用计算属性。这时候我们可以用对象展开运算符写法，以免这样的情况发生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      count: (state) =&gt; state.user.count,</span><br><span class="line">      plus: (state) =&gt; &#123;</span><br><span class="line">        console.log(thit.num);</span><br><span class="line">        return state.user.count;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">    plusNum: () =&gt; &#123;</span><br><span class="line">      return thit.num + 10;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    thit = this;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以在计算属性，照常使用，data里面的参数，与store里面的参数相加。</p>
<p>也能把computed，mapState分开来。</p>
<p>对于需要经常去进行通讯的组件来说，vuex，极大了弥补了，单向数据流带来的不足。<br>vuex，更方便调试，更直观。但是，却不好维护，所以，非必要的情况下，组件的局部状态还是保存到局部为好。</p>
<h4 id="vuex当中的Getter"><a href="#vuex当中的Getter" class="headerlink" title="vuex当中的Getter"></a>vuex当中的Getter</h4><blockquote>
<p>有时候我们需要从 store 中的 state 中派生出一些状态，比如store里面有个count，我们需要对count，进行加倍。这个时候，使用getter，就非常好使。</p>
</blockquote>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  dounceCount() &#123;</span><br><span class="line">    return this.$store.getters.doubleCount;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getter通过属性访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;超级加倍&#123;&#123; $store.getters.doubleCount &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getter通过方法去访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doubleCount() &#123;</span><br><span class="line">    return thit.$store.getters.doubleCount;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>mapGetters辅助函数，当我们需要多个getter的时候，可以使用mapGetters函数，将store里面的getter属性映射到，computed上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...mapGetters([&quot;doneCount&quot;]),</span><br></pre></td></tr></table></figure>

<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...mapGetters([&#123;doneCount:doneCount&#125;]),</span><br></pre></td></tr></table></figure>




<h4 id="vuex-mutation的使用"><a href="#vuex-mutation的使用" class="headerlink" title="vuex mutation的使用"></a>vuex mutation的使用</h4><p>修改，store里面的状态的唯一方法就是，mutation。</p>
<p>首先我们要在mutation方法里面注册一个，更改store的事件或者是方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  pluNum(state, payload) &#123;</span><br><span class="line">    console.log(state.count, payload);</span><br><span class="line">    state.count += payload;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>mutation会有一个type，一个回调函数，实际上，pluNum，就是我们事件类型的type，而pluNum，就是我们的回调函数，是我们修改，它会接受state，作为一个参数，第二个参数为payload。</p>
<p>在回调函数内部，对store当中的state进行修改。</p>
<p>如何提交一个mutation呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.commit(&#x27;pluNum&#x27;, 10)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>store.commit()，第一个注册的mutation名字，第二个是传递过来的参数。</p>
<p>以对象的方式，提交mutation,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &lt;div</span><br><span class="line">    @click=&quot;</span><br><span class="line">      $store.commit(&#123;</span><br><span class="line">        type: &#x27;pluNum&#x27;,</span><br><span class="line">        data: 10,</span><br><span class="line">      &#125;)</span><br><span class="line">    &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    count自增</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> mutations: &#123;</span><br><span class="line">  pluNum(state, payload) &#123;</span><br><span class="line">    console.log(payload);</span><br><span class="line">    state.count += payload.data;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接受的时候，payload.data,就是要传递过来的参数。</p>
<p>使用常量代替mutation事件类型。</p>
<p>创建一个mutation-types.js文件来保存常量。使用export 导出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const PLUS_NUM = &quot;PLUS_NUM&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>store模块代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; PLUS_NUM &#125; from &quot;../mutation-types.js&quot;;</span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  [PLUS_NUM](state, payload) &#123;</span><br><span class="line">    console.log(payload);</span><br><span class="line">    state.count += payload.data;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>提交store.commit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  @click=&quot;</span><br><span class="line">    $store.commit(&#123;</span><br><span class="line">      type: &#x27;PLUS_NUM&#x27;,</span><br><span class="line">      data: 10,</span><br><span class="line">    &#125;)</span><br><span class="line">  &quot;</span><br><span class="line">&gt;</span><br><span class="line">  count自增</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Mutation必须是一个同步函数。</p>
<p>使用mapMutations提交 mutation函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click=&quot;add(&#123; data: 12 &#125;)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">import &#123; mapState, mapGetters, mapMutations &#125; from &quot;vuex&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: &quot;PLUS_NUM&quot;,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="vuex-Action"><a href="#vuex-Action" class="headerlink" title="vuex Action"></a>vuex Action</h4><p>action类似于mutation，不同是，</p>
<p>action是异步，action，可以提交mutation，但是不能直接改变，state的状态。</p>
<p>注册一个action</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment(&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      commit(&quot;PLUS_NUM&quot;, 12);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<p>action的分发。</p>
<p>actioon接受一个叫，context，和store实例对象相同的对象。<br>context，内置了，getter，commit，state，</p>
<p>载荷方式分发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&quot;increment&quot;, &#123; data: 15 &#125;);</span><br></pre></td></tr></table></figure>
<p>以对象形式分发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&#123;</span><br><span class="line">  type: &quot;increment&quot;,</span><br><span class="line">  data: 15,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在组件里面分发，action。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click=&quot;increment(&#123; data: 15 &#125;)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line">import &#123;  mapActions &#125; from &quot;vuex&quot;;</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([&quot;increment&quot;]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<p>组合式Action。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA(&#123; commit &#125;, params) &#123;</span><br><span class="line">    return new Promise((resolve) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(params);</span><br><span class="line">        commit(&quot;PLUS_NUM&quot;, params);</span><br><span class="line">        resolve(&quot;actionA方法执行成功&quot;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  actionB(&#123; dispatch &#125;) &#123;</span><br><span class="line">    return dispatch(&quot;actionA&quot;, &#123; data: 11 &#125;).then(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;actionB方法执行成功&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">  add() &#123;</span><br><span class="line">    this.$store.dispatch(&quot;actionB&quot;, &#123; data: 11 &#125;).then((res) =&gt; &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="vuex-module的使用"><a href="#vuex-module的使用" class="headerlink" title="vuex module的使用"></a>vuex module的使用</h4><p>由于使用单一状态树，所有的应用状态，都会集中到一个对象上，会导致整个store，变大，难易维护。为了解决这个问题，vuex允许我们，把store分割为module模块，每个模块拥有<br>state，getter，mutation，action。</p>
<p>关于module的命名空间。</p>
<p>默认的情况下，action，mutation，和getter，注册的是全局命名空间。这样以来，会导致，多个模块对同一个action，或者getter mutation做出响应。</p>
<p>假设我们在一个大项目，我们希望我们的模块有更高的复用性，封装度。可以开启模块的命名空间。。</p>
<p>给我们的user模块，打开命名空间。  namespaced: true,</p>
<p>一旦打开命名空间后，我们获取到的，getter派生出来的值，提交mutition，action都会发生变化。。</p>
<p>先从，getter说起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//vuex模块，</span><br><span class="line">getters: &#123;</span><br><span class="line">    doneCount(state) &#123;</span><br><span class="line">        return state.count * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">...mapGetters([&quot;doneCount&quot;]),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候控制台就会报错，error，[vuex] unknown getter: doneCount。因为，获取，state的时候，我们是这些写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">  count: (state) =&gt; state.user.count,</span><br><span class="line">  plus: (state) =&gt; &#123;</span><br><span class="line">    return state.user.count;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接从，state.user模块，导出了，state的值。</p>
<p>开启命名空间后，获取user模块下面的getter，就得通过，mapGetter提供的对象写法。把user/doneCount的值映射到，”doneCount”上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">  doneCount: &quot;user/doneCount&quot;,</span><br><span class="line">&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，如果我们要提交一个mutation呢，怎么办呢？</p>
<p>mapMutiton写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  //vuex部分</span><br><span class="line">  mutations: &#123;</span><br><span class="line">   [PLUS_NUM](state, payload) &#123;</span><br><span class="line">     state.count += payload.data;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line">...mapMutations(&#123;</span><br><span class="line">   PLUS_NUM: &quot;user/PLUS_NUM&quot;,</span><br><span class="line">&#125;),</span><br><span class="line"> </span><br><span class="line">&lt;div @click=&quot;PLUS_NUM(&#123; data: 11 &#125;)&quot;&gt;mutation自增&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>store.commit写法。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line"> [PLUS_NUM](state, payload) &#123;</span><br><span class="line">   state.count += payload.data;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"> //store.commit写法</span><br><span class="line"> test(data) &#123;</span><br><span class="line">   this.$store.commit(&quot;user/PLUS_NUM&quot;, data);</span><br><span class="line"> &#125;,</span><br><span class="line">&lt;div @click=&quot;test(&#123; data: 11 &#125;)&quot;&gt;mutation自增&lt;/div&gt;   </span><br></pre></td></tr></table></figure>



<p>action写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mapActions写法</span><br><span class="line">...mapActions(&#123;</span><br><span class="line">  add: &quot;user/actionA&quot;,</span><br><span class="line">&#125;),</span><br><span class="line">//store.dispatch写法</span><br><span class="line">test(data) &#123;</span><br><span class="line">  this.$store.dispatch(&quot;user/actionA&quot;, data);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>假如，在vuex模块化当中，在b模块，获取到a模块的getter派生出来的值。要如何获取呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是模块a</span><br><span class="line">export default &#123;</span><br><span class="line">  namespaced: true,</span><br><span class="line">  state: &#123;</span><br><span class="line">    price: 100,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doublePrice(state) &#123;</span><br><span class="line">      return state.price * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模块b，</span><br><span class="line"></span><br><span class="line"> getters: &#123;</span><br><span class="line">    doneCount(state, getters, rootState, rootGetters) &#123;</span><br><span class="line">      console.log(&quot;另一个模块化getter的值&quot;,  </span><br><span class="line">      rootGetters[&quot;cart/doublePrice&quot;]);</span><br><span class="line">      return state.count * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>带命名空间的模块，如果想要使用全局的state，getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p>
<p>带命名空间绑定函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">  // ...mapState(&#123;</span><br><span class="line">  //   count: (state) =&gt; state.user.count,</span><br><span class="line">  //   plus: (state) =&gt; &#123;</span><br><span class="line">  //     return state.user.count;</span><br><span class="line">  //   &#125;,</span><br><span class="line">  // &#125;),</span><br><span class="line">  ...mapState(&quot;user&quot;, &#123;</span><br><span class="line">    count: (state) =&gt; state.count,</span><br><span class="line">    plus: (state) =&gt; state.count,</span><br><span class="line">  &#125;),</span><br><span class="line">  plusNum: () =&gt; &#123;</span><br><span class="line">    return thit.num + 10;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...mapGetters(&#123;</span><br><span class="line">  //   doneCount: &quot;user/doneCount&quot;,</span><br><span class="line">  // &#125;),</span><br><span class="line">  ...mapGetters(&quot;user&quot;, &#123;</span><br><span class="line">    doneCount: &quot;doneCount&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line">  thit = this;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations(&quot;user&quot;, &#123;</span><br><span class="line">    PLUS_NUM: &quot;PLUS_NUM&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  //mapActions写法</span><br><span class="line">  ...mapActions(&quot;user&quot;, &#123;</span><br><span class="line">    add: &quot;actionA&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  //store.dispatch写法</span><br><span class="line">  test(data) &#123;</span><br><span class="line">    this.$store.dispatch(&quot;user/actionA&quot;, data);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>我有点反感，vuex 的写法。。mapstate(‘路径’，导出的参数)，这样只能导出一个模块的参数。觉得更低效了。。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>vuex核心概念，state，与，getter，mutation，action。</p>
<p>mutation与action的区别是，一个同步一个异步。任何对store进行修改的操作都要经过，mutation。</p>
<p>action，可以提交mutation。也可以多重action。嵌套着玩。</p>
<p>getter，派生出来的东西 rootgetter，获取其他模块的getter。</p>
<p>namespaced，开启空间命名。。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>VueX</tag>
      </tags>
  </entry>
  <entry>
    <title>ES Modules的特性</title>
    <url>/blogs/2022/12/06/es_modules%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>很长的一段时间内，我以为，es modules的关键字import，export,只能在vue里面，使用，是因为webpack，这样的打包工具，才能得已实现的。<br>甚至让我觉得，原生js不行的原因就是因为，不支持es moduls。</p>
<p>陷入了一定的误区，这篇文章，来修正我的认知错误。</p>
<h5 id="原生js使用es-module进行模块化。"><a href="#原生js使用es-module进行模块化。" class="headerlink" title="原生js使用es module进行模块化。"></a>原生js使用es module进行模块化。</h5><p>使用script 加载js文件的时候 <strong><u>type = ‘module’</u></strong> 就可以开启模块化。</p>
<p><a href="https://imgse.com/i/xTjKx0"><img src="https://s1.ax1x.com/2022/11/01/xTjKx0.md.png" alt="xTjKx0.md.png"></a></p>
<h5 id="注意，es-module，默认开启的严格模式。我来证明给您看。"><a href="#注意，es-module，默认开启的严格模式。我来证明给您看。" class="headerlink" title="注意，es module，默认开启的严格模式。我来证明给您看。"></a>注意，es module，默认开启的严格模式。我来证明给您看。</h5><p><a href="https://imgse.com/i/xTj92t"><img src="https://s1.ax1x.com/2022/11/01/xTj92t.png" alt="xTj92t.png"></a></p>
<p><a href="https://imgse.com/i/xTjVaQ"><img src="https://s1.ax1x.com/2022/11/01/xTjVaQ.png" alt="xTjVaQ.png"></a></p>
<p>看吧，控制台上this是 undefined</p>
<h5 id="原生js，使用import，export"><a href="#原生js，使用import，export" class="headerlink" title="原生js，使用import，export"></a>原生js，使用import，export</h5><p>在上图的index.html文件下的index.js export抛出，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p>
<p>在test import，引入。<br><a href="https://imgse.com/i/xTjnGn"><img src="https://s1.ax1x.com/2022/11/01/xTjnGn.png" alt="xTjnGn.png"></a></p>
<p>控制台，打印的结果是，{a: 11}</p>
<h5 id="es-module，加载是通过cors进行的。"><a href="#es-module，加载是通过cors进行的。" class="headerlink" title="es module，加载是通过cors进行的。"></a>es module，加载是通过cors进行的。</h5><p>如果 <strong><script type='module' src=''> </script></strong><br>如果，这里的 <strong>src</strong>加载的是服务器资源的话，如果资源不支持cors的话，会被浏览器拦截。</p>
<p>例子如下，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p>
<p>支持，cors 加载的资源，type = ‘module’ 会被浏览器所加载，不支持cors的，会被浏览器拦截，这点服务端需要注意。</p>
<p><a href="https://imgse.com/i/xTj1qU"><img src="https://s1.ax1x.com/2022/11/01/xTj1qU.png" alt="xTj1qU.png"></a></p>
<p>cors，不支持文件的访问，所以，必须使用，http，serve的方式进行访问。</p>
<p><strong>使用，文件访问导致的后果</strong></p>
<p><a href="https://imgse.com/i/xTjlrT"><img src="https://s1.ax1x.com/2022/11/01/xTjlrT.png" alt="xTjlrT.png"></a></p>
<h5 id="es-module，自带脚本延迟效果"><a href="#es-module，自带脚本延迟效果" class="headerlink" title="es module，自带脚本延迟效果"></a>es module，自带脚本延迟效果</h5><p>当页面，加载完毕后，才会加载，es module脚本。<br><a href="https://imgse.com/i/xTjQMV"><img src="https://s1.ax1x.com/2022/11/01/xTjQMV.png" alt="xTjQMV.png"></a></p>
<p>当所有的，非es module加载完毕后，才能加载es module模块。</p>
<p>总结，<br>es module的特性是，<br>1，默认就是严格模式<br>2，每个module模块，都拥有私有的作用域。<br>3，只支持cors，加载。本地必须开启 web serve<br>4，自带延迟效果</p>
<h5 id="关于import-export-一些小知识。"><a href="#关于import-export-一些小知识。" class="headerlink" title="关于import export 一些小知识。"></a>关于import export 一些小知识。</h5><p>我们可以使用，export，到处一些变量方法，也可以，export，设置默认导出的方法。</p>
<p><a href="https://imgse.com/i/xTjEVg"><img src="https://s1.ax1x.com/2022/11/01/xTjEVg.jpg" alt="xTjEVg.jpg"></a></p>
<p>接收默认到处的值</p>
<p><a href="https://imgse.com/i/xTjiKf"><img src="https://s1.ax1x.com/2022/11/01/xTjiKf.png" alt="xTjiKf.png"></a></p>
<p>接收默认导出的值</p>
<p><a href="https://imgse.com/i/xTjmPs"><img src="https://s1.ax1x.com/2022/11/01/xTjmPs.png" alt="xTjmPs.png"></a></p>
<p><strong>as 关键字，修改默认导出的值</strong></p>
<p>export <strong>as关键字修改 变量名</strong></p>
<p><a href="https://imgse.com/i/xTj8ZF"><img src="https://s1.ax1x.com/2022/11/01/xTj8ZF.png" alt="xTj8ZF.png"></a></p>
<p><a href="https://imgse.com/i/xTjGa4"><img src="https://s1.ax1x.com/2022/11/01/xTjGa4.png" alt="xTjGa4.png"></a><br>import <strong>as修改接收参数的变量名</strong></p>
<h5 id="export-导出的并不是一个对象-import-引入的也不是个对象的解构。"><a href="#export-导出的并不是一个对象-import-引入的也不是个对象的解构。" class="headerlink" title="export 导出的并不是一个对象 import 引入的也不是个对象的解构。"></a>export 导出的并不是一个对象 import 引入的也不是个对象的解构。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">export &#123;</span><br><span class="line">    num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然export后面跟着 {} 看起来很像对象， { name },看起来很像es6，字面量的写法。</p>
<p>import 在这里 **{}**，就像使用对象字面量解构一样，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; num &#125; from &#x27;./test.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>export {}</strong> 和 <strong>import {}</strong> 是 es modulc的固定语法。</p>
<p>export 导出的只是，内存地址。<br>export 导出的，是常量。只能在 export 内部修改。</p>
<p><strong>例子如下</strong></p>
<p>导出num</p>
<p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p>
<p><a href="https://imgse.com/i/xTjNGR"><img src="https://s1.ax1x.com/2022/11/01/xTjNGR.png" alt="xTjNGR.png"></a></p>
<p>控制台报错，index.js:4 Uncaught TypeError: Assignment to constant variable.<br>    at index.js:4:4</p>
<p>因为，我们import引入的，<strong>num</strong> 是个常量。无法在外部，对 import 引入的 num进行修改。</p>
<p><strong>那么，怎么样导入，一个字面量对象呢？</strong></p>
<p>使用 <strong>export default</strong></p>
<p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p>
<h5 id="import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"><a href="#import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。" class="headerlink" title="import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"></a>import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。</h5><p>如果export 导入了很多属性。我们可以使用import * 把所有的导出全部接收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">let name = &#x27;张三&#x27;;</span><br><span class="line">let age = 12;</span><br><span class="line">let sigin = &#x27;为什么&#x27;</span><br><span class="line">export &#123;</span><br><span class="line">    num,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sigin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import * as module from &#x27;./test.js&#x27;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure>

<p>import * as module 导入全部的要导出的模块。</p>
<p>试想，我们有一个这样的需求，根据判断条件，来决定要导入，那个模块。</p>
<p>import 必须要在最外层，最顶层的作用域当中。不能嵌套在if，或者funtion当中。</p>
<p>es modulc，提供了一个，<strong>import</strong>函数，来帮助我们动态的导入模块。而且，import(),本身是一个promise函数。</p>
<p><a href="https://imgse.com/i/xTjFr8"><img src="https://s1.ax1x.com/2022/11/01/xTjFr8.png" alt="xTjFr8.png"></a></p>
<p>这样通过，then,那么就能读取到模块了。</p>
<p>import 可以导入一个，url链接模块<br><a href="https://imgse.com/i/xTju2q"><img src="https://s1.ax1x.com/2022/11/01/xTju2q.png" alt="xTju2q.png"></a></p>
<p>import 导出默认成员与，命名成员<br><a href="https://imgse.com/i/xTjkqS"><img src="https://s1.ax1x.com/2022/11/01/xTjkqS.png" alt="xTjkqS.png"></a></p>
<p>总结，es module，</p>
<ol>
<li>在原生js当中使用，script标签，type应该使用，module。module默认就在严格模式环境下，this不可能指向全局。</li>
<li>每个模块都拥有了独立的，私有的作用域。</li>
<li>module加载，模块，会存在cors问题，需要服务端专门设置，本地必须开启，web sever</li>
<li>type = module后，会存在延迟效果，等页面资源加载完毕后，再去加载。</li>
</ol>
<p>总结，import的特性</p>
<ol>
<li>import {} 并非对象的解构，而是语法就是这样的。</li>
<li>import，导入的属性，只可以读取。import导入的是常量，无法修改。</li>
<li>import * model from 可以把，所有导出的属性，全部导入到一个对象里面。</li>
<li>import，可以导入url模块，</li>
<li>import必须在顶部，不可以在函数，条件语句下面。</li>
<li>import()，可以动态导入，<strong>import</strong>默认本身就是一个promise方法。</li>
<li>import as 可以更换导入的属性别名。</li>
<li>import num，{age,age1} from ‘../../‘可以导入，默认的成员与命名的成员。</li>
</ol>
<p>总结，export的特性</p>
<ol>
<li>export {} 这是语法，抛出的不是一个，字面量对象，export default是抛出对象。</li>
<li>export 抛出去的值是内存地址的引用，值，只能在export模块里面修改。</li>
<li>as 可以修改默认要导出的值的别名。</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>import export的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>初学webpack</title>
    <url>/blogs/2022/12/06/%E5%88%9D%E5%AD%A6webpack/</url>
    <content><![CDATA[<h5 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h5><blockquote>
<p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些预设，打包为合适的格式以供浏览器使用。</p>
</blockquote>
<p>1，webpack可以分析你项目当中的代码，提取使用到的代码，去除用不到代码。<br>2，配合各种loader，来把sass，less，scss，ts，es新语法，解析成各种各样的文件。<br>3，帮忙把打包的项目，文件通过plugin，进行各种优化，比如压缩，混淆。</p>
<h5 id="webpack模块化打包的原因。"><a href="#webpack模块化打包的原因。" class="headerlink" title="webpack模块化打包的原因。"></a>webpack模块化打包的原因。</h5><ol>
<li>浏览器内核不同，对于技术支持的情况不一样，会存在兼容性问题。</li>
<li>模块化划分下，会增加多余的http请求次数。</li>
<li>不仅仅是js需要模块化，css，img，整个前端项目都需要，进行模块化。</li>
</ol>
<h5 id="webpack的概念"><a href="#webpack的概念" class="headerlink" title="webpack的概念"></a>webpack的概念</h5><p>webpack4以后，webpack配置默认的<strong>entry</strong>就是src目录下的js文件。<br><strong>output</strong>默认输出的path，就是dist下的main.js文件。</p>
<p>我们也可以，新建一个webpack.config.js文件。来设置，<strong>entry与output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//path是node里面的path</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //webpck的入口文件，要模块化打包的js代码目录，是个相对路径，&quot;./&quot;，不能丢。</span><br><span class="line">    entry: &#x27;./src&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;pc&#x27;),//path.resolve,是一个绝对路径，</span><br><span class="line">        filename: &#x27;dist.js&#x27;//要输出的文件名称</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>关于webpack的loader</strong></p>
<p>webpack，可以把，js代码模块化打包，但是，前端不仅仅是css需要打包。还有还有，css，ts，各种资源。</p>
<p>这个时候就得需要配置loader，来处理这些文件。</p>
<h5 id="webpack的工作模式"><a href="#webpack的工作模式" class="headerlink" title="webpack的工作模式"></a>webpack的工作模式</h5><table>
<thead>
<tr>
<th>webpack的工作模式</th>
<th>语法</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>开发环境</td>
<td>webpack –mode development</td>
<td>开发环境下的代码</td>
</tr>
<tr>
<td>原始环境</td>
<td>webpack –mode none</td>
<td>最原始的代码</td>
</tr>
<tr>
<td>生产环境</td>
<td>webpack –mode production</td>
<td>默认就是生产环境下的压缩代码</td>
</tr>
</tbody></table>
<h5 id="关于webpack的loader"><a href="#关于webpack的loader" class="headerlink" title="关于webpack的loader"></a>关于webpack的loader</h5><p><strong>如何去使用loader编译，css代码。</strong></p>
<p>首先使用npm，css loader。</p>
<p>npm i css-loder –dev<br>npm i style-loader –dev</p>
<p>然后设置。webpack.config.js配置的module。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rules，是数组，决定都要使用，那些loader，test，<br>use是个数组，指定要，使用哪些loader。</p>
<p><strong>use设置要使用的loader，打包的时候，会存在先后顺序，比如，把css文件，模块化，打包到，dist文件资源里面，css-loader，解析css文件上使用到的样式，而，style loadr 把样式放入，style到页面上。</strong></p>
<p>并且，通常我们都会把，所有的资源都汇总到，src/main.js，至少是个js文件到情况下。<br>要加载，或者使用到的css文件，直接import到，main.js页面就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //webpck的入口文件，要模块化打包的js代码目录</span><br><span class="line">    entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.js</span><br><span class="line"></span><br><span class="line">import createHeading from &#x27;./test.js&#x27;</span><br><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line">import &#x27;../sass/index.css&#x27;</span><br><span class="line">const heading = createHeading();</span><br><span class="line">console.log(createHeading())</span><br><span class="line">document.body.append(heading);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**entry: ‘./src/index.js’,**输出来的，webpack打包出来的还是一个js文件。顺便把css模块给整合进入。</p>
<h5 id="如何使用loader-file-loader与url-loader。"><a href="#如何使用loader-file-loader与url-loader。" class="headerlink" title="如何使用loader file-loader与url-loader。"></a>如何使用loader file-loader与url-loader。</h5><p>安装file-loader</p>
<p>yarn add file-loader</p>
<p>webpack.config.js配置 file-loader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;,</span><br><span class="line">        &#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: [&#x27;file-loader&#x27;] &#125;,</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后运行，yarn webapck 命令。</p>
<p>输出的dist目录下，会有图片。</p>
<p>但是，如果加载的项目静态资源过多的话，会导致，请求变多。网页卡顿。这个时候，url-loader，就能解决问题。</p>
<p>base64，可以减少我们http请求次数。</p>
<p>设置url-loader的情况下的前提下是，必须安装<strong>file-loader</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.(jpg|png|gif|bmp|jpeg)$/,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: &#x27;url-loader&#x27;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: 10 * 1024,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后通过，use下的option设置规则，limit: 10 * 1024,这里的10是字节，1024字节是1kb，大于10kb的图片，我们就通过，file-loader，加载到项目当中，小于10kb到情况下，就使用url-loader，base64.</p>
<h4 id="使用webpack-，转换es6代码。"><a href="#使用webpack-，转换es6代码。" class="headerlink" title="使用webpack ，转换es6代码。"></a>使用webpack ，转换es6代码。</h4><p>webpack，只是打包工具。虽然队，import，export，能够转换，但是，对es6并没有进行。</p>
<p>所以我们需要使用，bable-loader插件对es6的代码转换。</p>
<p>例子如下，</p>
<p><strong>安装bable-loader插件</strong></p>
<p>yarn add bable-loader @babel/core @babel/preset-env –dev</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.js$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&#x27;@babel/preset-env&#x27;],</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>option,选择 persets，使用@babel/preset-env插件。来对es6代码进行转换。。</p>
<h4 id="webpack加载的资源方式"><a href="#webpack加载的资源方式" class="headerlink" title="webpack加载的资源方式"></a>webpack加载的资源方式</h4><p>webpack不仅仅会通过css-loader 和style-loader 把css样式给打包到一个模块js文件里面。<br>也会，把图片资源 通过，file-loader 或者 url-loadr，打包到js文件里面。</p>
<p>连html都模块也可以打包，但是，html当中我们会引用到其他资源，比如a标签的地址，比如图片加载的资源文件。</p>
<p>所以我们先安装html-loader</p>
<p>yarn add html-loader @1.3.2</p>
<p>配置，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: /.html$/,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &#x27;html-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">        //仅仅限制版本号。1.3.2</span><br><span class="line">            attributes: &#123;</span><br><span class="line">                list: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        tag: &#x27;img&#x27;,</span><br><span class="line">                        attribute: &#x27;src&#x27;,</span><br><span class="line">                        type: &#x27;src&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        tag: &#x27;a&#x27;,</span><br><span class="line">                        attribute: &#x27;href&#x27;,</span><br><span class="line">                        type: &#x27;src&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过配置attributes的方式，对需要加载资源的标签，进行处理。。</p>
<h5 id="如何自己开发一个loader出来。。"><a href="#如何自己开发一个loader出来。。" class="headerlink" title="如何自己开发一个loader出来。。"></a>如何自己开发一个loader出来。。</h5><p><strong>weboack</strong>除了给我们提供了许许多多的loader以外，我们也可以开发自己的loader来进行使用。。</p>
<p>比如，我们需要把markdown 文件，在webpack打包的时候，转化为html，并且渲染到页面上。。</p>
<p>首先第一步，新建一个markdown-loader.js文件。在src目录下。。<br>然后安装yarn add marked</p>
<p>然后在weback-config.js下，配置loader<br>webpack-config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">               test: /.md$/,</span><br><span class="line">               use: [</span><br><span class="line">                   &#x27;./src/markdown-loader.js&#x27;,</span><br><span class="line">               ]</span><br><span class="line">           &#125;</span><br><span class="line">       ],</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>use,可指定加载相对路径的loader</p>
<p>//source 是webpack在打包过程中，输入的md文件<br>// return 出去必须是，js语法。通过<strong>module.exports</strong>或者 <strong>return export default</strong> 输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入 marked</span><br><span class="line">const marked = require(&#x27;marked&#x27;);</span><br><span class="line">module.exports = (source) =&gt; &#123;</span><br><span class="line">    const html = marked.marked(source);</span><br><span class="line">    return ` module.exports = $&#123;JSON.stringify(html)&#125;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>然后就能在dist下的markdown 被转换到html到，bundle.js当中了。</p>
<p>当然loader之间可以相互配合使用，比如，markdown文件被转换到，html之后，我们也可以不选择，return export default html。</p>
<p>我们也可以交给，html-loader来处理。</p>
<hr>
<p>markdown-loader 和 html-loader 配合使用。。</p>
<p>mackdown-loader.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const marked = require(&#x27;marked&#x27;);</span><br><span class="line">module.exports = (source) =&gt; &#123;</span><br><span class="line">    const html = marked.marked(source);</span><br><span class="line">    return html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>webpack-config.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /.md$/,</span><br><span class="line">            use: [</span><br><span class="line">                &#x27;html-loader&#x27;,</span><br><span class="line">                &#x27;./src/markdown-loader.js&#x27;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="webpack-Plugins"><a href="#webpack-Plugins" class="headerlink" title="webpack Plugins"></a>webpack Plugins</h4><p>webpack plugins的功能可以，让我们在打包的时候，webpack运行到某个阶段的时候，帮我们做一些事情。</p>
<p>比如，在dist文件夹下面，生成html，比如，每次打包之前，清空dist文件夹。</p>
<p>例子如下，</p>
<p>安装CleanWebpackPlugin，每次打包的dist文件夹的时候，把dist文件下下面上次打包的资源文件清空。</p>
<p>yran add clean-webpack-plugin –dev</p>
<p>webpack-config.js下面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">    ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再比如，dist文件夹下面每次打包发布资源的时候，都没有html页面。</p>
<p>这个时候，我们需要html-webpack-plugin，来使用。</p>
<p>yran add html-webpack-plugin –dev</p>
<p>webpack-config.js</p>
<p>template可以指定html模版作为，HtmlWebpackPlugin输出的index.html模版。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: &#x27;Webpack Plugin Sample&#x27;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            viewport: &#x27;width-device-width&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &#x27;./src/template.html&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>webpack初学</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现网站的哀悼模式</title>
    <url>/blogs/2022/12/06/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%93%80%E6%82%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">body&#123;</span><br><span class="line"> filter: grayscale(100%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChat1d1ad09b1ab494616acafe5348a975e4.png" alt="黑白效果图"></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6844904114053185544">明天全国哀悼日，一段css让全站变灰</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">mdn</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Data URL</title>
    <url>/blogs/2022/12/06/DataUrl%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h4 id="什么是Data-URL"><a href="#什么是Data-URL" class="headerlink" title="什么是Data URL"></a>什么是Data URL</h4><p>Data URL指的是，前缀为data:协议url。<br>现代浏览器将 <strong>Data URL</strong> 视作唯一的不透明来源，而不是可以用于导航的 URL，<br>不透明质指的是，在浏览器url上，输入上，一段比如<a href="https://baidu.com,我们可以看到这段url最终是要访问那里,而/">https://baidu.com,我们可以看到这段url最终是要访问那里，而</a> <strong>Data Url</strong>，则不是不透明，又长又臭，我们看不出这段url是什么。</p>
<h5 id="Data-URL语法"><a href="#Data-URL语法" class="headerlink" title="Data URL语法"></a>Data URL语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA2CAYAAAB3Ep8CAAAAAXNSR0IArs4c6QAABTtJREFUaEPVW1Fy4kYU7CflI1W4Kr5B2BME2wcInCDrE8ScIMbs/9oHAPkGi08Q7wnMBWDxDZwb2FUmlY/VvK0RiGAxM280SID5RTNMt1pv+vUIQvCndYwo+gyiFoB28DShA5mfQTQD4x4qvQNmzyFTUcggoNVGFH0BUTNsfMWjGDOotAvMZmVnDiCg1UYcP5T9odqv14pQqlOWhJIEtFqIogcQHdcOKOQHAkgoQcCBg88JY36CUie+NcGTgFYTUfTtYO98US2LmqAfB7EwehCgq338AIKu9uZPmmrGSxegEJWvxsSnFwB9sc7hSYJAgAd4cBfpdLQVmNDBEgnAGOmk45reQcCBg89RRafXIPpsVwKPoKZd2/d2AqJTvc9f2Nnb450vLio6G4HwZwgJZgIk8Iw7qImDnFBNbzFOJuEGanpd/IVNAt4j+BxVfHYP4I8yqn1LgFRUDvHOv0Gb9SdjEP3mS8L/BIjg+RFqat8Kt1BvtUM9SEhxDky0WrAkQPD3rMGrto+xqBZM6GwCCWuWmYDsYu3yzJ3duwOfk6atezwG4RcjjZlRmpwQotNLECWWi16g0ub7ufNFFAIJadrRBNyC6K8NAhgavJb9bi1uqOqt4xwkMN8Q7FvHPdLJeeXr2ceE8ZnOLzZTq4wAl5VkNpoHJ4YkOW4AzXmvV6lyjpKk/drrjUvz5/Q13NVFsIU4/ua7b7oWcDQYrHw5AzMQdbclopEkLWLWd1CHMM/M3Jv3+37Nl9QnpOmHxTZoqwM52rV900ZAYzC4INpoT5+/E5381+s9lb5zAArgV1Mopc7//fQp28etH9nX9KCmt7kPcDsoj6jpaDjU8vy9uCCthDlRB72eGE6sj/05SZo/MWtlmuK3r69XVx/t6M8+IsbfDnq+Ip1k49escOYHtGx/NW+JWeiogw/j3bQRoOcqTYKuI8wP+vk0rYWBu/nVlaUZE6K7gq8pNEM+5sEcNekihcWzauGPR/N+39qXrwYJ4PV134k+mB8rIbpj/gdKtdZ9jaEdDifBUgdW2JhlEhrD4Yhg7+2ZuWsugkKAY/E15jxALiDWlMUDgK7ityaZeIytFHyhBhSWVC8JG0Aag8El2Sz5oo7Yn3spw3Dklu5QVEpZHBM3BoMZufpyok5ubMRHpybwbgXkggglQRczpcYOEp6ZqEN6m3MXz8d5v2/OIUSVytGdx7lAZpT09mhPWWznAklyfKTUE4jMLSmQewPjURszP86jqG30EBWA91NApgT/gKFY3DI3p5SOqWwk2PbNl9coapoNlGDfs73eL73yU8CChCaieGYPGOxncktL6+g3Chwwv3AUtc19RDmj43LLJRSQT1OfR1hfKBOdWMAL6VWWYWij4917lFDAigTp/QDrcZRU7TPbXLHRqVgBy+nEAmQ/jnKZHTt4ALZQI0eYZha9dF4QoIDlL0q9tiNMMZFQl9GpRwHbegTd6w+HuhdfZJHMN6/9/saxVfbdFkRL4AOKoGFK6TjKI0yxLlR81GSjI5EQ/gisZg73CO7F+YcaEkjX9xUQsDJKwWHK5gKr3et3QEBGgsdJjM97O+VDjQNQwPZGaTFDWKhxQATo/Vp6ecnmEXYPvppdwER/CAlbhBqHpYAQj7An8PUpoAwJ2bXO9/1qfR+pom3QIUIpTHHpdwev5NRPgBSm2AgoEWocZg14syohTCki2OFbKTtQgKdHyC9bHGCUCjXegQJWJLjDlD28lbJDBSxJsHmEPYCvfxu0ajNLda/B+rWV5Z+f0vSyTJa3jezXx/4AhsQjITcm0vsAAAAASUVORK5CYII=</span><br><span class="line">    &quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>mediatype</strong>为image/png，指的是，文件的类型。<br>base64为64位字符表示二进制的流。</p>
<p>Data URL，减少http请求次数</p>
<p><a href="https://imgse.com/i/zyBco6"><img src="https://s1.ax1x.com/2022/12/05/zyBco6.jpg" alt="zyBco6.jpg"></a></p>
<p>Data URL，会占html文件的内存空间。<br><a href="https://imgse.com/i/zyBco6"><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog2.jpg" alt="zyBco6.jpg"></a></p>
<p>Data URL，加载的图片，不会被缓存下来，每次访问图片都得再下载一次。除非放入css当中缓存下来。</p>
<p>http加载的图片，只需要加载一次，就可以在页面上使用了，而每次使用Data URL作为图片，都会被重新加载。</p>
<p>base64 编码后的图片会比原来的体积大三分之一左右。</p>
<p>使用Data URL方式的Demo在渲染时会比不使用 多消耗53%左右的CPU资源，内存多出4倍左右，耗时平均高出24.6倍 。由此可见，使用Data URl方式还是需要更多的考量，在可接受的范围内适量使用。</p>
<p>Data URL的适用场景。</p>
<p>减轻http并发，减少http请求数量，加载icon的时候，或者作为css文件，引入，iconfont的时候。非常好用。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>使用Data URL，对页面进行优化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用es module模块化编程</title>
    <url>/blogs/2022/11/01/%E5%85%B3%E4%BA%8Ees%20module%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>很长的一段时间内，我以为，es modules的关键字import，export,只能在vue里面，使用，是因为webpack，这样的打包工具，才能得已实现的。<br>甚至让我觉得，原生js不行的原因就是因为，不支持es moduls。</p>
<p>陷入了一定的误区，这篇文章，来修正我的认知错误。</p>
<h5 id="原生js使用es-module进行模块化。"><a href="#原生js使用es-module进行模块化。" class="headerlink" title="原生js使用es module进行模块化。"></a>原生js使用es module进行模块化。</h5><p>使用script 加载js文件的时候 <strong><u>type = ‘module’</u></strong> 就可以开启模块化。</p>
<p><a href="https://imgse.com/i/xTjKx0"><img src="https://s1.ax1x.com/2022/11/01/xTjKx0.md.png" alt="xTjKx0.md.png"></a></p>
<h5 id="注意，es-module，默认开启的严格模式。我来证明给您看。"><a href="#注意，es-module，默认开启的严格模式。我来证明给您看。" class="headerlink" title="注意，es module，默认开启的严格模式。我来证明给您看。"></a>注意，es module，默认开启的严格模式。我来证明给您看。</h5><p><a href="https://imgse.com/i/xTj92t"><img src="https://s1.ax1x.com/2022/11/01/xTj92t.png" alt="xTj92t.png"></a></p>
<p><a href="https://imgse.com/i/xTjVaQ"><img src="https://s1.ax1x.com/2022/11/01/xTjVaQ.png" alt="xTjVaQ.png"></a></p>
<p>看吧，控制台上this是 undefined</p>
<h5 id="原生js，使用import，export"><a href="#原生js，使用import，export" class="headerlink" title="原生js，使用import，export"></a>原生js，使用import，export</h5><p>在上图的index.html文件下的index.js export抛出，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p>
<p>在test import，引入。<br><a href="https://imgse.com/i/xTjnGn"><img src="https://s1.ax1x.com/2022/11/01/xTjnGn.png" alt="xTjnGn.png"></a></p>
<p>控制台，打印的结果是，{a: 11}</p>
<h5 id="es-module，加载是通过cors进行的。"><a href="#es-module，加载是通过cors进行的。" class="headerlink" title="es module，加载是通过cors进行的。"></a>es module，加载是通过cors进行的。</h5><p>如果 <strong><script type='module' src=''> </script></strong><br>如果，这里的 <strong>src</strong>加载的是服务器资源的话，如果资源不支持cors的话，会被浏览器拦截。</p>
<p>例子如下，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p>
<p>支持，cors 加载的资源，type = ‘module’ 会被浏览器所加载，不支持cors的，会被浏览器拦截，这点服务端需要注意。</p>
<p><a href="https://imgse.com/i/xTj1qU"><img src="https://s1.ax1x.com/2022/11/01/xTj1qU.png" alt="xTj1qU.png"></a></p>
<p>cors，不支持文件的访问，所以，必须使用，http，serve的方式进行访问。</p>
<p><strong>使用，文件访问导致的后果</strong></p>
<p><a href="https://imgse.com/i/xTjlrT"><img src="https://s1.ax1x.com/2022/11/01/xTjlrT.png" alt="xTjlrT.png"></a></p>
<h5 id="es-module，自带脚本延迟效果"><a href="#es-module，自带脚本延迟效果" class="headerlink" title="es module，自带脚本延迟效果"></a>es module，自带脚本延迟效果</h5><p>当页面，加载完毕后，才会加载，es module脚本。<br><a href="https://imgse.com/i/xTjQMV"><img src="https://s1.ax1x.com/2022/11/01/xTjQMV.png" alt="xTjQMV.png"></a></p>
<p>当所有的，非es module加载完毕后，才能加载es module模块。</p>
<p>总结，<br>es module的特性是，<br>1，默认就是严格模式<br>2，每个module模块，都拥有私有的作用域。<br>3，只支持cors，加载。本地必须开启 web serve<br>4，自带延迟效果</p>
<h5 id="关于import-export-一些小知识。"><a href="#关于import-export-一些小知识。" class="headerlink" title="关于import export 一些小知识。"></a>关于import export 一些小知识。</h5><p>我们可以使用，export，到处一些变量方法，也可以，export，设置默认导出的方法。</p>
<p><a href="https://imgse.com/i/xTjEVg"><img src="https://s1.ax1x.com/2022/11/01/xTjEVg.jpg" alt="xTjEVg.jpg"></a></p>
<p>接收默认到处的值</p>
<p><a href="https://imgse.com/i/xTjiKf"><img src="https://s1.ax1x.com/2022/11/01/xTjiKf.png" alt="xTjiKf.png"></a></p>
<p>接收默认导出的值</p>
<p><a href="https://imgse.com/i/xTjmPs"><img src="https://s1.ax1x.com/2022/11/01/xTjmPs.png" alt="xTjmPs.png"></a></p>
<p><strong>as 关键字，修改默认导出的值</strong></p>
<p>export <strong>as关键字修改 变量名</strong></p>
<p><a href="https://imgse.com/i/xTj8ZF"><img src="https://s1.ax1x.com/2022/11/01/xTj8ZF.png" alt="xTj8ZF.png"></a></p>
<p><a href="https://imgse.com/i/xTjGa4"><img src="https://s1.ax1x.com/2022/11/01/xTjGa4.png" alt="xTjGa4.png"></a><br>import <strong>as修改接收参数的变量名</strong></p>
<h5 id="export-导出的并不是一个对象-import-引入的也不是个对象的解构。"><a href="#export-导出的并不是一个对象-import-引入的也不是个对象的解构。" class="headerlink" title="export 导出的并不是一个对象 import 引入的也不是个对象的解构。"></a>export 导出的并不是一个对象 import 引入的也不是个对象的解构。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">export &#123;</span><br><span class="line">    num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然export后面跟着 {} 看起来很像对象， { name },看起来很像es6，字面量的写法。</p>
<p>import 在这里 **{}**，就像使用对象字面量解构一样，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; num &#125; from &#x27;./test.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>export {}</strong> 和 <strong>import {}</strong> 是 es modulc的固定语法。</p>
<p>export 导出的只是，内存地址。<br>export 导出的，是常量。只能在 export 内部修改。</p>
<p><strong>例子如下</strong></p>
<p>导出num</p>
<p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p>
<p><a href="https://imgse.com/i/xTjNGR"><img src="https://s1.ax1x.com/2022/11/01/xTjNGR.png" alt="xTjNGR.png"></a></p>
<p>控制台报错，index.js:4 Uncaught TypeError: Assignment to constant variable.<br>    at index.js:4:4</p>
<p>因为，我们import引入的，<strong>num</strong> 是个常量。无法在外部，对 import 引入的 num进行修改。</p>
<p><strong>那么，怎么样导入，一个字面量对象呢？</strong></p>
<p>使用 <strong>export default</strong></p>
<p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p>
<h5 id="import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"><a href="#import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。" class="headerlink" title="import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"></a>import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。</h5><p>如果export 导入了很多属性。我们可以使用import * 把所有的导出全部接收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">let name = &#x27;张三&#x27;;</span><br><span class="line">let age = 12;</span><br><span class="line">let sigin = &#x27;为什么&#x27;</span><br><span class="line">export &#123;</span><br><span class="line">    num,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sigin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import * as module from &#x27;./test.js&#x27;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure>

<p>import * as module 导入全部的要导出的模块。</p>
<p>试想，我们有一个这样的需求，根据判断条件，来决定要导入，那个模块。</p>
<p>import 必须要在最外层，最顶层的作用域当中。不能嵌套在if，或者funtion当中。</p>
<p>es modulc，提供了一个，<strong>import</strong>函数，来帮助我们动态的导入模块。而且，import(),本身是一个promise函数。</p>
<p><a href="https://imgse.com/i/xTjFr8"><img src="https://s1.ax1x.com/2022/11/01/xTjFr8.png" alt="xTjFr8.png"></a></p>
<p>这样通过，then,那么就能读取到模块了。</p>
<p>import 可以导入一个，url链接模块<br><a href="https://imgse.com/i/xTju2q"><img src="https://s1.ax1x.com/2022/11/01/xTju2q.png" alt="xTju2q.png"></a></p>
<p>import 导出默认成员与，命名成员<br><a href="https://imgse.com/i/xTjkqS"><img src="https://s1.ax1x.com/2022/11/01/xTjkqS.png" alt="xTjkqS.png"></a></p>
<p>总结，es module，</p>
<ol>
<li>在原生js当中使用，script标签，type应该使用，module。module默认就在严格模式环境下，this不可能指向全局。</li>
<li>每个模块都拥有了独立的，私有的作用域。</li>
<li>module加载，模块，会存在cors问题，需要服务端专门设置，本地必须开启，web sever</li>
<li>type = module后，会存在延迟效果，等页面资源加载完毕后，再去加载。</li>
</ol>
<p>总结，import的特性</p>
<ol>
<li>import {} 并非对象的解构，而是语法就是这样的。</li>
<li>import，导入的属性，只可以读取。import导入的是常量，无法修改。</li>
<li>import * model from 可以把，所有导出的属性，全部导入到一个对象里面。</li>
<li>import，可以导入url模块，</li>
<li>import必须在顶部，不可以在函数，条件语句下面。</li>
<li>import()，可以动态导入，<strong>import</strong>默认本身就是一个promise方法。</li>
<li>import as 可以更换导入的属性别名。</li>
<li>import num，{age,age1} from ‘../../‘可以导入，默认的成员与命名的成员。</li>
</ol>
<p>总结，export的特性</p>
<ol>
<li>export {} 这是语法，抛出的不是一个，字面量对象，export default是抛出对象。</li>
<li>export 抛出去的值是内存地址的引用，值，只能在export模块里面修改。</li>
<li>as 可以修改默认要导出的值的别名。</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JavaScript的严格模式那些事</title>
    <url>/blogs/2022/06/08/JavaScript%E5%BD%93%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>JavaScript通常情况下隐式运行在正常模式-“Sloppy Mode”，ES5及其版本之后，javaScript可以显示运行在严格模式-“Strict Mode”！在严格模式下。可以减少我们编写不安全的JavaScript代码，获得更加清大的错误检查机制。为了向后兼容，严格模式需要我们手动开启！</p>
</blockquote>
<ol>
<li>变量必须先声明后使用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">console.log(&quot;🚀 ~ file: index.js ~ line 4 ~ a&quot;, a)</span><br><span class="line">a = 11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数型参不允许重复</li>
</ol>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(x, y, y) &#123;</span><br><span class="line">   return x + y + y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(1, 2, 1));//Uncaught SyntaxError: Duplicate parameter name not allowed in this context (at index.js:4:21)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(x, y, z) &#123;</span><br><span class="line">   return x + y + z;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(1, 2, 1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数的arguments 在严格模式和非严格模式下也有区别。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">   console.dir(arguments)</span><br><span class="line">   console.log(arguments.callee, arguments.caller);</span><br><span class="line">   /**</span><br><span class="line">    * @非严格模式</span><br><span class="line">   0: (4) [1, 2, 3, 4]</span><br><span class="line">   callee: ƒ test()</span><br><span class="line">   length: 1</span><br><span class="line">   Symbol(Symbol.iterator): ƒ values()</span><br><span class="line">   [[Prototype]]: Object</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @严格模式</span><br><span class="line">    * 0: (4) [1, 2, 3, 4]</span><br><span class="line">      callee: [Exception: TypeError: &#x27;caller&#x27;, &#x27;callee&#x27;, and &#x27;arguments&#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them at Arguments.s (&lt;anonymous&gt;:1:83)]</span><br><span class="line">      length: 1</span><br><span class="line">      Symbol(Symbol.iterator): ƒ values()</span><br><span class="line">      get callee: ƒ ()</span><br><span class="line">      set callee: ƒ ()</span><br><span class="line">      [[Prototype]]: Object</span><br><span class="line">   */</span><br><span class="line">&#125;</span><br><span class="line">test([1, 2, 3, 4]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>严格模式下的arguments消失了。</p>
<p>arguments.callee, arguments.caller</p>
<h4 id="width不可用"><a href="#width不可用" class="headerlink" title="width不可用"></a>width不可用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">   name: &#x27;使用with读取对象属性&#x27;</span><br><span class="line">&#125;</span><br><span class="line">with (obj) &#123;		//严格模式下将禁用with关键字</span><br><span class="line">   console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="八进制数不可用"><a href="#八进制数不可用" class="headerlink" title="八进制数不可用"></a>八进制数不可用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">console.log(010 === 8)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="严格模式下的this指向"><a href="#严格模式下的this指向" class="headerlink" title="严格模式下的this指向"></a>严格模式下的this指向</h4><p>请注意：这里的函数时非方法函数！因为方法与对象挂钩，有具体的this!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line">function foo() &#123;</span><br><span class="line">   console.log(this)//undefined</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>总结</p>
<ul>
<li>js严格模式下 必须要显式声明变量才允许使用</li>
<li>width 方法不可用</li>
<li>arguments少了一些东西</li>
<li>八进制不可用</li>
<li>非方法函数this指向undefined</li>
<li>形参不允许 重复定义</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>严格模式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的去console</title>
    <url>/blogs/2022/06/08/%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8Cconsole/</url>
    <content><![CDATA[<h4 id="不要再去console一把梭了。"><a href="#不要再去console一把梭了。" class="headerlink" title="不要再去console一把梭了。"></a>不要再去console一把梭了。</h4><h5 id="使用console-time-console-timeEnd"><a href="#使用console-time-console-timeEnd" class="headerlink" title="使用console.time,console.timeEnd"></a>使用console.time,console.timeEnd</h5><p>可以获取到代码的执行时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.time(1);</span><br><span class="line">console.timeEnd(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="Console-assert-如果结果是true-就不会打印出来。"><a href="#Console-assert-如果结果是true-就不会打印出来。" class="headerlink" title="Console.assert()如果结果是true 就不会打印出来。"></a>Console.assert()如果结果是true 就不会打印出来。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let len = 10;</span><br><span class="line">console.assert(len !== 10, &#x27;失败&#x27;);</span><br></pre></td></tr></table></figure>

<h5 id="console-trace对栈的追踪"><a href="#console-trace对栈的追踪" class="headerlink" title="console.trace对栈的追踪"></a>console.trace对栈的追踪</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.trace(test)</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="console-table-打印出来一个表格，比较适合对-引用类型的数据"><a href="#console-table-打印出来一个表格，比较适合对-引用类型的数据" class="headerlink" title="console.table 打印出来一个表格，比较适合对 引用类型的数据"></a>console.table 打印出来一个表格，比较适合对 引用类型的数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let tableData = [&#123;</span><br><span class="line">    date: &#x27;2016-05-02&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1518 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-04&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1517 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-01&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1519 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-03&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1516 弄&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">console.table(tableData)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据的展示会更加直观。。</p>
<h5 id="对log进行分级"><a href="#对log进行分级" class="headerlink" title="对log进行分级"></a>对log进行分级</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">console.info(1);</span><br><span class="line">console.debug(1);</span><br><span class="line">console.warn(1);</span><br><span class="line">console.error(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>像百度一样骚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;每一个星球都有一个驱动核心，\n每一种思想都有影响力的种子。\n感受世界的温度，\n年轻的你也能成为改变世界的动力，\n百度珍惜你所有的潜力。\n你的潜力，是改变世界的动力！\n\n&quot;), console.log(&quot;%c百度2022校园招聘简历投递：https://talent.baidu.com/external/baidu/campus.html&quot;, &quot;color:red&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript标签页通讯问题</title>
    <url>/blogs/2022/06/08/js%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h4 id="浏览器中的标签页如何通讯"><a href="#浏览器中的标签页如何通讯" class="headerlink" title="浏览器中的标签页如何通讯"></a>浏览器中的标签页如何通讯</h4><ol>
<li>标签页必须是同源的页面，必须是同源的页面。</li>
<li>使用BroadcastChannel。</li>
</ol>
<p>例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let channel = new BroadcastChannel(&#x27;test&#x27;);</span><br><span class="line">channel.postMessage(&#x27;hello,word&#x27;)</span><br><span class="line">channel.onmessage = (res =&gt; &#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">&#125;)</span><br><span class="line">channel.onmessageerror = (err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实例话BroadcastChannel<br>postMessage方法发送数据</p>
<p>onmessageerror 监听错误信息<br>onmessage 获取消息</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的Promise</title>
    <url>/blogs/2022/05/30/%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>关于ES6中<strong>promise</strong>的使用，我已经熟练掌握了不少。至少能顺顺利利的写上一个异步方法。<br>但是对promise的理解使用 并没有得到提高。</p>
<p>比如，有这么一个场景，我需要发送5个接口。拿到5个接口里面的数据，且必须五个接口全部请求完毕，有结果了，我才能拿到。因为接口的响应时间不一样的，而且这个业务里面不想，a接口好了，去请求b接口。而是abcde5个接口一起请求。</p>
<p>这就是我，重新细读promsie的原因。</p>
<h5 id="关于promise的特点。"><a href="#关于promise的特点。" class="headerlink" title="关于promise的特点。"></a>关于promise的特点。</h5><ol>
<li><p>promise有3个状态， pending（进行中），和fulfilled（已成功），和rejected（已失败）。只有异步操作才能决定promise当前是哪一种状态，任何操作都无法改变</p>
</li>
<li><p>promsie的状态一旦改变就不可能逆转。比如从pending状态，到rejected状态。这个状态，就会凝固，不会再改变了，这个就称为resolved（已定型）。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">primise-&gt;&gt;fulfilled或rejected:异步操作才能决定promise当前的状态。</span><br><span class="line">fulfilled或rejected-&gt;&gt;primise:状态处于resolved状态凝固不可改变。</span><br></pre></td></tr></table></figure>



<h5 id="关于promise的一些缺点。"><a href="#关于promise的一些缺点。" class="headerlink" title="关于promise的一些缺点。"></a>关于promise的一些缺点。</h5><ul>
<li>promise一旦建立就无法取消。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;11&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码里面的log会立刻执行。</p>
<ul>
<li>promise异步执行的时候，我们无法知道他在哪一步。</li>
</ul>
<h5 id="promise的then"><a href="#promise的then" class="headerlink" title="promise的then"></a>promise的then</h5><p>primise的then方法，能够接受2个回调函数做参数使用。第一个是，当pending状态改变为，fulfilled调用，另一个是pending状态改变为，reject调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(11);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(function (res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="promise-catch-只能接受一个回调函数做参数使用。"><a href="#promise-catch-只能接受一个回调函数做参数使用。" class="headerlink" title="promise catch 只能接受一个回调函数做参数使用。"></a>promise catch 只能接受一个回调函数做参数使用。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(11);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(function (res) &#123;</span><br><span class="line">    console.log(res);//没有打印结果</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="如果promise里面有同步执行的代码呢？？？"><a href="#如果promise里面有同步执行的代码呢？？？" class="headerlink" title="如果promise里面有同步执行的代码呢？？？"></a>如果promise里面有同步执行的代码呢？？？</h5><p>我们可以来看一段代码的执行顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function promise(time) &#123;</span><br><span class="line">    console.log(&#x27;预计执行时间:&#x27;, time / 1000);</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;欢迎来到promise:&#x27;);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;promise结果:resolve&#x27;);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;codeing&#x27;);</span><br><span class="line">promise(3000).then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;执行结束&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>正确的执行顺序应该是：</p>
<ol>
<li>codeing</li>
<li>预计执行时间</li>
<li>欢迎来到promise</li>
<li>promise结果</li>
<li>执行结束。</li>
</ol>
<p>promise异步操作执行的时候，除了pending 状态发生改变之前，都是同步的代码。<br>当定时器结束，异步操作的状态改变。我们通过then 或者catch来回调promise的结果。</p>
<p>使用promise异步加载图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function imgaeLoad(src) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let image = new Image();</span><br><span class="line">        image.src = src;</span><br><span class="line">        image.onload = function () &#123;</span><br><span class="line">            resolve(&#x27;succss&#x27;);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = function () &#123;</span><br><span class="line">            reject(&#x27;error&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">imgaeLoad(&#x27;https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/04/26/6267bb50cad26.jpeg&#x27;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="关于promise的异步操作的结果是返回另一个异步操作"><a href="#关于promise的异步操作的结果是返回另一个异步操作" class="headerlink" title="关于promise的异步操作的结果是返回另一个异步操作"></a>关于promise的异步操作的结果是返回另一个异步操作</h5><p>如果调用resolve或者reject函数带有参数，那么参数会被传递到回调函数。<br>reeject通常的参数是new Error的参数实例，无论reslove，还是reject来说，都有可能接受一个promise实例作为参数。</p>
<p>比如下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        reject(new Error(&#x27;fail&#x27;))</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(p1)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>p2的resolve的方法，将p1作为参数，即一个异步操作的结果返回另一个异步操作。</p>
<p>这个时候p1的状态就会传递给p2，如果p1，在pending，那么p2会等待。直到p1的状态从pending改变到resolved，或者rejectd，这个时候。p2的回调函数会马上执行。。</p>
<p>白话文就是，如果p2的异步操作把p1作为参数的话。那么p2的回调函数的状态就由p1异步操作来决定。</p>
<p>再浅一点，p2的异步操作如果把p1作为参数的话。那么p1的异步操作会执行，且他的状态影响着p2回调函数的状态。又或者说p1的状态结果就是p2的。</p>
<p>对于promise 方法来说，一旦状态从resolved 到 rejectd后。接下来的操作，直接在then，和catch里面操作就行了。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段方法会导致，即便是promise 状态已经改变了，log方法也还是执行了。所以一旦状态从resolved 到 rejectd后，一定要return出去。</p>
<h5 id="关于promise的链式调用。"><a href="#关于promise的链式调用。" class="headerlink" title="关于promise的链式调用。"></a>关于promise的链式调用。</h5><p>曾经做过微信服务商入驻哪一块。需要调上传接口，上传图片，然后在上传给图片给微信，然后再去给后端。</p>
<p>要发送4个请求，其中错了一个之后，就算失败。<br>于是代码就成了这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promiseA().then(()=&gt;&#123;</span><br><span class="line">    promiseB().then(()=&gt;&#123;</span><br><span class="line">            promiseC().then(()=&gt;&#123;</span><br><span class="line">                 promiseD().then(()=&gt;&#123;</span><br><span class="line">        </span><br><span class="line">                &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是promise 是可以使用链式调用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结其他来是，链式调用可以避免回调地狱的产生，你需要then下去就好了。<br>无非就promiseA好了那就去调用promiseB。如果失败了直接在catch捕捉就可以了。</p>
<p>当然如果promiseA失败了，catch捕捉到的肯定是，promiseA的catch。</p>
<p>我们只需要在第五个then下面，进行操作就可以了。</p>
<p>好处是。catch捕捉一次就够了。</p>
<h5 id="关于promise的catch"><a href="#关于promise的catch" class="headerlink" title="关于promise的catch"></a>关于promise的catch</h5><ol>
<li>promise的catch具有冒泡性。</li>
</ol>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段方法会导致，即便是promise 状态已经改变了，log方法也还是执行了。所以一旦状态从resolved 到 rejectd后，一定要return出去。</p>
<h5 id="关于promise的链式调用。-1"><a href="#关于promise的链式调用。-1" class="headerlink" title="关于promise的链式调用。"></a>关于promise的链式调用。</h5><p>曾经做过微信服务商入驻哪一块。需要调上传接口，上传图片，然后在上传给图片给微信，然后再去给后端。</p>
<p>要发送4个请求，其中错了一个之后，就算失败。<br>于是代码就成了这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promiseA().then(()=&gt;&#123;</span><br><span class="line">    promiseB().then(()=&gt;&#123;</span><br><span class="line">            promiseC().then(()=&gt;&#123;</span><br><span class="line">                 promiseD().then(()=&gt;&#123;</span><br><span class="line">        </span><br><span class="line">                &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是promise 是可以使用链式调用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不管是say1 到say5promise方法，只要有一个错误都会被catch捕捉到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>且尽可能不要尝试在then方法里面捕捉，错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say1().then(function (value) &#123;</span><br><span class="line">    console.log(&#x27;succss&#x27;);</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // failure</span><br><span class="line">    console.log(&#x27;error&#x27;);</span><br><span class="line">&#125;)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>promise方法的任何报错都会导致，promise进入rejected状态，被catch捕捉到错误信息。</p>
<p>比如我们人为制造一些报错信息。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">        let a;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say1().then(succss =&gt; &#123;</span><br><span class="line">    console.log(succss);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本身promise应该是resolved的。因为报错信息，导致变成rejected，然后被catch捕捉。</p>
<p>promise 会把报错信息给吞掉。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const someAsyncThing = function () &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        // 下面一行会报错，因为x没有声明</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">someAsyncThing().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">&#125;, 2000)//11</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在promise中如果没有使用catch函数去接受捕捉错误信息的话，promsie对象抛出错误，不会传递到外层的代码。也不会有任何反应。</p>
<p>在看下个例子，当promise已经结束了，下轮事件循环再抛出错误，这个时候，promise已经执行完毕了，所以这个错误是promise函数体外抛出的，会冒泡到最外层。导致无法捕获该错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let test = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&#x27;succss&#x27;);</span><br><span class="line">    setTimeout(function () &#123; throw new Error(&#x27;test&#x27;) &#125;, 0)</span><br><span class="line">&#125;)</span><br><span class="line">test.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>promise 可以运行catch函数方法，再去运行，then函数方法。如果没有报错会绕过catch，运行then方法指定的回调函数。。</p>
<p>如果存在报错，catch捕捉错误后继续执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;errors:&#x27;, error);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    alert(&#x27;11&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>没有报错，catch被绕过，直接执行then。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1(x = 1) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;errors:&#x27;, error);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>catch内部也会报错。如果catch报错了，在后面再写一个catch捕获错误信息就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return p1();</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    y + 2;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="promise-finally方法。"><a href="#promise-finally方法。" class="headerlink" title="promise finally方法。"></a>promise finally方法。</h5><p>不管promise的状态如何，他都会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(0);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;).finally(e =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>then回调函数与finally函数，分别console.log出来了，0和1</p>
<h5 id="promise-all"><a href="#promise-all" class="headerlink" title="promise all"></a>promise all</h5><p>假设，我是说假设，我们有3个promise方法，p1，p2，p3。<br>让p1，p2，p3，几乎同时发送，p1，p2，p3全部是resloved，那就then回调函数捕获。不然就使用，catch捕获。。</p>
<p>我们该怎么去写呢。</p>
<p>这个时候就可以使用promise all来处理。</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            resolve(&#x27;p3成功&#x27;);</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1(), p2(), p3()]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.all（）把p1-p3函数全部放入。</p>
<p>等到p1-p3函数的promise状态全部都为resovled 或者rejected的话。promise.all的状态是rejected或者resovled</p>
<p>promise.all的成员可以不是数组，但是必须具有Iterator，且每个成员都是返回了promise实例。</p>
<p>如果primise.all内的promise实例，catch捕获了错误信息，那么promise.all，的状态不会受rejected的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            reject(new Error(&#x27;p3失败&#x27;));</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1(), p2(), p3().catch(err =&gt; &#123; console.log(err); &#125;)]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//因为p3函数使用catch函数捕获了，报错信息。所以promise.all的 没有捕获到错误，导致还是then回调函数正常使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="promise的race方法。"><a href="#promise的race方法。" class="headerlink" title="promise的race方法。"></a>promise的race方法。</h5><p>promise.race 函数的特点是，假设，我们拥有，p1-p3多个promise函数，如果p2promise方法，状态首先改变了，那么会改变promise.race的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            reject(new Error(12121));</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.race([p1(), p2(), p3()]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和promise.all不同，里面的成员必须是promise实例。promise.race，成员什么参数都可以接收。。</p>
<p>并且，promise.race()的成员里非primise实例的成员，会立马，触发promise.race的then回调函数。</p>
<h5 id="promise-race，all的区别。"><a href="#promise-race，all的区别。" class="headerlink" title="promise race，all的区别。"></a>promise race，all的区别。</h5><p>promise all，p1-p4….promise方法，同时执行，全部成功了，会成功，一个失败，那就是失败咯，all方法的成员不一定非得是数组，但是一定要有，有Iterator接口。</p>
<p>promise race，p1-p4…..promise方法，promis.race的实例的状态是，p1-p4promise函数中那个函数的结果改变了，那么改变的状态就是promise.race的状态。</p>
<h5 id="promise-allSettled方法。"><a href="#promise-allSettled方法。" class="headerlink" title="promise allSettled方法。"></a>promise allSettled方法。</h5><p>假设，我们有p1-p4，4个promise实例，不管成功与否，我都想让他走完，又或者（等待所有的promise实例，全部结束），再去做一些操作。</p>
<p>promise.all的前提是，p1-p4实例，必须要走完，才能进行操作，如果但凡有个失败，那就直接报错，不管另外的promise是否结束。。</p>
<p>alisettled不是这样的，promise多个实例，都会执行，并且全部执行结束了promise.allsettled的promise状态才改变，并且then回调函数下面，我们会拿到所有promise的结果，以对象的形式</p>
<h5 id="关于promise的any"><a href="#关于promise的any" class="headerlink" title="关于promise的any"></a>关于promise的any</h5><p>与promise，reac函数不同的是，reac，在promise实例当中，找到最快响应的实例，</p>
<p>promise，any，找到最快响应的实例，必须得是，resovled，状态的。</p>
<p>p1-p4，4个promise实例，是promise，any的成员。<br>p1-p4，最快执行完毕，且实例本身，是resolved的，成为any的状态。<br>假设p1-p4全部rejected的话，那么，就得使用catch去捕获异常。。</p>
<p>p1-p4，只要有一个resolved，那就算成功了。</p>
<h5 id="关于promise-try"><a href="#关于promise-try" class="headerlink" title="关于promise try"></a>关于promise try</h5><p>关于promise的执行顺序。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(0);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印的顺序居然是，1 0；</p>
<p>因为promise是异步函数，除非你给他做一个匿名立即执行函数。绕过去。不然的话。</p>
<p>可是我们即想要使用，promise函数，但也没有什么，异步操作。。。</p>
<p>这个时候，promise，try就诞生了。</p>
<p>promise try文档不全，最新还没有进行适配。后面补上。。</p>
<h5 id="关于promise-resolve。"><a href="#关于promise-resolve。" class="headerlink" title="关于promise resolve。"></a>关于promise resolve。</h5><ol>
<li>primise resolve，可以将一个对象转换为，promise方法。</li>
</ol>
<p>promise.resolve等于 new prmise((resolve,reject)=&gt;{});</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let object = &#123;</span><br><span class="line">    name: 111,</span><br><span class="line">    age: &#x27;12&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Promise.resolve(object);</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res.name)//111</span><br><span class="line">&#125;)</span><br><span class="line">console.log(p1)//Promise &#123;&lt;fulfilled&gt;: &#123;…&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>成功的把一个promise例子转换为，真实的例子。</p>
<p>primise.resolve()的参数有四种。</p>
<p>resolve()的参数是一个promise实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(12121);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Promise.resolve(p3())</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//12121</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>promise.resolve参数返回的还是promise实例。。</p>
<p>resolve(),thenable，参数。<br>thenable对象，指的是具有，then方法的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p1 = Promise.resolve(&#123;</span><br><span class="line">    then: () =&gt; &#123;</span><br><span class="line">        console.log(11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//11</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>resolve,then对象调用执行后，对象p1的状态就回变为resolved。</p>
<p>参数不是具有then()方法的对象，或根本就不是对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p1 = Promise.resolve(&#x27;11&#x27;)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//11</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>因为hello不属于一步操作，返回promise的实例状态从医生称就是resloved，所以回调函数立即执行。<br>同时会传给回调函数。。</p>
<p>如果promise.resolved,不带参数。那么直接返回resolved状态的promise对象。</p>
<p>立即执行的promise对象，是在本轮事件循环结束时执行，而不是在下一轮事件循环开始时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(0)</span><br><span class="line">let p1 = Promise.resolve(1)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;, 0)</span><br><span class="line">// 0 1 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="promise-reject"><a href="#promise-reject" class="headerlink" title="promise.reject(),"></a>promise.reject(),</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p1 = Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">p1.catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">/**</span><br><span class="line"> * Promise.reject(&#x27;出错了&#x27;) === new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line"> * reject</span><br><span class="line"> * &#125;)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的包管理器</title>
    <url>/blogs/2022/04/14/%E5%85%B3%E4%BA%8Enpm%E4%B8%8Eyran%E5%92%8Ccnpm%E5%8C%85%E6%8B%ACpnpm%E3%80%82/</url>
    <content><![CDATA[<ol>
<li>npm早起pages.json来确定node_modules依赖树关系，而且众所周知的原因，慢。v5版本之后多了，package-lock.json文件，锁定了依赖的版本，保证我们每次都能下到正确版本的依赖。</li>
<li>yran性能好，体积会小一些。早起的时候npm没有package-look.json。</li>
<li>pnpm超级快，体积小，掘金社区，说依赖少一些，不稳定。没有声明使用的依赖，好想存在一些问题。观望。</li>
<li>前端项目当中，一定要保持node版本，和包管理器的版本一致。</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Javascript闭包（Closure）</title>
    <url>/blogs/2022/04/14/%E5%AD%A6%E4%B9%A0Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/</url>
    <content><![CDATA[<h5 id="在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。"><a href="#在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。" class="headerlink" title="在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。"></a>在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。</h5><p>不bb上代码！！！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 0;</span><br><span class="line">function parent() &#123;</span><br><span class="line">    var b = 1;</span><br><span class="line">    console.log(a, b);</span><br><span class="line">    function son() &#123;</span><br><span class="line">        var c = 2;</span><br><span class="line">        console.log(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">parent();</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>


<ol>
<li>我们可以在任何地方访问变量，全局变量a。</li>
<li>局部变量，b，c，parent函数，只能访问到局部变量，b。son函数的作用域变量，parent无法访问。</li>
<li>son函数，访问，a，b，c变量的过程就是一个完整的作用域链。是一个向上的过程。</li>
</ol>
<p>通俗的语言表达，son作用域就是一个鱼缸，parent作用域是一个池塘。son可以通过吸管来抽取parent作用域的水（变量）;</p>
<h5 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h5><p>闭包问题，让池塘拿出吸管来抽取鱼缸的水（变量）的过程。</p>
<p><strong>所以，如何在外部访问函数内部的变量呢？</strong></p>
<p>看个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line">let val = parent();</span><br><span class="line">console.log(val);//0</span><br></pre></td></tr></table></figure>

<p>这里我们把parent函数直接return出去，就拿到了内部变量了，吗？</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    ++num;</span><br><span class="line">    console.log(num);</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line">parent();//1</span><br><span class="line">parent();//1</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>我们执行了，2次parent函数，log打印出来的只有1，1。<br>函数的内部变量为什么只做了一次自增就就没有了呢？？？？</p>
<p>这里不得不谈的js的执行机制问题。</p>
<p>太复杂的不想谈，parnt方法执行完毕之后，整个方法，连变量都被回收了，num变量值只拿到了自增一次后的，parnt函数的返回值。</p>
<p>可以把js执行理解为一个机器，parent执行，回收掉。返回值1，parent执行，回收掉返回值1。</p>
<h5 id="如何得到一个闭包呢？"><a href="#如何得到一个闭包呢？" class="headerlink" title="如何得到一个闭包呢？"></a>如何得到一个闭包呢？</h5><p>我们可以看看闭包需要达成的条件。</p>
<ol>
<li>外部函数能够访问，内部函数的变量。</li>
<li>内部的变量可以一直存在内存里面，不会被js的垃圾回收机制回收掉。</li>
</ol>
<h6 id="如何在外部访问部分的函数变量。"><a href="#如何在外部访问部分的函数变量。" class="headerlink" title="如何在外部访问部分的函数变量。"></a>如何在外部访问部分的函数变量。</h6><p>在函数内部在创建一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    son();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>son有权利访问，parent内部的所有变量。那么我们如果把son函数当作返回值，在外部不就能拿到，函数内部的变量了吗。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">val();//0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>上面这个例子，只能证明，外部函数可以访问得到parent函数的内部。可是函数内部的变量，有没有被垃圾回收，下面这个例子就能证明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    add = function () &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    minus = function () &#123;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">minus();</span><br><span class="line">val();//2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们在函数内部，声明了2个全局变量方法。一个做自增，一个做自减。</p>
<p>还有一个例子也能证明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        num: 0</span><br><span class="line">    &#125;;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">var c1 = val();</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">console.log(c1.num, val());//6,6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cl.num 与函数内部的变量完全相等。<br>son函数就是 闭包。在parent函数内部，通过return，与外部函数建立一条通道。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>闭包就是外部函数访问内部函数变量，且函数内部的变量一直在内存里得到保留，不会被垃圾回收。</p>
<p>产生闭包的原因是，因为，外部函数引用了函数内部的函数，导致不会进行垃圾回收，变量得到了保留。</p>
<p>这就是函数内部建立函数，return函数内部给外部函数的原因。</p>
<h5 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h5><ol>
<li>因为闭包函数内部的变量不会被垃圾回收，需要小心内存泄漏。</li>
<li>闭包让我们有了访问函数内部变量的权利，但是不要轻易去修改函数内部的值。</li>
</ol>
<h5 id="阮一峰大佬的思考题"><a href="#阮一峰大佬的思考题" class="headerlink" title="阮一峰大佬的思考题"></a>阮一峰大佬的思考题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">　　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that = this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个结果是，The Window”原因是因为，this的指向问题，return funtion是一个匿名函数，匿名函数默认指向window。</p>
<p>第二个结果是，My Object”原因是因为，getNameFunc，在obect下面，this自然而然就指向object。这个时候把this指针所谓变量，给了匿名函数。return的时候，this自然而然指向了objet，所以访问到name。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的new操作符</title>
    <url>/blogs/2022/01/23/javascript%E4%B8%AD%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="new操作符有什么用？"><a href="#new操作符有什么用？" class="headerlink" title="new操作符有什么用？"></a>new操作符有什么用？</h4><h5 id="试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。"><a href="#试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。" class="headerlink" title="试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。"></a>试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(&#123;</span><br><span class="line">        id: index,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">        run: function () &#123;</span><br><span class="line">            console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">arr[0].run();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>100个士兵，我们生成了，但是，这样这样，既不优雅，对性能也是一种极大的浪费。</p>
<h5 id="可不可以再优雅一点。"><a href="#可不可以再优雅一点。" class="headerlink" title="可不可以再优雅一点。"></a>可不可以再优雅一点。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//士兵原型</span><br><span class="line">var model = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    //创建一个临时对象</span><br><span class="line">    let object = &#123;</span><br><span class="line">        id: index,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">    &#125;</span><br><span class="line">    object.__proto__ = model;</span><br><span class="line">    arr.push(object)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr[0].run();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创建了一个原型对象 通过object的proto指向士兵的原型。</p>
<h5 id="还能不能更优雅一点，原型与对象在2个地方。"><a href="#还能不能更优雅一点，原型与对象在2个地方。" class="headerlink" title="还能不能更优雅一点，原型与对象在2个地方。"></a>还能不能更优雅一点，原型与对象在2个地方。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//士兵原型</span><br><span class="line">var model = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//更优雅的方式</span><br><span class="line"></span><br><span class="line">function Cat(id) &#123;</span><br><span class="line">    let object = &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">    &#125;</span><br><span class="line">    object.__proto__ = model;</span><br><span class="line">    return object;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(Cat(index))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr, arr[0].run());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://imgtu.com/i/75NzLt"><img src="https://s4.ax1x.com/2022/01/23/75NzLt.jpg" alt="代码演示.jpg"></a></p>
<p>使用 new来实现一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//士兵们</span><br><span class="line">let arr = [];</span><br><span class="line">function Soldier(id) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.hp = Math.floor(Math.random() * (100 - 0)) + 0;</span><br><span class="line">&#125;</span><br><span class="line">Soldier.prototype.run = function () &#123;</span><br><span class="line">    console.log(`$&#123;this.id&#125;号士兵在逃跑`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实例化</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(new Soldier(index))</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr, arr[80].run());</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>首先实例化过程中创建了一个对象。</li>
<li>给对象添加proto，然后new自动找到了构造函数的原型并且把原型链接到了对象proto。</li>
<li>this做实例化的对象的上下文。</li>
<li>如果该函数没有返回对象，返回this。</li>
</ul>
<p>这就是new操作符的作用。<br><a href="https://zhuanlan.zhihu.com/p/23987456">参考文章</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于js中的apply bind call的使用</title>
    <url>/blogs/2022/01/20/%E5%85%B3%E4%BA%8Ethis%E7%9A%84call%EF%BC%8Capply%EF%BC%8Cbind%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="this到底指向哪里。"><a href="#this到底指向哪里。" class="headerlink" title="this到底指向哪里。"></a>this到底指向哪里。</h4><p>事实上，this基本上指向最后调用他的对象。谁最后调用了this，this最终就指向哪里。（虽然会存在着，隐式调用的时候，this就变成了默认）</p>
<h4 id="而apply-call-与-bind-，可以改变this的指向。"><a href="#而apply-call-与-bind-，可以改变this的指向。" class="headerlink" title="而apply call 与 bind ，可以改变this的指向。"></a>而apply call 与 bind ，可以改变this的指向。</h4><p>例子如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi();//芳芳</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>我们需要让sayHi方法的this指向parson</strong></p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi.call(parson)//李四</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用apply 也可以改变指向。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi.apply(parson)//李四</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="apply-与-call-的区别。"><a href="#apply-与-call-的区别。" class="headerlink" title="apply 与 call 的区别。"></a>apply 与 call 的区别。</h5><p>apply 和call的第一个参数都是，制定this的指向。第二次参数都是要传递进入的参数。不同的是 apply方法必须要制定一个数组作为参数传入，而，call则不是。</p>
<p>例子如下，，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi(a, b) &#123;</span><br><span class="line">    console.log(this.val + a + b);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    val: 10,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sayHi.call(parson, 1, 2);</span><br><span class="line">sayHi.apply(parson, [1, 2,]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>不管是apply 与call 方法都指向了 parson，且，只不过apply参数传递必须是个数组。</p>
<p>bind 与 apply 和call不同的地方在于。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>执行</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>apply</td>
<td>改变函数的this上下文后马上执行函数</td>
<td>返回fun的执行结果</td>
</tr>
<tr>
<td>bind</td>
<td>返回函数改变了上下文的函数不马上执行</td>
<td>返回fun的拷贝，并指定了this的指向，保存函数的参数。</td>
</tr>
</tbody></table>
<p>关于apply 的一些妙用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 21, 21, 31, 32, 32, 12121, 21];</span><br><span class="line">let max = Math.max.apply(Math, arr);</span><br><span class="line">let min = Math.min.apply(Math, arr)</span><br><span class="line">console.log(max, min);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>改变this的指向</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce解决商品sku算法问题</title>
    <url>/blogs/2022/01/10/reduce%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81sku%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="sku问题。"><a href="#sku问题。" class="headerlink" title="sku问题。"></a>sku问题。</h4><p>找到了一个数组方法 特别适合计算sku。</p>
<p>就是js中的reduce方法。</p>
<p>关于reduce方法的四个参数。<br>Accumulator (acc) (累计器)<br>Current Value (cur) (当前值)<br>Current Index (idx) (当前索引)<br>Source Array (src) (源数组)<br>initialValue（初始值）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>accmulator</td>
<td>累加器（如果设置有初始值的话，第一次是初始值的参数，没有初始值，返回上次回调函数的结果）</td>
</tr>
<tr>
<td>Current Value</td>
<td>当前的值</td>
</tr>
<tr>
<td>Current Index</td>
<td>当前下标</td>
</tr>
<tr>
<td>Source Array</td>
<td>源数组</td>
</tr>
<tr>
<td>initialValue</td>
<td>默认值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var arr = [[&#x27;s&#x27;, &#x27;m&#x27;, &#x27;x&#x27;, &#x27;l&#x27;, &#x27;xl&#x27;], [&#x27; T恤&#x27;, &#x27;裤子&#x27;, &#x27;裙子&#x27;], [&#x27;蓝色&#x27;, &#x27;白色&#x27;], [&#x27;nike&#x27;, &#x27;安踏&#x27;, &#x27;李宁&#x27;]];</span><br><span class="line">console.log(...arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    pre.forEach(item =&gt; &#123;</span><br><span class="line">        cur.forEach(items =&gt; &#123;</span><br><span class="line">            res.push(item.concat(items));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;, [[]]));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码需要理解的地方在于，第一遍的时候因为设置了默认值，[[]],所以第一次遍历到的是一个空数组。第二次再去遍历的时候 <strong>此时</strong>，当前值已经T恤xxx什么的了，所以第二次，我们遍历pre数组，合并cur数组就可以了。</p>
<p>reduce方法。。</p>
<p>这样sku问题就解决了</p>
<h5 id="reduce其他妙用。"><a href="#reduce其他妙用。" class="headerlink" title="reduce其他妙用。"></a>reduce其他妙用。</h5><h6 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [12, 3, 31, 21, 21, , 31, 31];</span><br><span class="line"></span><br><span class="line">console.log(arr.reduce((per, cur) =&gt; &#123;</span><br><span class="line">    return per + cur</span><br><span class="line">&#125;));//150</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="reduce-计算数组中每个元素出现的次数"><a href="#reduce-计算数组中每个元素出现的次数" class="headerlink" title="reduce 计算数组中每个元素出现的次数"></a>reduce 计算数组中每个元素出现的次数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Tiff&#x27;, &#x27;Bruce&#x27;, &#x27;Alice&#x27;];</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    return names.reduce((allNames, name) =&gt; &#123;</span><br><span class="line">        if (name in allNames) &#123;</span><br><span class="line">            allNames[name]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            allNames[name] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return allNames;</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(names));</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>includes</title>
    <url>/blogs/2022/01/10/includes/</url>
    <content><![CDATA[<h4 id="关于ES6-include的使用方法。"><a href="#关于ES6-include的使用方法。" class="headerlink" title="关于ES6-include的使用方法。"></a>关于ES6-include的使用方法。</h4><p>场景，和后端同学调试接口的时候，后端同学很喜欢返回我，status，或者type来给我判断。但是，，，如果状态多的话，那么判断可能是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let status = 0;</span><br><span class="line"></span><br><span class="line">if (status == 1 || status == 2 || status == 3) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说实话这样写一点都不优雅。但是还能接受。毕竟 1 2 3，还好判断。</p>
<p>场景，后端同学又过来，接口要改，status可能要多判断2个值，4，5。4是进行中，5是已售后，或者叫啥都行。</p>
<p><a href="https://imgtu.com/i/7VEMdI"><img src="https://s4.ax1x.com/2022/01/10/7VEMdI.jpg" alt="7VEMdI.jpg"></a></p>
<p>接下来，我们的代码就是这样。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let status = 5;</span><br><span class="line"></span><br><span class="line">if (status == 1 || status == 2 || status == 3 || status == 4 || status == 5) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>即便后端哥们不再过来改接口，添加状态。你也觉得这段代码不妥了把。</p>
<p>includes方法就可以完美解决这个问题。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let status = 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5];</span><br><span class="line">if (arr.includes(status)) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>includes</strong>会找数组的成员，找到了就是true，找不到就是false。</p>
<p>可可可，有indexof，呀。为什么要使用includes。</p>
<p>的确。indexof能实现这个问题。。</p>
<p>可是，如果数组里面存在NaN呢。indexof是否还能找得到？</p>
<p>例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let status = NaN;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, NaN, null];</span><br><span class="line">if (arr.indexOf(status) != -1) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>alert 出来到是 no。</p>
<p>而，includes就不会存在这样到问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let status = NaN;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, NaN, null];</span><br><span class="line">if (arr.includes(status)) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>indexof 无法在数组内定位到，NaN的位置。</p>
<p>结论如下，NaN无敌可能会存在数组的情况下，使用includes。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读红宝书js中的变量</title>
    <url>/blogs/2021/11/25/%E9%98%85%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h5 id="var是什么。"><a href="#var是什么。" class="headerlink" title="var是什么。"></a>var是什么。</h5><p>1.js中的操作符，声明一个函数级的变量。<br>2.会存在变量提升的情况。</p>
<h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">var a = 11;//undefined</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为，变量提升到了最上面，所以虽然没有声明变量a，但是a变量被提到了最前面。</p>
<p>小知识，声明未使用的变量，默刃值是undefined。</p>
<h6 id="例子2，在函数里面"><a href="#例子2，在函数里面" class="headerlink" title="例子2，在函数里面"></a>例子2，在函数里面</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a;//undefined</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样也是变量被声明了。</p>
<p>我在变量提升上面的理解走错了路。声明变量，变量的默认中undefined，所谓的变量提升，就是声明的变量提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 11;</span><br><span class="line">代码等于 </span><br><span class="line">var a;</span><br><span class="line">a = 11;</span><br></pre></td></tr></table></figure>


<h6 id="let，块级作用域"><a href="#let，块级作用域" class="headerlink" title="let，块级作用域"></a>let，块级作用域</h6><p>1.何谓块级作用域啊。<br><code>&#123;&#125;</code><br>指的是只在代码块里有效。</p>
<p>2.最大的特点是没有变量提升。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * error  index.js:20 Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br><span class="line">    at index.js:20</span><br><span class="line"> * </span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">let a = 11;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不可以先使用！后声明变量。必须得先声明。因为没有变量提升！！！<br>因为let 声明执行的瞬间会存在一个暂缓性死区，不允许先使用后声明。</p>
<h6 id="3-可否重复声明？？"><a href="#3-可否重复声明？？" class="headerlink" title="3.可否重复声明？？"></a>3.可否重复声明？？</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var a = 11;</span><br><span class="line">var a = 12;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>//众所周知，var变量的缺点是提升，与重复声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let a = 11;</span><br><span class="line">let a = 12;</span><br><span class="line">console.log(a);//error Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let 在同一作用域下,不允许重复声明。</p>
<h6 id="关于全局声明。"><a href="#关于全局声明。" class="headerlink" title="关于全局声明。"></a>关于全局声明。</h6><p>var 声明的变量会成为window对象的属性。但是let在全局声明则不然。  </p>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//全局声明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let a = 11;</span><br><span class="line">console.log(window.a);undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="let-是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。"><a href="#let-是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。" class="headerlink" title="let 是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。"></a>let 是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。</h5><p>举个例子。</p>
<p>a.js文件里面的代码</p>
<p>`<br>let a = 11;</p>
<p>`<br>b.js文件的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// let a = 12;</span><br><span class="line">//条件声明不是一个好的方式。</span><br><span class="line">if (typeof (a) == &#x27;number&#x27;) &#123;</span><br><span class="line">    // 块级作用域下的let 声明的变量a ，无法检测前面有没有同名的变量。也无法在没有什么声明之前使用a。</span><br><span class="line">    let a = 12;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">//此处变量a，是a.js文件下声明的变量a，因为这个变量a是在全局作用域声明的变量。</span><br><span class="line">a = 13;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>关于js为什么做模块化的。就是因为上面的代码太乱了，都在一个html页面下，依赖于上下关系，而且能够很轻松的访问到全局作用域洗面的全局变量。所以很容易出现变量泄漏的问题。</p>
<p>且很难理清楚代码的关系。</p>
<h5 id="在for循环中声明let。"><a href="#在for循环中声明let。" class="headerlink" title="在for循环中声明let。"></a>在for循环中声明let。</h5><p>举个例子，因为for循环中，var 声明的变量会渗透出去。所以let声明的变量只会在代码块中存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 1; i &lt; 3; ++i) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//在这里我们能轻松访问到i</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>//如果使用let声明的话则不会。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">for (let i = 1; i &lt; 3; ++i) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//index.js:6 Uncaught ReferenceError: i is not definedat index.js:6</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>//陷入的误区。</p>
<p>因为之前习惯使用 var来声明变量，搞不清楚为什么for循环后，var声明的变量比，<br>之前的代码多了1。</p>
<p>我tm就是脑子不好使，是个傻逼。let是块级作用域当然没这个问题了。</p>
<p>在js的for循环中只有失败了，才会停止。</p>
<p>总结，var会变量提升，在for循环中会导致变量渗透。var可以多次被声明，var 任何版本都可以使用。变量都默认值数undefined。<br>var 在windows作为属性。</p>
<p>let 没有变量提升，因为声明瞬间会暂缓性死区，let必须先声明后使用，在同块级作用域下let 变量不能重复声明。lef使用for循环不会泄漏变量。别使用条件声明let 同名变量。let不在window作为属性。</p>
<p>for循环只有失败都时候会终止。</p>
<p>最重要的知识点是弄清楚了for循环失败结束，太蠢了我。和上古时期的前端开发者的苦恼，没有模块化之前很容易全局变量污染。不易维护。</p>
<p>感同身受。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年11月22日日报</title>
    <url>/blogs/2021/11/23/2021%E5%B9%B411%E6%9C%8822%E6%97%A5%E6%97%A5%E6%8A%A5/</url>
    <content><![CDATA[<h4 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h4><h5 id="看js的红宝书"><a href="#看js的红宝书" class="headerlink" title="看js的红宝书"></a>看js的红宝书</h5><p>标识符<br>js中的标识符指的是，变量，属性，方法。最好使用小驼峰写法（首字母小写），标识符开头必须是字母或者_下划线，或者美元符号$来表示。</p>
<p>语句<br>{}来表示代码块，那怕就一句，;号表示语句的结束，如果不写分号也许。只不过js引擎会解析都时候带上，对性能不好。<br>最好使用控制语句来控制代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(true)</span><br><span class="line">log(&#x27;坏的写法&#x27;)</span><br><span class="line"></span><br><span class="line">if(ture)&#123;</span><br><span class="line">    log(&#x27;好的写法&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>es6之后才加了let 与const，任何版本变量都可以使用var 声明。<br>var 自带变量提升。</p>
<p>关键字是js中定义好的东西，不可以声明为标识符。保留字是不是关键字的关键字。下个版本也许就是关键字了。</p>
<h5 id="商城项目"><a href="#商城项目" class="headerlink" title="商城项目"></a>商城项目</h5><p>瀑布流的数据push入数组里面，这个时候转成josn字符串再转出来。</p>
<p>uniapp编译的时候存在问题。（猜测）</p>
<p>写分页的时候，上拉加载的时候就做判断。</p>
<h5 id="催宋哥工厂图"><a href="#催宋哥工厂图" class="headerlink" title="催宋哥工厂图"></a>催宋哥工厂图</h5><h4 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h4><p>尽快结束商城<br>给爸爸打电话<br>找媳妇聊天。<br>恢复状态<br>减肥。</p>
<h5 id="心得。"><a href="#心得。" class="headerlink" title="心得。"></a>心得。</h5><p>调整状态，多学习。经验。勤为径。</p>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常用的单位和计算说明</title>
    <url>/blogs/2021/10/24/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E4%BD%8D%E5%92%8C%E8%AE%A1%E7%AE%97%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单位</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>px</td>
<td>相对长度单位</td>
</tr>
<tr>
<td>pt</td>
<td>绝对单位</td>
</tr>
<tr>
<td>rem</td>
<td>相对单位</td>
</tr>
<tr>
<td>em</td>
<td>相对单位</td>
</tr>
<tr>
<td>upx</td>
<td>uniapp主动放弃了</td>
</tr>
<tr>
<td>rpx</td>
<td>相对单位-动态宽度单位</td>
</tr>
<tr>
<td>vw</td>
<td>相对单位</td>
</tr>
<tr>
<td>vh</td>
<td>相对单位</td>
</tr>
<tr>
<td>vmin</td>
<td>相对单位，屏幕宽高相对较小的那个。</td>
</tr>
<tr>
<td>vmax</td>
<td>相对单位，屏幕宽高相对较大的那个。</td>
</tr>
</tbody></table>
<h4 id="关于px"><a href="#关于px" class="headerlink" title="关于px"></a>关于px</h4><p>1.px,是一块屏幕能展示能显示最小的像素点。<br>2.px是一个相对的绝对单位。相对指的是 都是屏幕,但是1px在不同屏幕上可能展示的大小不一样。  A屏幕的1px的长度也许会大于B屏幕的1px。</p>
<p>3.但是在网页设计中，A屏幕分辨率 300x300px  B屏幕 600x600px，各设一个width 2px，height 2px的盒子。他们大小会是一样的。</p>
<p>因为浏览器，在A屏幕是 1px 也许只是1个像素点。但是 B屏幕这样的高清屏幕，1px也许就是 2个像素点来表示1px。所以就是屏幕像素密度存在差异，但是会在浏览器会经过逻辑计算。这就是绝对。</p>
<h4 id="关于pt"><a href="#关于pt" class="headerlink" title="关于pt"></a>关于pt</h4><p>印刷行业表示字体的单位， 1/72英寸。绝对单位。<br>计算公式等于 100px * 4/3</p>
<h4 id="关于rem单位。"><a href="#关于rem单位。" class="headerlink" title="关于rem单位。"></a>关于rem单位。</h4><p>htlm根元素字体大小。 1rem 等于16px</p>
<h4 id="关于em-单位"><a href="#关于em-单位" class="headerlink" title="关于em 单位"></a>关于em 单位</h4><p>我对em单位超级超级陌生。培训班大师兄跟我说 国外喜欢用em作为字体大小来使用。<br>但是国内没必要，选择rem或者px就行了。</p>
<p>今天写这篇博客的时候，看到这篇文章<a href="https://jorux.com/archives/95-websites-of-china-need-to-rewrite-css/">。95%的中国网站需要重写CSS</a></p>
<p>由于ie浏览器的内核不支持调整网站px字体的大小。所以国外都使用了em作为web网站的字体单位。</p>
<p>但是国内没有这样去做。以至于今天，ie已经成为会议了。</p>
<p>那么em单位是什么呢。</p>
<p>em的值不是固定的，em会继承父级字体的大小。</p>
<h4 id="rpx单位。"><a href="#rpx单位。" class="headerlink" title="rpx单位。"></a>rpx单位。</h4><p>uniapp 针对屏幕的宽度会动态调整的单位。<br>计算规则如下，2px == 4rpx</p>
<p>设计稿 * A元素的px / 750 就是rpx。</p>
<p>设计稿 * 页面测试的元素宽度 / 设计稿基准宽度。</p>
<p>通常1px 等于2rpx</p>
<h4 id="vw-和-vh单位。"><a href="#vw-和-vh单位。" class="headerlink" title="vw 和 vh单位。"></a>vw 和 vh单位。</h4><p>vw 是视口的宽度 vh是视口的高度</p>
<p>vw 等于 视口的1%。<br>也是相对单位</p>
<p>1920 * 1080 1vw 等于 1920 / 100% 19.2px。</p>
<h4 id="vmax-与vmin。"><a href="#vmax-与vmin。" class="headerlink" title="vmax 与vmin。"></a>vmax 与vmin。</h4><p>vmax vmin 针对与我们字体 比如，我们手机从竖屏来到横屏。vw 和vh会发生变化。</p>
<p>vmax vmin 一个是取vw 和vh 最大的值，一个是取最小的值。</p>
<p>ps：写此篇博客是为了和ui撕逼。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css常用单位</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年9月7日日报</title>
    <url>/blogs/2021/09/07/2021%E5%B9%B49%E6%9C%887%E6%97%A5%E6%97%A5%E6%8A%A5/</url>
    <content><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><p>1.写秒杀专区。<br>2.找春鹏对接。<br>3.帮樊解决上传的问题。  </p>
<h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><p>1.秒杀专区欠支付成功页面。<br>2.小程序导航栏。<br>3.开碰头会。  </p>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1.使用vuex，不顺手。<br>2.父组件的子组件的组件库组件的样式不能在子组件修改。<br>3.上传formdata。</p>
<h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><p>1.父组件的子组件的组件库组件的样式不能在子组件修改<br>解决方法。在父组件 /deep/.子组件.ui库组件。</p>
<p>这一块需要在看看。</p>
<p>2.vuex的使用。和组件的运用。</p>
<h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ol>
<li>给家人打电话。</li>
<li>减肥</li>
<li>焦躁</li>
</ol>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>git团队协作</title>
    <url>/blogs/2021/09/02/git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>客驾到的时候，我使用了breach，来进行分支管控。<br>dev分支用来开发。master用来合并。</p>
<p>如果我和A君一起开发的话，我俩一起在一个dev分支下进行开发。然后去master进行合并。<br>春鹏告诉我，我们可以一人一个分支去玩的。一起往master上面合并。我意识到我对breach 的使用略显不足，所以补充一下我的理解。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>客驾到项目中，我想的更多的是 ，想通过分支来做一个<strong>沙盒</strong>。进行<strong>隔绝</strong>。<br>去进行<strong>区分</strong>。</p>
<p>但是，分支给我带来的体验并不好，因为2个人使用一个分支，我与A君，我们两个人之间，没有沙盒。</p>
<p>如果这个时候 B君也参与了进来，我们三个人，使用一个dev分支。超级容易打架。</p>
<h4 id="多分支开发。"><a href="#多分支开发。" class="headerlink" title="多分支开发。"></a>多分支开发。</h4><p>标准团队协作模式下进行开发。</p>
<p>应该有这样的分支。</p>
<p><strong>master</strong>  <strong>hotfix</strong> <strong>develop</strong> <strong>feature</strong> <strong>release</strong></p>
<table>
<thead>
<tr>
<th>分支名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>主分支，随时都得处于发布状态。</td>
</tr>
<tr>
<td>hotfix</td>
<td>修复线上的bug</td>
</tr>
<tr>
<td>develop</td>
<td>开发分支</td>
</tr>
<tr>
<td>feature</td>
<td>开发功能分支。</td>
</tr>
<tr>
<td>release</td>
<td>预发布分支。</td>
</tr>
</tbody></table>
<p>首先咱们先从 master分支下 创建 develop<br>develop 下创建 feature分支，用来开发功能。<br>功能开发结束，develop合并feature的功能。<br>然后从develop签出一条 release分支。用来准备发布。<br>出现bug，release修复bug，修复结束，同步给develop，与matser分支。</p>
<p>master分支 出现bug。</p>
<p>建立hotfix分支。修复bug。修复成功同步给master 与develop。</p>
<p>主要还是围绕着master 与 develop来展开的。</p>
<p>这就是标准的 git团队协作。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年8月14日日报</title>
    <url>/blogs/2021/08/14/2021%E5%B9%B48%E6%9C%8814%E6%97%A5%E6%97%A5%E6%8A%A5/</url>
    <content><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><ol>
<li>看webview与iframe</li>
<li>对着html进行查漏补缺</li>
<li>gitee，实名</li>
<li>看naive ui</li>
<li>uniapp，阅读了一下入门知识</li>
<li>html语义化规范</li>
</ol>
<h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><ul>
<li>递归算法</li>
<li>nuxt</li>
<li>uniapp router权限控制</li>
</ul>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><ul>
<li><p>webview是什么。  </p>
<blockquote>
<ol>
<li>浏览器专门针对像java啊，ios 安卓这样原生语言来设计的</li>
<li>原生应用就像一个孤岛。需要使用webview来接入web服务端的内容。</li>
<li>webview更像一个浏览器的渲染引擎。</li>
<li>通过webview，JavaScript可以调用原生的api，原生也可以加载web端的信息。</li>
</ol>
</blockquote>
</li>
<li><p>iframe是什么。</p>
<blockquote>
<p>1.html标签<br>2.加载网页。<br>3.上古时期的前端开发者用它来轮询。<br>4.自带一个沙盒机制。与页面代码互不打扰。<br>5.网页广告情况泛滥。<br>6.因为不知道别人有没有拿你的页面iframe，你会不会拿别人的页面iframe 所以不安全。</p>
</blockquote>
</li>
<li><p>html 标签查漏补缺。</p>
<blockquote>
<p>1.里面有个details标签。<br>2.meter 标签很有意思。<br>3.做好语义化。</p>
</blockquote>
</li>
</ul>
<h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><ul>
<li>html语义化与html常用标签。</li>
<li>webview与iframe</li>
</ul>
<h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ul>
<li>效率低下</li>
<li>今天没有使用番茄钟</li>
</ul>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>html查漏补缺</title>
    <url>/blogs/2021/08/14/%E9%87%8D%E6%96%B0%E5%A4%8D%E4%B9%A0html/</url>
    <content><![CDATA[<h5 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h5><p>一个优秀的前端开发者，一定不是靠着一手所谓的<div><p>标签一把梭的。</p>
<p>即使html是一个超文本标记语言。JavaScript一直以来才是web开发者中的重中之重。</p>
<h5 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h5><ol>
<li><code>&lt;article&gt;&lt;/article&gt;</code>标签</li>
</ol>
<blockquote>
<p>w3cschool 是这样描述它的。article元素规定独立的自包含内容。  </p>
<article>元素的应用场景是 论坛，博客，新闻。
</blockquote>
<p>独立的自包含内容，指的是，article标签，内部可以设置header，footer各种标签。来展示一篇独立的文章内容。</p>
<ol start="2">
<li><code>&lt;aside&gt;&lt;/aside&gt;</code></li>
</ol>
<blockquote>
<p>aside标签2种用法。<br>要么文章标题的补充部分。<br>要么就是侧边栏。<br>与div差不多，但是html5 推行语义化标签的结果。</p>
</blockquote>
<ol start="3">
<li><code>&lt;bdi&gt;&lt;bdi&gt;</code></li>
</ol>
<blockquote>
<p>我感觉 bdi标签没啥卵用。<br>标签允许您设置一段文本，使其脱离其父元素的文本方向设置。在发布用户评论或其他您无法完全控制的内容时</p>
</blockquote>
<blockquote>
<p>文档上是这么说。</p>
</blockquote>
<blockquote>
<p>但是在我眼里，这标签只会把 所谓的文字 如果是数字的话 改变一些排列的方向而已。</p>
</blockquote>
<ol start="4">
<li><code>&lt;details&gt;&lt;/details&gt;与, &lt;summary&gt;&lt;summary/&gt;    </code></li>
</ol>
<blockquote>
<p>details是用于描述文档的细节。<br>summary details的标题。</p>
</blockquote>
<p>上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;details draggable=&quot;true&quot;&gt;</span><br><span class="line">    &lt;summary&gt;详情菜单&lt;/summary&gt;</span><br><span class="line">    &lt;div&gt;详情内容&lt;/div&gt;</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>&lt;dialog&gt;&lt;/dialog&gt;</code></li>
</ol>
<blockquote>
<p>一个对话框，弹窗标签。open 打开关闭与否。<br>能和form配合使用。</p>
</blockquote>
<ol start="6">
<li><code>&lt;figure&gt;&lt;/figure&gt;   &lt;figcaption&gt;&lt;/figcaption&gt;</code></li>
</ol>
<blockquote>
<p>用作文档中插图的图像，带有一个标题：figcaption。使用场景语焉不详</p>
</blockquote>
<ol start="7">
<li><code>&lt;main&gt;&lt;/main&gt;</code></li>
</ol>
<blockquote>
<p>main标签对于文档来说 应该是唯一的。<br>文档最重要的内容。<br>不能嵌套hader footer等。应该保持平级。</p>
</blockquote>
<ol start="8">
<li><code>&lt;mark&gt;&lt;/mark&gt;</code></li>
</ol>
<blockquote>
<p>定义重要或强调的内容。</p>
</blockquote>
<ol start="9">
<li><code>&lt;meter&gt;&lt;/meter&gt;</code></li>
</ol>
<blockquote>
<p>它进度条<progress>的标签不一样的是，它更适合在磁盘用量，手机电量的展示上面。</p>
</blockquote>
<p>上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meter value=&quot;0.2&quot; max=&quot;1&quot; min=&quot;0&quot; low=&quot;0.1&quot; high=&quot;0.2&quot; optimum=&quot;1&quot; &gt;&lt;/meter&gt;</span><br><span class="line">/**</span><br><span class="line">   * max 最大的值</span><br><span class="line">   * min 最小的值</span><br><span class="line">   * high 被规定高的范围</span><br><span class="line">   * low 被规定低的范围</span><br><span class="line">   * optimum 规定度量的优化值。</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="10">
<li><code>&lt;nav&gt;&lt;/nav&gt;</code></li>
</ol>
<blockquote>
<nav> 标签定义导航链接的部分。
</blockquote>
<ol start="11">
<li><code>&lt;progress&gt;&lt;/progress&gt;</code></li>
</ol>
<blockquote>
<p>进度条 无需多言。</p>
</blockquote>
<ol start="12">
<li><code>&lt;section&gt;&lt;/section&gt;</code></li>
</ol>
<blockquote>
<p>表示文档中的一个章节。</p>
</blockquote>
<ol start="13">
<li><code>&lt;&lt;wbr&gt;</code></li>
</ol>
<blockquote>
<p>在合适的位置换行，如果文字一行排放不完的话。wbr换行，让文本没那么割裂。</p>
</blockquote>
<p>14.<code>base </code></p>
<blockquote>
<p>是要设置在 heade标签里面了。规定了所有的超链接，该如何跳转。<br>当前页还是新开一个页面。</p>
</blockquote>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html lang=&quot;zh&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;刘超的demo&lt;/title&gt;</span><br><span class="line">    &lt;!--设置base target 来保证所有的超链接都该怎么样跳转--&gt;</span><br><span class="line">    &lt;base target=&quot;_blank&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/index.css&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="15">
<li><code>blockquote</code></li>
</ol>
<blockquote>
<p>标记长的引用。比如一个段落。</p>
</blockquote>
<ol start="16">
<li><code>datalist</code></li>
</ol>
<blockquote>
<p>datalist，input的可能选项列表。来定义input可能出现的值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;myCar&quot; list=&quot;cars&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;cars&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;BMW&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Ford&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Volvo&quot;&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="17">
<li><code> &lt;optgroup&gt; &lt;/optgroup&gt;</code></li>
</ol>
<blockquote>
<p>把select一些相关的选项组合在一起</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;optgroup label=&quot;Swedish Cars&quot;&gt;</span><br><span class="line">    &lt;option value =&quot;volvo&quot;&gt;Volvo&lt;/option&gt;</span><br><span class="line">    &lt;option value =&quot;saab&quot;&gt;Saab&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt;</span><br><span class="line"></span><br><span class="line">  &lt;optgroup label=&quot;German Cars&quot;&gt;</span><br><span class="line">    &lt;option value =&quot;mercedes&quot;&gt;Mercedes&lt;/option&gt;</span><br><span class="line">    &lt;option value =&quot;audi&quot;&gt;Audi&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="18">
<li><code>&lt;picture&gt;&lt;/picture&gt;</code></li>
</ol>
<blockquote>
<p>picture标签 不同的尺寸下展示不同的图片。</p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年8月13日日报</title>
    <url>/blogs/2021/08/13/2021%E5%B9%B48%E6%9C%8813%E6%97%A5%E6%97%A5%E6%8A%A5/</url>
    <content><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><ol>
<li>智喔喔调试bug。</li>
<li>部署nuxt打包。</li>
<li>指定番茄钟。</li>
<li>扫了一眼rust。</li>
<li>三元表达式里面使用匿名函数。</li>
</ol>
<h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><ol>
<li>智喔喔安卓调试</li>
<li>商城等待开工</li>
<li>uniapp文章待看</li>
</ol>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1.nuxt打包问题。</p>
<p>nuxt的打包模式分为 build，和generate。<br>其中build里面打包，需要后端配置node，并且，但是需不需要做转发不得而知。</p>
<p>好像generate打包的是静态文件。但是却也可以使用。为了准确尽快出活。我没有细究。</p>
<p>2.跨域问题</p>
<p>我总感觉，nuxt就好像不需要跨域一样。待测试。</p>
<p>3.三元表达式-结合匿名函数一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var state = true;</span><br><span class="line">state ? (()=&gt;&#123;alert(11)&#125;)():(function b()&#123;alert(22)&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写完匿名函数之后，咱们需要多加个括号，表示是一个代码块。后面跟一个括号。</p>
<p>4.看春鹏的代码，了解了一些关于代码的规范。</p>
<p>比如，这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * description：刘超的代码</span><br><span class="line"> * author：刘超</span><br><span class="line"> * signa：只争朝夕</span><br><span class="line"> * timer：20点42分</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.nuxt更改布局页面。<br>nuxt在layouts，指定了多种布局方式，包括报错页面。与我们的视图。可以互相配合。互不干扰。</p>
<p>比如我不需要login加载导航栏。那就专门针对login。加载一个布局方式。</p>
<p>6.我们只需要在 vue文件下面layout:’指定的布局’</p>
<p>7.rust，具体印象，前端中后端语言，速度比c，c++快。</p>
<h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><ol>
<li>指定优秀的学习计划。</li>
<li>多看一些东西。</li>
<li>多像春鹏学习</li>
<li>nuxt的打包。</li>
</ol>
<h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ol>
<li>少说话</li>
<li>三思而行</li>
</ol>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue路由组件传参</title>
    <url>/blogs/2021/07/10/vue%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<h3 id="关于vue-router组件的传参"><a href="#关于vue-router组件的传参" class="headerlink" title="关于vue router组件的传参"></a>关于vue router组件的传参</h3><h5 id="提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？"><a href="#提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？" class="headerlink" title="提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？"></a>提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？</h5><ol>
<li> 比如vue 动态路由参数匹配？</li>
<li> 还是使用vue params，传参，比如通过router上的name，才能跳转，刷新一下参数就掉。</li>
<li> 还是比如query，参数拼接到字符串上？</li>
</ol>
<p>我们假设一个场景，我们在A页面到B页面，要传递一个object。是的，你一定要json一下，<br>在B页面接收都要做那些步骤。</p>
<ol>
<li>先写上一段，this.$route.query.object ….（我不说你也得觉得很长）</li>
<li>把拿到的参数josn化。</li>
<li>要把参数赋值到data，然后data再去使用。</li>
</ol>
<h5 id="发现的问题"><a href="#发现的问题" class="headerlink" title="发现的问题"></a>发现的问题</h5><h6 id="1-你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。"><a href="#1-你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。" class="headerlink" title="1. 你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。"></a>1. 你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。</h6><p>解决方案也简单，写个判断语句嘛。if，三元表达式，或者query，传递不同的标识符。这样页面C跳转B也没啥问题了。</p>
<h6 id="2-this-router-query-object-真的是一种很舒服的传参方式嘛，这么长。"><a href="#2-this-router-query-object-真的是一种很舒服的传参方式嘛，这么长。" class="headerlink" title="2. this.$router.query.object,真的是一种很舒服的传参方式嘛，这么长。"></a>2. this.$router.query.object,真的是一种很舒服的传参方式嘛，这么长。</h6><p>不是。</p>
<p>这就是我要讲vue router 组件传参的意义。</p>
<p>路由传参有三种模式</p>
<h6 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h6><p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//router部分</span><br><span class="line">  &#123;</span><br><span class="line">    name:&#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props: true //直接开启布尔模式</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  //跳转</span><br><span class="line">&lt;router-link :to=&quot;&#123;name: &#x27;user&#x27;,params: &#123;name: &#x27;word&#x27;,  age: &#x27;11&#x27;&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">//页面取参数</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;name&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/div&gt;&lt;!--参数是word11--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: [&#x27;params&#x27;,&#x27;name&#x27;,&#x27;age&#x27;],</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>布尔模式下，props：true的情况下，params的参数会被设置为组件的props。</p>
<h6 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h6><p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  router部分</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    name: &#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props: &#123;</span><br><span class="line">      name: &#x27;11&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">//跳转</span><br><span class="line">  &lt;router-link :to=&quot;&#123;name: &#x27;user&#x27;, params:&#123;name:&#x27;word&#x27;,age:&#x27;11&#x27;,&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  页面</span><br><span class="line">  </span><br><span class="line">    &lt;template&gt;</span><br><span class="line">         &lt;div&gt;user&#123;&#123; name &#125;&#125;&#123;&#123; age &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [ &quot;name&quot;, &quot;age&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对象模式只适合给静态类型的数据。。routerlink 传递进去的数据 拿不到。</p>
<p>函数模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//router</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    name: &#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props:route=&gt;(&#123;//函数模式，把route的参数给解构了。</span><br><span class="line">      name:route.query.name,</span><br><span class="line">      age:route.query.age,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  //跳转</span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&#x27;/user&#x27;,query:&#123;name:&#x27;word&#x27;,age:&#x27;11&#x27;&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line">  </span><br><span class="line">//user页面接收参数</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;user&#123;&#123; name &#125;&#125;&#123;&#123; age &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;!--参数是word11--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;query&#x27;, &quot;name&quot;, &quot;age&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>


<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><table>
<thead>
<tr>
<th>模式</th>
<th>特性</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值模式</td>
<td>props，属性为true，route.params，自动绑定为属性</td>
<td>不支持query</td>
</tr>
<tr>
<td>对象模式</td>
<td>适合静态类型</td>
<td>不支持动态类型</td>
</tr>
<tr>
<td>函数模式</td>
<td>支持params，query</td>
<td>没啥毛病</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的router</title>
    <url>/blogs/2021/07/10/vue%E7%9A%84router/</url>
    <content><![CDATA[<h5 id="vue-动态路由"><a href="#vue-动态路由" class="headerlink" title="vue 动态路由"></a>vue 动态路由</h5><p>很多时候,向url上传参都是使用的，query传参，因为params很多时候，视图你需要靠name来找。</p>
<p>但是 动态路由，可以让我们在路由的url上面去定义一个参数。跳转的时候把参数传入过去就能匹配到该页面。</p>
<p>比如我们有个查询接口，id来查找非常好用。</p>
<p>代码例子如下。</p>
<p>我的router</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/about/:id&#x27;,</span><br><span class="line">    name: &#x27;About&#x27;,</span><br><span class="line">    // route level code-splitting</span><br><span class="line">    // this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    // which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跳转既可以使用 <routerlink>标签，也可以使用this.$router.push({path:”/url/params”})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/about/111&quot;&gt;动态路由&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p>在路由的匹配页面上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$route.params.id,我们就能拿到。</span><br></pre></td></tr></table></figure>


<h5 id="关于匹配模式"><a href="#关于匹配模式" class="headerlink" title="关于匹配模式"></a>关于匹配模式</h5><p>常规的匹配模式，vue router 只匹配/分割开来的片段字符。如果想匹配任何路径，就需要使用通配符 </p>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path:&#x27;/user-*&#x27;</span><br></pre></td></tr></table></figure>
<p>那么 ，/user /user-love,/user-test，<br>*字通配符都能匹配得到。</p>
<p>不过我们一般会用 *号来匹配 ，查找不到的路径。<br>比如 404.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/404&#x27;,</span><br><span class="line">  name: &#x27;404&#x27;,</span><br><span class="line">  component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/404.vue&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  // 会匹配所有路径</span><br><span class="line">  path: &#x27;*&#x27;,</span><br><span class="line">  redirect:&#x27;/404&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只要匹配不到的路径 都会去 404</p>
<p>其他的匹配规则，暂时先不去看。我感觉有会用到他的一天，但是不是现在。</p>
<h5 id="vue-router-路由的嵌套"><a href="#vue-router-路由的嵌套" class="headerlink" title="vue router 路由的嵌套"></a>vue router 路由的嵌套</h5><p>//首先我们要给 /about 添加几个要嵌套的视图。</p>
<ol>
<li>children里面添加我们想要嵌套的视图。</li>
<li>子视图path 不带 “/”</li>
<li>父视图里面添加routerview</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/about&#x27;,</span><br><span class="line">  name: &#x27;About&#x27;,</span><br><span class="line">  component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;),</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;user&#x27;,</span><br><span class="line">      component:()=&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;info&#x27;,</span><br><span class="line">      component:()=&gt; import(&#x27;../views/info.vue&#x27;),</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>视图嵌套出现的小问题。<br>我们需要 访问 /user/info 如果 不访问 /info 就只跳转到 /user页面的话。很尴尬。</p>
<p>所以我们要对 如果他直接访问我们user的情况下进行重定向。</p>
<p>访问 user的情况下 直接重定向到 /user/xxxxx页面。</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/about&#x27;,</span><br><span class="line">  redirect:&#x27;/about/user&#x27;,//我们在这里重定向</span><br><span class="line">  name: &#x27;About&#x27;,</span><br><span class="line">  component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;),</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;user&#x27;,</span><br><span class="line">      component:()=&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;info&#x27;,</span><br><span class="line">      component:()=&gt; import(&#x27;../views/info.vue&#x27;),</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>命名路由的，可以直接 this.$router.push({name:’user’})</p>
<p>但是我不需要这样写。略….</p>
<h5 id="命名视图与嵌套视图。"><a href="#命名视图与嵌套视图。" class="headerlink" title="命名视图与嵌套视图。"></a>命名视图与嵌套视图。</h5><p>vue router 的命名视图，我大概是明白怎么使用了。但是不知道怎么样更好的去使用他。</p>
<p>例子如下。</p>
<p>1，命名视图的组件是使用components的。不是component。<br>2.设置默认的视图名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/&#x27;,</span><br><span class="line">  name: &#x27;Home&#x27;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    default:Home,</span><br><span class="line">    user:()=&gt; import(&#x27;../views/user&#x27;),</span><br><span class="line">    info:()=&gt; import(&#x27;../views/info&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在app.vue里面使用多个routerview</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view name=&quot;user&quot; /&gt;</span><br><span class="line">    &lt;router-view name=&quot;info&quot; /&gt;</span><br><span class="line">    &lt;router-view  /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="vue编程式导航"><a href="#vue编程式导航" class="headerlink" title="vue编程式导航"></a>vue编程式导航</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&#x27;...&#x27;&gt;&lt;/router-link&gt;</span><br><span class="line">等于我们调用的this.$router.push(),方式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>router</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>router.push()</td>
<td>往浏览器的history有记录</td>
</tr>
<tr>
<td>router.replace()</td>
<td>跳转美誉history记录</td>
</tr>
<tr>
<td>router.go()</td>
<td>向前向后跳转history记录</td>
</tr>
</tbody></table>
<h5 id="vue-router的重定向与别名"><a href="#vue-router的重定向与别名" class="headerlink" title="vue router的重定向与别名"></a>vue router的重定向与别名</h5><p>关于重定向。比如我们要访问一个/home的路径。可以通过redirect，来让我们跳到其他页面。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加载到首页，通过redirect 跳到了404页面。</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    redirect:&#x27;/404&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      default:Home,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们也可以一个方法动态返回要重定向的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法接收目标参数 return返回参数。</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    redirect:to=&gt;&#123;</span><br><span class="line">      return &#x27;/404&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      default:Home,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>router 别名的概念。</p>
<p>别名的是意思是，例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们访问 / 可以去跳转到首页。/home也能跳转到首页。虽然url是/home，但是匹配的规则还是/。</span><br><span class="line"></span><br><span class="line">就像小名与大名一样。</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    alias:&#x27;/home&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      default:Home,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名字</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>redirect</td>
<td>访问/a,重定向访问/b，</td>
</tr>
<tr>
<td>alias</td>
<td>别名访问和匹配规则，与你正常访问的url匹配到一起。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue数组对象赋值问题</title>
    <url>/blogs/2021/06/25/vue%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h5 id="数组的更新监测"><a href="#数组的更新监测" class="headerlink" title="数组的更新监测"></a>数组的更新监测</h5><p>vue是一个响应式的框架。data里面的数据的改动，会随时随地的传到view视图里面。</p>
<p>但是，对于data里面的object类型的数据，并不是这样的。</p>
<p>数组的更新监测，只有一下这些方法才能触发视图的更新。</p>
<table>
<thead>
<tr>
<th>触发视图更新的方法</th>
</tr>
</thead>
<tbody><tr>
<td>push()</td>
</tr>
<tr>
<td>pop()</td>
</tr>
<tr>
<td>shift()</td>
</tr>
<tr>
<td>unshift()</td>
</tr>
<tr>
<td>splice()</td>
</tr>
<tr>
<td>sort()</td>
</tr>
<tr>
<td>reverse()</td>
</tr>
</tbody></table>
<h5 id="遇到的问题。"><a href="#遇到的问题。" class="headerlink" title="遇到的问题。"></a>遇到的问题。</h5><p>1，我想对一个数组的1号位进行赋值。而且我不想使用数组方法。splie(),什么什么的。但是视图不会更新。</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for=&quot;(item,index) in arr&quot; :key=&#x27;index&#x27;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">    //页面渲染出来的是 1 3 3 4</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;11&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      arr:[1,2,3,4],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    test() &#123;</span><br><span class="line">      this.arr[0] = 11;</span><br><span class="line">      console.log(this.arr);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created()&#123;</span><br><span class="line">    this.arr[1] = 3;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.arr[2] = 12;</span><br><span class="line">    // console.log(this.arr); [1,3,12,4]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么会这样，因为 data里面检测不到 对数组的改动。created的赋值，为什么被视图监测到了？</p>
<p>尤大大的文档： </p>
<blockquote>
<p>当你把一个普通的 JavaScript 对象传入 ==Vue 实例==作为 data 选项，Vue 将==遍历==此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 ==getter/setter==。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
</blockquote>
<blockquote>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面</p>
</blockquote>
<p>通俗语言解释下</p>
<p>vue创建实例的时候，会把我们data里面的所有数据，全部转为getter 与 setter。</p>
<p>所以created 正是创建vue实例的时候。所以 isok。</p>
<p>但是 如果我们在 mounted生命周期函数里面操作的话，如果我们写个事件对data里面的数组赋值的话。</p>
<p>就必须要使用 this.$set方法。来进行。</p>
<h5 id="使用-this-set-方法。"><a href="#使用-this-set-方法。" class="headerlink" title="使用 $this.set()方法。"></a>使用 $this.set()方法。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for=&quot;(item,index) in arr&quot; :key=&#x27;index&#x27;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;11&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      arr:[1,2,3,4],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    test() &#123;</span><br><span class="line">      this.$set(this.arr,1,12);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created()&#123;</span><br><span class="line">    this.$set(this.arr,0,2);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // console.log(this.arr)</span><br><span class="line">    this.arr[1] = 3;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Vue.set( target, propertyName/index, value )</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件基础</title>
    <url>/blogs/2021/06/25/vue%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="vue的组件基础"><a href="#vue的组件基础" class="headerlink" title="vue的组件基础"></a>vue的组件基础</h4><p>创建一个组件</p>
<p>1，我们在src文件夹下面的components文件下，创建了一个组件。代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;cell&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            count:0,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>和平常写的vue组件没啥两样。</p>
<h5 id="关于组件的复用"><a href="#关于组件的复用" class="headerlink" title="关于组件的复用"></a>关于组件的复用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;My-cell&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;My-cell&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;My-cell&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;My-cell&gt;&lt;/My-cell&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个组件都是独立的。里面的值不会出现窜。</p>
<p>组件的data必须必须必须是一个函数。<br>所以每个组件实例都会都可以维护一个返回实例的拷贝。</p>
<h5 id="关于组件中的prop。"><a href="#关于组件中的prop。" class="headerlink" title="关于组件中的prop。"></a>关于组件中的prop。</h5><p>1,prop是一个单向数据流，数据从组件外，自然而然的流向组件内。<br>2，组件内顶柜的prop来接收，组件外的指定参数。<br>3，prop可以校验数据的格式。</p>
<p>组件添加props</p>
<p>props我们可以指定数据类型与格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#x27;我想静静&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    content:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#x27;假装我是一篇文章....&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    number:&#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        default:0,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell :content=&quot;content&quot; :title=&quot;title&quot;&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content:&#x27;你好阿，小老弟&#x27;,</span><br><span class="line">      title:&#x27;你好aaaa    &#x27;,</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h5><p>使用emit(),抛出事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;click()&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;cell&quot;,</span><br><span class="line">  props:&#123;</span><br><span class="line">      title:&#123;</span><br><span class="line">          type:String,</span><br><span class="line">          default:&#x27;我想静静&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      content:&#123;</span><br><span class="line">          type:String,</span><br><span class="line">          default:&#x27;假装我是一篇文章....&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      number:&#123;</span><br><span class="line">          type:Number,</span><br><span class="line">          default:0,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click() &#123;</span><br><span class="line">        this.$emit(&#x27;getdata&#x27;,this.number);//0</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>getdata 拿到事件抛出的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell :content=&quot;content&quot; :title=&quot;title&quot; @getdata=&#x27;getdata&#x27;&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content:&#x27;你好阿，小老弟&#x27;,</span><br><span class="line">      title:&#x27;你好aaaa    &#x27;,</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata(e)&#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="组件的插槽，可以命名。让组件更加灵活。"><a href="#组件的插槽，可以命名。让组件更加灵活。" class="headerlink" title="组件的插槽，可以命名。让组件更加灵活。"></a>组件的插槽，可以命名。让组件更加灵活。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用组件的 slot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell&gt;</span><br><span class="line">      &lt;div slot=&quot;header&quot;&gt;11&lt;/div&gt;</span><br><span class="line">       &lt;div slot=&quot;main&quot;&gt;22&lt;/div&gt;</span><br><span class="line">        &lt;div slot=&quot;footer&quot;&gt;33&lt;/div&gt;</span><br><span class="line">    &lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content:&#x27;你好阿，小老弟&#x27;,</span><br><span class="line">      title:&#x27;你好aaaa    &#x27;,</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata(e)&#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5><p>插槽可以命名，也可以绑定数据。但是必须要使用template 元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot; :user=&#x27;obj&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;cell&quot;,</span><br><span class="line">  data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">          obj:&#123;</span><br><span class="line">              name:&#x27;里斯哦&#x27;,</span><br><span class="line">              age:11,</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<p>我们可以使用 scope.user.name,来访问数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell&gt;</span><br><span class="line">      &lt;template v-slot:header=&#x27;scope&#x27;&gt;&#123;&#123;scope.user.name&#125;&#125;&lt;/template&gt;</span><br><span class="line">       &lt;div slot=&quot;main&quot;&gt;22&lt;/div&gt;</span><br><span class="line">        &lt;div slot=&quot;footer&quot;&gt;33&lt;/div&gt;</span><br><span class="line">    &lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj:&#123;</span><br><span class="line">        name:11,</span><br><span class="line">        age:&#x27;111&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata(e)&#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h5 id="组件的动态切换插槽。"><a href="#组件的动态切换插槽。" class="headerlink" title="组件的动态切换插槽。"></a>组件的动态切换插槽。</h5><p>v-slot:[参数]</p>
<p>例子如下，组件我们2个插槽都会给上不同的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;zz&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot; :usr=&#x27;obj&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;main&quot; :username=&#x27;obj.name&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot; :age=&#x27;obj.age&#x27;&gt;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;cell&quot;,</span><br><span class="line">  data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">          obj:&#123;</span><br><span class="line">              name:&#x27;里斯哦&#x27;,</span><br><span class="line">              age:11,</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell&gt;</span><br><span class="line">      &lt;template v-slot:header=&quot;scope&quot;&gt;&#123;&#123; scope.usr.name &#125;&#125;&lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:[name]=&quot;scope&quot;&gt;&#123;&#123;scope&#125;&#125;&lt;/template&gt;</span><br><span class="line">    &lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj: &#123;</span><br><span class="line">        name: 11,</span><br><span class="line">        age: &quot;111&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      name: &quot;footer&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata(e) &#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>插槽可以缩写 用#来表示 v-slot:header=’scope’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;My-cell&gt;</span><br><span class="line">  &lt;template #header=&#x27;scope&#x27;&gt;&#123;&#123; scope.usr.name &#125;&#125;&lt;/template&gt;</span><br><span class="line">  &lt;template #[name]=&quot;scope&quot;&gt;&#123;&#123;scope&#125;&#125;&lt;/template&gt;</span><br><span class="line">&lt;/My-cell&gt;</span><br></pre></td></tr></table></figure>



<p>总结</p>
<table>
<thead>
<tr>
<th>组件属性</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>$emit()</td>
<td>子组件抛出去一个自定义事件，传一个参数。</td>
</tr>
<tr>
<td>props</td>
<td>单向数据流，父传子，监测数据类型，默认值。</td>
</tr>
<tr>
<td>slot</td>
<td>带一个插槽，可以指定名字，也可以成为作用域插槽，#表示缩写。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中class与style绑定</title>
    <url>/blogs/2021/06/23/vue%E4%B8%AD%E7%9A%84class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h5 id="class的绑定"><a href="#class的绑定" class="headerlink" title="class的绑定"></a>class的绑定</h5><p>1.通过v-bind：对象语法绑定class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; class=&quot;b-b-w-1&quot; :class=&quot;&#123;active:isactive,error:isactive&#125;&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>class中的 active 的绑定完全依赖于 isactive的布尔值。<br>class 绑定的静态类型与v-bind绑定动态类型，class最终还是会汇聚到一起。也就是这个样子。</p>
<p>class=’b-b-w-1 active error’;</p>
<p>绑定class的对象不一定非要在，模板里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; class=&quot;b-b-w-1&quot; :class=&quot;objclass&quot; value=&quot;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">   data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">	    objclass:&#123;</span><br><span class="line">		active:true,</span><br><span class="line">		error:true,</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class=’b-b-w-1 active error’;</p>
<p>2.给class绑定一个数组，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; class=&quot;b-b-w-1&quot; :class=&quot;[&#x27;active&#x27;,&#x27;isactive&#x27;]&quot; value=&quot;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>甚至我们还能使用三元运算符 来绑定class。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; value=&quot;&quot; v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, &#x27;errorClass&#x27;]&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; value=&quot;&quot; :class=&quot;activeClass == isActive ? &#x27;&#x27;:&#x27;errorClass&#x27;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.给组件绑定class</p>
<p>class会将被添加到组件的根元素上。</p>
<p>简单写个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;myElement class=&#x27;test test1&#x27; &gt;&lt;/myElement&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果组件添加一个class，组件上本身就已经有一个class了。那么就不会覆盖。而是，共存。</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;myElement class=&#x27;test test&#x27; &gt;&lt;/myElement&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>4.v-bind绑定 内联样式，强烈不推荐内联的写法。<br>但是必要的时候还是离不开，因为只有pc有hover效果，移动端需要active来模拟。</p>
<p>so，<br>看例子把。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&quot; :style=&quot;&#123;color:&#x27;red&#x27;,backgroundColor:size&#125;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写样式最好使用 驼峰命名，第二个单词首字母大写。</p>
<p>内联样式绑定对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&quot; :style=&quot;objStyle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">objStyle:&#123;</span><br><span class="line">	backgroundColor:&#x27;red&#x27;,</span><br><span class="line">	color:&#x27;#ffffff&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内联样式 同样也可以绑定，数组语法。数组里面的对象是样式的集合。但是却没有class名。</p>
<p>优点就是我们省下来一个class名，确定就是权重贼高。</p>
<p>数组语法和对象语法，阅读起来更舒服。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;input type=&quot;text&quot; value=&quot;&quot; :style=&quot;[objStyle,objStyle1]&quot; /&gt;</span><br><span class="line"></span><br><span class="line">   objStyle: &#123;</span><br><span class="line">	backgroundColor: &#x27;red&#x27;,</span><br><span class="line">	color: &#x27;#ffffff&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">objStyle1: &#123;</span><br><span class="line">	color: &#x27;#ffffff&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue计算属性与侦听器</title>
    <url>/blogs/2021/06/23/vue%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h4 id="vue的计算属性与侦听器"><a href="#vue的计算属性与侦听器" class="headerlink" title="vue的计算属性与侦听器"></a>vue的计算属性与侦听器</h4><p>computed的特性</p>
<ol>
<li>computed会观察data里面的所有数据的变化。</li>
<li>computed，观察改变的数据，你有使用才会执行。</li>
<li>computed数据会有缓存，计算的是默认值，你有你值改变了才会再次计算。</li>
</ol>
<h5 id="computed的-getter函数，与setter函数。"><a href="#computed的-getter函数，与setter函数。" class="headerlink" title="computed的 getter函数，与setter函数。"></a>computed的 getter函数，与setter函数。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上代码</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class=&quot;content&quot;&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; v-model=&quot;value  &quot; /&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; v-model=&quot;value1&quot; /&gt;</span><br><span class="line">		&#123;&#123;example&#125;&#125;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				value: 1,</span><br><span class="line">				value1: 11,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		computed: &#123;</span><br><span class="line">			// 计算属性的 getter</span><br><span class="line">			example: &#123;</span><br><span class="line">				get(e) &#123;</span><br><span class="line">					console.log(e)</span><br><span class="line">					return e.value * 2;</span><br><span class="line">				&#125;,</span><br><span class="line">				set(value) &#123;</span><br><span class="line">					this.value = value;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		onLoad() &#123;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">		onShow() &#123;</span><br><span class="line">		    //调用setter函数赋值。</span><br><span class="line">			this.example = 122;</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="computed与watch的区别。"><a href="#computed与watch的区别。" class="headerlink" title="computed与watch的区别。"></a>computed与watch的区别。</h5><p>computed更适合，针对一个数据的变化而进行变化。比如商品的价格等于，件数*价格-优惠券-折扣卡。这样的值，更适合computed来去做。<br>因为computed需要依赖其他数据。</p>
<p>watch的改变。更多程度上，更适用于，一个数据发生变化后做一些事情。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue模板语法的查漏补缺</title>
    <url>/blogs/2021/06/22/vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%E7%9A%84%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h4 id="一直以来，都没有认真的看过vue的文档。所以把一些细节性的东西给过一遍。查漏补缺。"><a href="#一直以来，都没有认真的看过vue的文档。所以把一些细节性的东西给过一遍。查漏补缺。" class="headerlink" title="一直以来，都没有认真的看过vue的文档。所以把一些细节性的东西给过一遍。查漏补缺。"></a>一直以来，都没有认真的看过vue的文档。所以把一些细节性的东西给过一遍。查漏补缺。</h4><h5 id="1-关于vue的模板语法，表达式。我使用的很少很少。"><a href="#1-关于vue的模板语法，表达式。我使用的很少很少。" class="headerlink" title="1.关于vue的模板语法，表达式。我使用的很少很少。"></a>1.关于vue的模板语法，表达式。我使用的很少很少。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status是0</span><br><span class="line">&lt;view class=&quot;&quot;&gt;</span><br><span class="line">    &#123;&#123;status ? &#x27;是&#x27;:&#x27;否&#x27;&#125;&#125;//否</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;&quot;&gt;</span><br><span class="line">    &#123;&#123;status ? &#x27;已激活&#x27;:&#x27;已冻结&#x27;&#125;&#125;//已冻结</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">在模板里面使用 三元表达式，我们可以省下一个过滤器。</span><br></pre></td></tr></table></figure>

<h5 id="1-1-关于使用，我们都知道-vue的v-bind可以绑定参数。如果他是一个动态参数呢？"><a href="#1-1-关于使用，我们都知道-vue的v-bind可以绑定参数。如果他是一个动态参数呢？" class="headerlink" title="1.1 关于使用，我们都知道 vue的v-bind可以绑定参数。如果他是一个动态参数呢？"></a>1.1 关于使用，我们都知道 vue的v-bind可以绑定参数。如果他是一个动态参数呢？</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a :[type]=&quot;url&quot;&gt;百度&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		url:&#x27;https://www.baidu.com/&#x27;,</span><br><span class="line">		type:&#x27;href&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="1-2-v-on的修饰符。"><a href="#1-2-v-on的修饰符。" class="headerlink" title="1.2 v-on的修饰符。"></a>1.2 v-on的修饰符。</h5><p>v-on是用来 给vue的元素，绑定事件的。</p>
<p>例子如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们绑定了一个touch的事件。</span><br><span class="line">&lt;button type=&quot;default&quot; v-on:tap=&quot;touch()&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>但是，如果碰到了问题呢，比如我一个元素上面绑定了2个事件，大家都知道事件冒泡，和事件捕获。这个时候，v-on绑定事件的时候的的修饰符，就非常有必要了。</p>
<p>v-on的修饰符，用.来表示。</p>
<p>再看一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view type=&quot;default&quot; v-on:tap=&quot;touch()&quot;&gt;</span><br><span class="line">	&lt;text @tap=&quot;test()&quot;&gt;你好&lt;/text&gt;</span><br><span class="line">	&lt;text&gt;世界&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">		</span><br><span class="line">touch()&#123;</span><br><span class="line">	console.log(&#x27;11&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">test()&#123;</span><br><span class="line">	console.log(&#x27;22&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">//触发test（）,打印结果，11，22</span><br><span class="line">		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先有2点，v-on：绑定事件的时候 可以简写为@。其次我们遇到了事件冒泡问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view type=&quot;default&quot; v-on:tap=&quot;touch()&quot;&gt;</span><br><span class="line">	&lt;text @tap.stop=&quot;test()&quot;&gt;你好&lt;/text&gt;</span><br><span class="line">	&lt;text&gt;世界&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">		</span><br><span class="line">touch()&#123;</span><br><span class="line">	console.log(&#x27;11&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">test()&#123;</span><br><span class="line">	console.log(&#x27;22&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">//v-on.stop修饰符 替我们阻止了事件的冒泡。</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>v-on的修饰符还有很多。</p>
<table>
<thead>
<tr>
<th>v-on的修饰符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>stop</td>
<td>阻止事件冒泡</td>
</tr>
<tr>
<td>once</td>
<td>事件只执行一次</td>
</tr>
<tr>
<td>prevent</td>
<td>阻止默认事件</td>
</tr>
<tr>
<td>capture</td>
<td>事件捕获</td>
</tr>
<tr>
<td>:keyup.enter</td>
<td>键盘事件，enter是回车</td>
</tr>
</tbody></table>
<hr>
<h4 id="总结知识点"><a href="#总结知识点" class="headerlink" title="总结知识点"></a>总结知识点</h4><ul>
<li>模板的三元表达式</li>
<li>指令的动态参数。[type]=’text’;</li>
<li>v-on绑定事件的修饰符。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件的双向绑定</title>
    <url>/blogs/2021/06/22/vue%E7%9A%84%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h4 id="vue组件的双向绑定。"><a href="#vue组件的双向绑定。" class="headerlink" title="vue组件的双向绑定。"></a>vue组件的双向绑定。</h4><p>一直以来vue自定义组件，都有个问题困惑我。prop，好像是一个单向数据流，父组件的数据可以传向子组件，可是子组件。无法修改父组件的值。</p>
<p>输入框的v-model也只是一个语法糖，实际上。还是把要传进来的值接受到之后再去通过$emit<br>自定义事件和值给抛了出去。</p>
<p>例子如下，我使用的是 uniapp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&#x27;updata&#x27; /&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &quot;inputfield&quot;,</span><br><span class="line">		props: &#123;</span><br><span class="line">			value: &#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">		    //输入框输入触发，input事件的时候，我们使用emit()，把值给抛出去。value得到了更新。</span><br><span class="line">			updata(e)&#123;</span><br><span class="line">				this.$emit(&#x27;input&#x27;,e.detail.value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="sync是vue的修饰符，可以帮助props，实现双向绑定。"><a href="#sync是vue的修饰符，可以帮助props，实现双向绑定。" class="headerlink" title=".sync是vue的修饰符，可以帮助props，实现双向绑定。"></a>.sync是vue的修饰符，可以帮助props，实现双向绑定。</h5><p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//sync绑定了value，</span><br><span class="line">&lt;inputfield :value.sync=&quot;value&quot; /&gt;</span><br><span class="line">&#123;&#123;value&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们看看组件内部是如何实现的</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		&lt;view class=&quot;&quot;&gt;</span><br><span class="line">			&#123;&#123;value&#125;&#125;</span><br><span class="line">			&lt;button type=&quot;default&quot; @tap=&#x27;run&#x27;&gt;run&lt;/button&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &quot;inputfield&quot;,</span><br><span class="line">		props: &#123;</span><br><span class="line">			value: &#123;</span><br><span class="line">				type: Boolean,</span><br><span class="line">				default: false,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			run() &#123;</span><br><span class="line">				//使用 emit触发一个update事件，然后:value，是我们子组件要改变的属性。</span><br><span class="line">				if (this.value) &#123;</span><br><span class="line">					this.$emit(&#x27;update:value&#x27;, false);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					this.$emit(&#x27;update:value&#x27;, true);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局复习</title>
    <url>/blogs/2021/06/21/flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="flex给项目排序"><a href="#flex给项目排序" class="headerlink" title="flex给项目排序"></a>flex给项目排序</h3><h5 id="例子如下"><a href="#例子如下" class="headerlink" title="例子如下"></a>例子如下</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    color: #fff;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    border: 1px solid #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    order: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">    order: 2;</span><br><span class="line">&#125;</span><br><span class="line">.box3&#123;</span><br><span class="line">    order: 3;</span><br><span class="line">&#125;</span><br><span class="line">.box4&#123;</span><br><span class="line">    order: 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>flex布局下面的item，根据order的大小来进行排序，数值越小越靠前。</p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>分配flex下面的item成员的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box div&#123;</span><br><span class="line">    color: #fff;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    border: 1px solid #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    flex-grow: 2;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box3&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box4&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box5&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box6&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box7&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="flex-shrink属性。"><a href="#flex-shrink属性。" class="headerlink" title="flex-shrink属性。"></a>flex-shrink属性。</h4><p>当flex布局下面的item成员的宽度超过了，flex盒子的空间不足，flex-shrink，可以给他们全部等比缩小。默认为1，一个item成员flex-shrink为0，其他为1，那么前面的盒子不缩小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box div&#123;</span><br><span class="line">    color: #fff;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    border: 1px solid #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    flex-shrink: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box3&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box4&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box5&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box6&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box7&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="flex的-align-self属性"><a href="#flex的-align-self属性" class="headerlink" title="flex的 align-self属性"></a>flex的 align-self属性</h4><p>在flex父级盒子 对item下的成员使用，align-items center还是什么的时候，align-self，可以覆盖align-items的属性，只对items成员有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    height: 300;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.box div&#123;</span><br><span class="line">    color: #fff;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    border: 1px solid #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    flex-shrink: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box3&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box4&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    align-self: baseline;</span><br><span class="line">&#125;</span><br><span class="line">.box5&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box6&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box7&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    align-self: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>使用css做一个九宫格</title>
    <url>/blogs/2021/06/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E4%B9%9D%E5%AE%AB%E6%A0%BC/</url>
    <content><![CDATA[<h4 id="css中的，九宫格的实现。"><a href="#css中的，九宫格的实现。" class="headerlink" title="css中的，九宫格的实现。"></a>css中的，九宫格的实现。</h4><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1，2个商品排列在一起，我很难处理其中的间距。因为如果左右各设10px,他俩之间有20px的间距。<br>2，那么我们如果只给一边间距的话，那么最左边以及最右边，总会多出来。还需要我们去清理。</p>
<p>解决方案如下。</p>
<p>1，flex布局。我们需要计算长度。非常非常准确的长度。css的calc()函数准确的满足了我的需要。比如，一个盒子是100%，我们一行三列。margin-right 是10px。实际上我们需要的只是，20px的marin值就够了。</p>
<p>那么就是 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width:calc((100%-20px)/3);</span><br></pre></td></tr></table></figure>
<p>2,通过width:calc((100%-20px)/3);，我们至少拿到了，确切的宽度。剩下的是要清除。盒子，marin-right第三个，要清除10px。再写一个类，去清除是一个非常麻烦，且死板的事情。</p>
<h5 id="nth-of-type选择器，"><a href="#nth-of-type选择器，" class="headerlink" title="nth-of-type选择器，"></a>nth-of-type选择器，</h5><p>1,文档：，:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素.<br>可以匹配父元素下面的每一子元素，并且带着规则。比如偶数，奇数，或者倍数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">    width: calc((100% - 20px) / 3);</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-of-type(3n)&#123;</span><br><span class="line">    margin-right: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>nth-of-type(3n)，清楚了第三个，第六个，第九个的盒子。边距。</p>
<h5 id="nth-last-child选择器"><a href="#nth-last-child选择器" class="headerlink" title=":nth-last-child选择器"></a>:nth-last-child选择器</h5><p>匹配父元素下面的子元素的，从最后开始算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1:nth-last-child(3)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(2)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(1)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    width: 92%;</span><br><span class="line">    padding: 10px 4%;</span><br><span class="line">    height: 900px;</span><br><span class="line">    background-color: #f7f7f7;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    width: calc((100% - 20px) / 3);</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-of-type(3n)&#123;</span><br><span class="line">    margin-right: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(3)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(2)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(1)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中，class的使用</title>
    <url>/blogs/2021/06/21/Es6%E4%B8%ADclass%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="ES6中的Class"><a href="#ES6中的Class" class="headerlink" title="ES6中的Class"></a>ES6中的Class</h3><h4 id="1-首先我们可以回归一下ES5之前的类是如何实现的。"><a href="#1-首先我们可以回归一下ES5之前的类是如何实现的。" class="headerlink" title="1.首先我们可以回归一下ES5之前的类是如何实现的。"></a>1.首先我们可以回归一下ES5之前的类是如何实现的。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一个类</span><br><span class="line">function Tool(name)&#123;</span><br><span class="line">    this.name=&#x27;张三&#x27;;</span><br><span class="line">    this.run = function()&#123;</span><br><span class="line">        alert(`$&#123;this.name&#125;,在奔跑`);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//实例化</span><br><span class="line">var tool = new Tool(&#x27;李四&#x27;);</span><br><span class="line">tool.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用create创建类</span><br><span class="line">var Dog = &#123;</span><br><span class="line">    name:&#x27;大黄&#x27;,</span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(&#x27;我是大黄&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">Dog.prototype.name = &#x27;王五&#x27;;</span><br><span class="line">var dog = Object.create(Dog);</span><br><span class="line"></span><br><span class="line">//使用  Object.create 创建的类 没有 静态类型 ，prototype</span><br><span class="line">dog.run();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-ES6的class"><a href="#2-ES6的class" class="headerlink" title="2.ES6的class"></a>2.ES6的class</h4><p>1.es6的class更想是一个语法糖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//es6的类</span><br><span class="line">class Prson &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(&#x27;你好啊&#x27;+this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var prson = new Prson(&#x27;弟弟&#x27;);</span><br><span class="line">prson.run();//你好啊 弟弟</span><br><span class="line">console.log(prson)</span><br><span class="line">console.log(Prson === Prson.prototype.constructor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Prson的原型链的构造器指向了Prson函数。所以 es6的构造函数也有prototype</span><br></pre></td></tr></table></figure>

<h4 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h4><p>constructor是类的默认方法，只要new实例化的时候，就会调用。即使我们写，也会添加···</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sayName();</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name);//小明</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const person = new Person(&#x27;小明&#x27;,11);</span><br><span class="line">//关于 constructor 类的默认方法。new实例化后会默认调用。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-class的特性"><a href="#4-class的特性" class="headerlink" title="4.class的特性"></a>4.class的特性</h4><p>1.class的方法除非你定义在实例化的对象上，否则都是定义在prototype上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sayName();</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const person = new Person(&#x27;小明&#x27;,11);</span><br><span class="line">//类的方法只要不是定义在实例化后的对象上，就只能定义在prototype上面。</span><br><span class="line">person.love = ()=&gt;&#123;</span><br><span class="line">   console.log(11);</span><br><span class="line">&#125;</span><br><span class="line">person.love();</span><br><span class="line">console.log(Person.prototype.love)//undefined</span><br><span class="line">//关于 constructor 类的默认方法。new实例化后会默认调用。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.类只能先声明，后实例化。没有变量提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// error index.js:13 Uncaught ReferenceError: Cannot access &#x27;Person&#x27; before initialization</span><br><span class="line">const person = new Person(&#x27;小明&#x27;,11);</span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sayName();</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="class的静态方法。"><a href="#class的静态方法。" class="headerlink" title="class的静态方法。"></a>class的静态方法。</h4><p>1.静态方法只能在class上面调用。实例无法使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//class的静态方法 只能在类上调用，实例无法使用。</span><br><span class="line"></span><br><span class="line">class Dog&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    static run(name)&#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var dog = new Dog(&#x27;大黄&#x27;);</span><br><span class="line">Dog.run(&#x27;李四&#x27;);</span><br><span class="line">dog.run(&#x27;胖虎&#x27;);// dog.run is not a function</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>2.如果静态方法包含this，那么这个this指向class，而不是实例。（class的静态方法只能调用静态方法，不能调用实例方法。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">//class的静态方法 只能在类上调用，实例无法使用。</span><br><span class="line"></span><br><span class="line">class Dog&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    static run(name)&#123;</span><br><span class="line">        this.pay();</span><br><span class="line">    &#125;;</span><br><span class="line">    pay()&#123;</span><br><span class="line">        console.log(&#x27;狗狗去付账&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">    static pay()&#123;</span><br><span class="line">        console.log(&#x27;狗狗去福州&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dog.pay();//index.js:16 狗狗去福州</span><br><span class="line">var dog = new Dog(&#x27;大黄&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从这里我们能得出 class的静态方法与实例方法可以重名。</p>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>1.class里面加入 static 的属性就是静态属性，实例无法使用。只能给class使用。<br>2.和静态方法一样，静态属性与实例属性可以重名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//class的静态属性。</span><br><span class="line"></span><br><span class="line">class Dog &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    static name = 11;</span><br><span class="line">&#125;;</span><br><span class="line">var dog = new Dog(&#x27;大黄&#x27;);</span><br><span class="line">console.log(Dog.name,dog.name)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="关于class的extends，实现继承。"><a href="#关于class的extends，实现继承。" class="headerlink" title="关于class的extends，实现继承。"></a>关于class的extends，实现继承。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// class继承</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    run(name)&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//cat 继承了 Animalclass</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">var cat = new Cat();</span><br><span class="line">cat.run(&#x27;李四&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="class-super关键字"><a href="#class-super关键字" class="headerlink" title="class super关键字"></a>class super关键字</h4><p>1.super可以作为函数，也可以作为对象。<br>2.子类继承父类之前，没有super函数，是不能使用this的。<br>3.super在子类的构造函数里面代表了父类的构造器。<br>4.super作为对象，调用父类的实例方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// class继承</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">     run()&#123;</span><br><span class="line">        console.log(&#x27;111&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//cat 继承了 Animalclass</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    constructor(name,age,color)&#123;</span><br><span class="line">        //super代表父类的构造函数。</span><br><span class="line">        super(name,age,color);</span><br><span class="line">        console.log(this.name,this.age)</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        //super指向父类的实例方法。</span><br><span class="line">        super.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var cat = new Cat(&#x27;李四&#x27;,11,&#x27;red&#x27;);</span><br><span class="line">cat.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.class是一个语法糖，本身还是基于prototype来做的继承。<br>2.静态类型static，只能在这个class访问。实例化的对象无法访问。<br>3.静态方法也只能给这个类去用。实例化后的对象无法使用。<br>4.子类继承父类，super必须要在构造器中作为函数使用。<br>5.super既可以当作函数也可以当作对象。作为函数，在子类构造器中代表了父类构造函数<br>作为对象代表了父类实例方法，在静态类型的方法中，指向父类。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>我的想法</title>
    <url>/blogs/2021/06/11/hello-world/</url>
    <content><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><h2 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1 自我介绍"></a>1 自我介绍</h2><p>1.我是一个比较热爱技术，沉默寡言的我。学历不高，受教育程度有限，使我在选择这门活计的时候犹豫了很久，最后抱着试试看的心态做的。<br>2.怕什么真理无穷，进一寸有一寸的欢喜</p>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>自我表达</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的async与await</title>
    <url>/blogs/2021/06/05/JavaScript%E4%B8%AD%E7%9A%84async/</url>
    <content><![CDATA[<h4 id="在JavaScript中，async与await的使用"><a href="#在JavaScript中，async与await的使用" class="headerlink" title="在JavaScript中，async与await的使用"></a>在JavaScript中，async与await的使用</h4><h5 id="1-async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。"><a href="#1-async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。" class="headerlink" title="1.async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。"></a>1.async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义一个异步函数。</span><br><span class="line">function one()&#123;  </span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        console.log(&#x27;11&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">定义一个async函数</span><br><span class="line">async function test()&#123;</span><br><span class="line">    await one();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(test());--Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">打印出来的async函数是一个promise对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">既然async函数内置了 promise对象，那么就可以使用then来调用。</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;success&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="2-async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。"><a href="#2-async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。" class="headerlink" title="2.async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。"></a>2.async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function timer() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">    await timer().then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;2000之后执行&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">demo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-那么为什么使用async而不是-直接去用promise呢？"><a href="#3-那么为什么使用async而不是-直接去用promise呢？" class="headerlink" title="3.那么为什么使用async而不是 直接去用promise呢？"></a>3.那么为什么使用async而不是 直接去用promise呢？</h5><p>原因很简单，因为，我们假设一个情况，promise A方法成功之后去调，Promise B方法，以此类推。是的promise其实已经很好了，但是。then多了 恐怕你不会觉得它优雅。<br>其次，我有八个异步方法，我需要等他们执行完毕后，一起告诉我结果。到底是成功和失败。async函数 更好一些。</p>
<p>请看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    await timer(1000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步A&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(2000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步B&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(5000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步C&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return Promise.resolve();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//控制台打印结果</span><br><span class="line">/*</span><br><span class="line">异步A</span><br><span class="line">index.js:157 异步B</span><br><span class="line">index.js:160 异步C</span><br><span class="line">index.js:166 异步执行完毕</span><br><span class="line">*/</span><br><span class="line">demo().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;异步执行完毕&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于async函数的理解，就像一辆校车。必须要等所有的同学都上车了才能发车。await函数全部执行完毕了，才能拿到成功还是失败。</p>
<h5 id="async函数执行，我们必须要把promise的结果给-return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。"><a href="#async函数执行，我们必须要把promise的结果给-return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。" class="headerlink" title="async函数执行，我们必须要把promise的结果给 return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。"></a>async函数执行，我们必须要把promise的结果给 return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    await timer(1000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步A&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(2000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步B&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(5000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步C&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return Promise.resolve();//所以我们在这里把 promise的状态 return出去。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//控制台打印结果</span><br><span class="line">/*</span><br><span class="line">异步A</span><br><span class="line">index.js:157 异步B</span><br><span class="line">index.js:160 异步C</span><br><span class="line">index.js:166 异步执行完毕</span><br><span class="line">*/</span><br><span class="line">demo().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;异步执行完毕&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="谈谈await的理解。"><a href="#谈谈await的理解。" class="headerlink" title="谈谈await的理解。"></a>谈谈await的理解。</h5><p>1.await必须要在async函数里面使用。否则报错。<br>2.await函数表示一个等待，它返回的不是promise对象，而是promise的结果。<br>3，await函数，会阻止async函数的执行。JavaScript是一个从上往下执行的语言。但是，await可以跳出async函数，继续往后面执行。</p>
<h5 id="关于await的执行顺序。"><a href="#关于await的执行顺序。" class="headerlink" title="关于await的执行顺序。"></a>关于await的执行顺序。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function timer(timer) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            return resolve(timer + 1000);</span><br><span class="line">        &#125;, timer);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">function one(num) &#123;</span><br><span class="line">    console.log(&#x27;第一次不延迟&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">function two(num) &#123;</span><br><span class="line">    console.log(&#x27;第二次延迟&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">function three(num) &#123;</span><br><span class="line">    console.log(&#x27;第三次延迟+&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    let time = 1000;</span><br><span class="line">    const timer1 = await one(time);</span><br><span class="line">    const timer2 = await two(timer1);</span><br><span class="line">    const timer3 = await three(timer2);</span><br><span class="line">    console.log(&#x27;第四次延迟&#x27;,timer3);</span><br><span class="line">    return Promise.resolve();</span><br><span class="line">&#125;;</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;end&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">timer(1000).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;11&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">控制台打印</span><br><span class="line">1.第一次不延迟1000，因为test函数的变量值，传了进去，执行了one方法。  </span><br><span class="line">因为跳出async函数后，执行了timer也是异步方法。</span><br><span class="line">2.第二次延迟2000，所以继续执行two，还是遇到了await，跳出去。</span><br><span class="line">3.11，跳出来执行，timer异步任务结束。</span><br><span class="line">4.第三次延迟，3000，拿到了two函数的返回值。await跳出async函数，可惜async函数外部没有可执行的函数了。</span><br><span class="line">5.第四次，延迟，three函数的返回值出来了。</span><br><span class="line">6.11，await函数执行完毕，promise给结果。</span><br></pre></td></tr></table></figure>
<h5 id="async函数异常不好捕捉。try-catch-配合使用。"><a href="#async函数异常不好捕捉。try-catch-配合使用。" class="headerlink" title="async函数异常不好捕捉。try catch 配合使用。"></a>async函数异常不好捕捉。try catch 配合使用。</h5><p>反面案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//async函数异常不好捕捉，一个异常，后续方法都不会执行了。</span><br><span class="line">function run(value)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(value)&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">async function test()&#123;</span><br><span class="line">    await run(true);</span><br><span class="line">    await run(false);</span><br><span class="line">&#125;;</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;成功了&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">//控制台Uncaught (in promise) undefined</span><br></pre></td></tr></table></figure>

<p>正确方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用try catch配合。</span><br><span class="line">function run(value) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (value) &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await run(false);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.log(&#x27;run(false)报错&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        await run(true);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.log(&#x27;run(true)报错&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">test().then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;成功了&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">//控制台run(false)报错，成功了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1.async是语法糖，也是一个关键字。<br>2.async函数，内置promise。<br>3.async函数默认，resolve。必须return才能改变。<br>4.async函数，必须等所有的await函数都有结果了，promise才会有结果。<br>5.async函数，只要有一个await异步任务异常就会停止。<br>6.async函数建议配合try，catch。抛出异常，继续执行下个异步任务。</p>
<p>1.await代表一个异步任务。<br>2.await必须要在async里面用。<br>3.await函数，里面同步的方法还是会执行的。遇到promise，跳出async，等待。<br>4.await返回的不是promise对象，只是promise的结果。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
