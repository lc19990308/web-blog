<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript中的async与await</title>
    <url>/2021/06/05/JavaScript%E4%B8%AD%E7%9A%84async/</url>
    <content><![CDATA[<h4 id="在JavaScript中，async与await的使用"><a href="#在JavaScript中，async与await的使用" class="headerlink" title="在JavaScript中，async与await的使用"></a>在JavaScript中，async与await的使用</h4><h5 id="1-async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。"><a href="#1-async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。" class="headerlink" title="1.async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。"></a>1.async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义一个异步函数。</span><br><span class="line">function one()&#123;  </span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        console.log(&#x27;11&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">定义一个async函数</span><br><span class="line">async function test()&#123;</span><br><span class="line">    await one();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(test());--Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">打印出来的async函数是一个promise对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">既然async函数内置了 promise对象，那么就可以使用then来调用。</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;success&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="2-async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。"><a href="#2-async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。" class="headerlink" title="2.async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。"></a>2.async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function timer() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">    await timer().then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;2000之后执行&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">demo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-那么为什么使用async而不是-直接去用promise呢？"><a href="#3-那么为什么使用async而不是-直接去用promise呢？" class="headerlink" title="3.那么为什么使用async而不是 直接去用promise呢？"></a>3.那么为什么使用async而不是 直接去用promise呢？</h5><p>原因很简单，因为，我们假设一个情况，promise A方法成功之后去调，Promise B方法，以此类推。是的promise其实已经很好了，但是。then多了 恐怕你不会觉得它优雅。<br>其次，我有八个异步方法，我需要等他们执行完毕后，一起告诉我结果。到底是成功和失败。async函数 更好一些。</p>
<p>请看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    await timer(1000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步A&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(2000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步B&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(5000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步C&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return Promise.resolve();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//控制台打印结果</span><br><span class="line">/*</span><br><span class="line">异步A</span><br><span class="line">index.js:157 异步B</span><br><span class="line">index.js:160 异步C</span><br><span class="line">index.js:166 异步执行完毕</span><br><span class="line">*/</span><br><span class="line">demo().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;异步执行完毕&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于async函数的理解，就像一辆校车。必须要等所有的同学都上车了才能发车。await函数全部执行完毕了，才能拿到成功还是失败。</p>
<h5 id="async函数执行，我们必须要把promise的结果给-return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。"><a href="#async函数执行，我们必须要把promise的结果给-return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。" class="headerlink" title="async函数执行，我们必须要把promise的结果给 return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。"></a>async函数执行，我们必须要把promise的结果给 return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    await timer(1000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步A&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(2000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步B&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(5000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步C&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return Promise.resolve();//所以我们在这里把 promise的状态 return出去。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//控制台打印结果</span><br><span class="line">/*</span><br><span class="line">异步A</span><br><span class="line">index.js:157 异步B</span><br><span class="line">index.js:160 异步C</span><br><span class="line">index.js:166 异步执行完毕</span><br><span class="line">*/</span><br><span class="line">demo().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;异步执行完毕&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="谈谈await的理解。"><a href="#谈谈await的理解。" class="headerlink" title="谈谈await的理解。"></a>谈谈await的理解。</h5><p>1.await必须要在async函数里面使用。否则报错。<br>2.await函数表示一个等待，它返回的不是promise对象，而是promise的结果。<br>3，await函数，会阻止async函数的执行。JavaScript是一个从上往下执行的语言。但是，await可以跳出async函数，继续往后面执行。</p>
<h5 id="关于await的执行顺序。"><a href="#关于await的执行顺序。" class="headerlink" title="关于await的执行顺序。"></a>关于await的执行顺序。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function timer(timer) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            return resolve(timer + 1000);</span><br><span class="line">        &#125;, timer);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">function one(num) &#123;</span><br><span class="line">    console.log(&#x27;第一次不延迟&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">function two(num) &#123;</span><br><span class="line">    console.log(&#x27;第二次延迟&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">function three(num) &#123;</span><br><span class="line">    console.log(&#x27;第三次延迟+&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    let time = 1000;</span><br><span class="line">    const timer1 = await one(time);</span><br><span class="line">    const timer2 = await two(timer1);</span><br><span class="line">    const timer3 = await three(timer2);</span><br><span class="line">    console.log(&#x27;第四次延迟&#x27;,timer3);</span><br><span class="line">    return Promise.resolve();</span><br><span class="line">&#125;;</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;end&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">timer(1000).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;11&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">控制台打印</span><br><span class="line">1.第一次不延迟1000，因为test函数的变量值，传了进去，执行了one方法。  </span><br><span class="line">因为跳出async函数后，执行了timer也是异步方法。</span><br><span class="line">2.第二次延迟2000，所以继续执行two，还是遇到了await，跳出去。</span><br><span class="line">3.11，跳出来执行，timer异步任务结束。</span><br><span class="line">4.第三次延迟，3000，拿到了two函数的返回值。await跳出async函数，可惜async函数外部没有可执行的函数了。</span><br><span class="line">5.第四次，延迟，three函数的返回值出来了。</span><br><span class="line">6.11，await函数执行完毕，promise给结果。</span><br></pre></td></tr></table></figure>
<h5 id="async函数异常不好捕捉。try-catch-配合使用。"><a href="#async函数异常不好捕捉。try-catch-配合使用。" class="headerlink" title="async函数异常不好捕捉。try catch 配合使用。"></a>async函数异常不好捕捉。try catch 配合使用。</h5><p>反面案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//async函数异常不好捕捉，一个异常，后续方法都不会执行了。</span><br><span class="line">function run(value)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(value)&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">async function test()&#123;</span><br><span class="line">    await run(true);</span><br><span class="line">    await run(false);</span><br><span class="line">&#125;;</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;成功了&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">//控制台Uncaught (in promise) undefined</span><br></pre></td></tr></table></figure>

<p>正确方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用try catch配合。</span><br><span class="line">function run(value) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (value) &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await run(false);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.log(&#x27;run(false)报错&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        await run(true);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.log(&#x27;run(true)报错&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">test().then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;成功了&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">//控制台run(false)报错，成功了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1.async是语法糖，也是一个关键字。<br>2.async函数，内置promise。<br>3.async函数默认，resolve。必须return才能改变。<br>4.async函数，必须等所有的await函数都有结果了，promise才会有结果。<br>5.async函数，只要有一个await异步任务异常就会停止。<br>6.async函数建议配合try，catch。抛出异常，继续执行下个异步任务。</p>
<p>1.await代表一个异步任务。<br>2.await必须要在async里面用。<br>3.await函数，里面同步的方法还是会执行的。遇到promise，跳出async，等待。<br>4.await返回的不是promise对象，只是promise的结果。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
