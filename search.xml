<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>css当中的BFC</title>
    <url>/blogs/2022/12/21/css%E5%BD%93%E4%B8%AD%E7%9A%84BFC/</url>
    <content><![CDATA[<h5 id="到底什么是bfc"><a href="#到底什么是bfc" class="headerlink" title="到底什么是bfc"></a>到底什么是bfc</h5><p>Block formatting contexts 也叫做”块格式化上下文”。简单来说，bfc容器在内部有一块独立的空间。不管内部的元素如何布局，如何排列，它们都不回影响到外部的布局。就像一个规则。</p>
<p>举个例子，</p>
<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog_bfc1.jpeg" alt="什么是bfc"></p>
<p><strong>孙悟空</strong>画的圈圈，就是<strong>BFC</strong>，而里面的唐僧等人，就是BFC容器内部的子元素。</p>
<p>外部的容器打扰不到BFC内部的布局，BFC容器，也不会影响到外部的布局。。</p>
<h5 id="BFC-有什么用？为什么要使用它。"><a href="#BFC-有什么用？为什么要使用它。" class="headerlink" title="BFC,有什么用？为什么要使用它。"></a>BFC,有什么用？为什么要使用它。</h5><p>为什么要使用bfc</p>
<p>举个例子，</p>
<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog_bfc2.jpeg" alt="如果不使用bfc的话"></p>
<p><strong>子元素</strong>(乘客)，就会<strong>挤出</strong>容器，导致影响到外部的布局。。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;div class=&quot;Container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;p&gt;林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">.Container &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChatb847b01c1e81db03fd5eb205c3048678.png" alt="容器被子元素挤出"></p>
<p>因为，Container，大小只有100px，box1+box2，大小已经超出了100px，那么元素就会溢出。这个时候就会影响到，下面的布局。。</p>
<p>bfc容器，子元素在空间不足的情况下，不会影响到外部布局。。</p>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;div class=&quot;BFC_box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;林尽水源，便得一山，山有小口，仿佛若有光。便舍船，从口入。初极狭，才通人。复行数十步，豁然开朗。&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.BFC_box &#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>效果图</p>
<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChatb3ca569dc952680bb8ab7b50e2bd73a8.png" alt="bfc容器，子元素不会影响到外部布局"></p>
<h5 id="如何触发bfc"><a href="#如何触发bfc" class="headerlink" title="如何触发bfc"></a>如何触发bfc</h5><ol>
<li><p>根元素；</p>
</li>
<li><p>浮动元素。元素的 float 不是 none；</p>
</li>
<li><p>绝对定位元素。元素的 position 为 absolute 或 fixed；</p>
</li>
<li><p>行内块元素。元素的 display 为 inline-block；</p>
</li>
<li><p>表格单元格。元素的 display为 table-cell，HTML表格单元格默认为该值；</p>
</li>
<li><p>表格标题。元素的 display 为 table-caption，HTML表格标题默认为该值；</p>
</li>
<li><p>匿名表格单元格元素。元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table；</p>
</li>
<li><p>overflow 值不为 visible 的块元素 ；</p>
</li>
<li><p>弹性元素。display为 flex 或 inline-flex元素的直接子元素；</p>
</li>
<li><p>网格元素。display为 grid 或 inline-grid 元素的直接子元素。</p>
</li>
</ol>
<h5 id="bfc都有哪些用处。"><a href="#bfc都有哪些用处。" class="headerlink" title="bfc都有哪些用处。"></a>bfc都有哪些用处。</h5><ol>
<li>出现mrigin重叠。</li>
<li>可以应用到两栏布局。</li>
<li>清除内部的元素的浮动。</li>
</ol>
<p>marigin 重叠。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-bottom: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-top: 40px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>效果图</p>
<p><a href="https://imgse.com/i/zIlvoq"><img src="https://s1.ax1x.com/2022/12/14/zIlvoq.md.png" alt="zIlvoq.md.png"></a></p>
<p>按道理来讲  margin-top: 40px;，margin-bottom: 100px;那么，上下边距得有140px的，但是2个盒子之间的上下边距，会被折叠，取最大的那个。所以。上下只有100px的边距。</p>
<p>bfc可以清除浮动。</p>
<p>现在产生一个浮动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;p&gt;111&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    width: 600px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box1 &#123;</span><br><span class="line">    margin: 0 10px;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2 &#123;</span><br><span class="line">    margin: 0 10px;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>效果图<br><a href="https://imgse.com/i/zI8use"><img src="https://s1.ax1x.com/2022/12/14/zI8use.md.png" alt="zI8use.md.png"></a></p>
<p>给.box添加 display：flex，</p>
<p>效果图。</p>
<p><a href="https://imgse.com/i/zI8TW6"><img src="https://s1.ax1x.com/2022/12/14/zI8TW6.md.png" alt="zI8TW6.md.png"></a></p>
<p>以下就是bfc格式化块级上下文的理解。bfc容器，不影响到外部容器。marigin会折叠。会清清楚浮动。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css当中的BFC</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始学习vuex</title>
    <url>/blogs/2022/12/21/%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%AD%A6%E4%B9%A0vuex/</url>
    <content><![CDATA[<h4 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h4><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<p>用通俗的话，来说，当一个vue项目，复杂起来的时候，就需要一个vue 组件全局状态管理的工具。vuex就是一个这样的工具。</p>
<h4 id="vuex的state"><a href="#vuex的state" class="headerlink" title="vuex的state"></a>vuex的state</h4><p>把vuex 当中的state，在组件里展示出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    token: &quot;&quot;,</span><br><span class="line">    count: 1,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      return this.$store.state.user.count;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用mapState 辅助函数</p>
<p>当我们需要在一个组件state当中获取到，多个状态的时候。</p>
<p>代码如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState &#125; from &quot;vuex&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;HomeView&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 10,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    count: (state) =&gt; state.user.count,</span><br><span class="line">    token: (state) =&gt; state.user.token,</span><br><span class="line">    countPlusLocalState(state) &#123;</span><br><span class="line">      return state.user.count + this.num;</span><br><span class="line">    &#125;,</span><br><span class="line">    msg: &quot;msg&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mapState,可以帮助我们更好的生成计算属性，获取到store里面的状态。</p>
<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  // 映射 this.count 为 store.state.count</span><br><span class="line">  &#x27;count&#x27;</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>mapState，是一个对象，刚才的那种写法影响到了，我们使用计算属性。这时候我们可以用对象展开运算符写法，以免这样的情况发生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      count: (state) =&gt; state.user.count,</span><br><span class="line">      plus: (state) =&gt; &#123;</span><br><span class="line">        console.log(thit.num);</span><br><span class="line">        return state.user.count;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">    plusNum: () =&gt; &#123;</span><br><span class="line">      return thit.num + 10;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    thit = this;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以在计算属性，照常使用，data里面的参数，与store里面的参数相加。</p>
<p>也能把computed，mapState分开来。</p>
<p>对于需要经常去进行通讯的组件来说，vuex，极大了弥补了，单向数据流带来的不足。<br>vuex，更方便调试，更直观。但是，却不好维护，所以，非必要的情况下，组件的局部状态还是保存到局部为好。</p>
<h4 id="vuex当中的Getter"><a href="#vuex当中的Getter" class="headerlink" title="vuex当中的Getter"></a>vuex当中的Getter</h4><blockquote>
<p>有时候我们需要从 store 中的 state 中派生出一些状态，比如store里面有个count，我们需要对count，进行加倍。这个时候，使用getter，就非常好使。</p>
</blockquote>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  dounceCount() &#123;</span><br><span class="line">    return this.$store.getters.doubleCount;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getter通过属性访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;超级加倍&#123;&#123; $store.getters.doubleCount &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getter通过方法去访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doubleCount() &#123;</span><br><span class="line">    return thit.$store.getters.doubleCount;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>mapGetters辅助函数，当我们需要多个getter的时候，可以使用mapGetters函数，将store里面的getter属性映射到，computed上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...mapGetters([&quot;doneCount&quot;]),</span><br></pre></td></tr></table></figure>

<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...mapGetters([&#123;doneCount:doneCount&#125;]),</span><br></pre></td></tr></table></figure>




<h4 id="vuex-mutation的使用"><a href="#vuex-mutation的使用" class="headerlink" title="vuex mutation的使用"></a>vuex mutation的使用</h4><p>修改，store里面的状态的唯一方法就是，mutation。</p>
<p>首先我们要在mutation方法里面注册一个，更改store的事件或者是方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  pluNum(state, payload) &#123;</span><br><span class="line">    console.log(state.count, payload);</span><br><span class="line">    state.count += payload;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>mutation会有一个type，一个回调函数，实际上，pluNum，就是我们事件类型的type，而pluNum，就是我们的回调函数，是我们修改，它会接受state，作为一个参数，第二个参数为payload。</p>
<p>在回调函数内部，对store当中的state进行修改。</p>
<p>如何提交一个mutation呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.commit(&#x27;pluNum&#x27;, 10)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>store.commit()，第一个注册的mutation名字，第二个是传递过来的参数。</p>
<p>以对象的方式，提交mutation,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &lt;div</span><br><span class="line">    @click=&quot;</span><br><span class="line">      $store.commit(&#123;</span><br><span class="line">        type: &#x27;pluNum&#x27;,</span><br><span class="line">        data: 10,</span><br><span class="line">      &#125;)</span><br><span class="line">    &quot;</span><br><span class="line">  &gt;</span><br><span class="line">    count自增</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> mutations: &#123;</span><br><span class="line">  pluNum(state, payload) &#123;</span><br><span class="line">    console.log(payload);</span><br><span class="line">    state.count += payload.data;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接受的时候，payload.data,就是要传递过来的参数。</p>
<p>使用常量代替mutation事件类型。</p>
<p>创建一个mutation-types.js文件来保存常量。使用export 导出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const PLUS_NUM = &quot;PLUS_NUM&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>store模块代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; PLUS_NUM &#125; from &quot;../mutation-types.js&quot;;</span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  [PLUS_NUM](state, payload) &#123;</span><br><span class="line">    console.log(payload);</span><br><span class="line">    state.count += payload.data;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>提交store.commit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  @click=&quot;</span><br><span class="line">    $store.commit(&#123;</span><br><span class="line">      type: &#x27;PLUS_NUM&#x27;,</span><br><span class="line">      data: 10,</span><br><span class="line">    &#125;)</span><br><span class="line">  &quot;</span><br><span class="line">&gt;</span><br><span class="line">  count自增</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Mutation必须是一个同步函数。</p>
<p>使用mapMutations提交 mutation函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click=&quot;add(&#123; data: 12 &#125;)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">import &#123; mapState, mapGetters, mapMutations &#125; from &quot;vuex&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: &quot;PLUS_NUM&quot;,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="vuex-Action"><a href="#vuex-Action" class="headerlink" title="vuex Action"></a>vuex Action</h4><p>action类似于mutation，不同是，</p>
<p>action是异步，action，可以提交mutation，但是不能直接改变，state的状态。</p>
<p>注册一个action</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment(&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      commit(&quot;PLUS_NUM&quot;, 12);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<p>action的分发。</p>
<p>actioon接受一个叫，context，和store实例对象相同的对象。<br>context，内置了，getter，commit，state，</p>
<p>载荷方式分发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&quot;increment&quot;, &#123; data: 15 &#125;);</span><br></pre></td></tr></table></figure>
<p>以对象形式分发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$store.dispatch(&#123;</span><br><span class="line">  type: &quot;increment&quot;,</span><br><span class="line">  data: 15,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在组件里面分发，action。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div @click=&quot;increment(&#123; data: 15 &#125;)&quot;&gt;count自增&lt;/div&gt;</span><br><span class="line">import &#123;  mapActions &#125; from &quot;vuex&quot;;</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([&quot;increment&quot;]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<p>组合式Action。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA(&#123; commit &#125;, params) &#123;</span><br><span class="line">    return new Promise((resolve) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(params);</span><br><span class="line">        commit(&quot;PLUS_NUM&quot;, params);</span><br><span class="line">        resolve(&quot;actionA方法执行成功&quot;);</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  actionB(&#123; dispatch &#125;) &#123;</span><br><span class="line">    return dispatch(&quot;actionA&quot;, &#123; data: 11 &#125;).then(() =&gt; &#123;</span><br><span class="line">      console.log(&quot;actionB方法执行成功&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">  add() &#123;</span><br><span class="line">    this.$store.dispatch(&quot;actionB&quot;, &#123; data: 11 &#125;).then((res) =&gt; &#123;</span><br><span class="line">      console.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="vuex-module的使用"><a href="#vuex-module的使用" class="headerlink" title="vuex module的使用"></a>vuex module的使用</h4><p>由于使用单一状态树，所有的应用状态，都会集中到一个对象上，会导致整个store，变大，难易维护。为了解决这个问题，vuex允许我们，把store分割为module模块，每个模块拥有<br>state，getter，mutation，action。</p>
<p>关于module的命名空间。</p>
<p>默认的情况下，action，mutation，和getter，注册的是全局命名空间。这样以来，会导致，多个模块对同一个action，或者getter mutation做出响应。</p>
<p>假设我们在一个大项目，我们希望我们的模块有更高的复用性，封装度。可以开启模块的命名空间。。</p>
<p>给我们的user模块，打开命名空间。  namespaced: true,</p>
<p>一旦打开命名空间后，我们获取到的，getter派生出来的值，提交mutition，action都会发生变化。。</p>
<p>先从，getter说起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//vuex模块，</span><br><span class="line">getters: &#123;</span><br><span class="line">    doneCount(state) &#123;</span><br><span class="line">        return state.count * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">...mapGetters([&quot;doneCount&quot;]),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个时候控制台就会报错，error，[vuex] unknown getter: doneCount。因为，获取，state的时候，我们是这些写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">  count: (state) =&gt; state.user.count,</span><br><span class="line">  plus: (state) =&gt; &#123;</span><br><span class="line">    return state.user.count;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>直接从，state.user模块，导出了，state的值。</p>
<p>开启命名空间后，获取user模块下面的getter，就得通过，mapGetter提供的对象写法。把user/doneCount的值映射到，”doneCount”上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">  doneCount: &quot;user/doneCount&quot;,</span><br><span class="line">&#125;),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么，如果我们要提交一个mutation呢，怎么办呢？</p>
<p>mapMutiton写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  //vuex部分</span><br><span class="line">  mutations: &#123;</span><br><span class="line">   [PLUS_NUM](state, payload) &#123;</span><br><span class="line">     state.count += payload.data;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line">...mapMutations(&#123;</span><br><span class="line">   PLUS_NUM: &quot;user/PLUS_NUM&quot;,</span><br><span class="line">&#125;),</span><br><span class="line"> </span><br><span class="line">&lt;div @click=&quot;PLUS_NUM(&#123; data: 11 &#125;)&quot;&gt;mutation自增&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>store.commit写法。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line"> [PLUS_NUM](state, payload) &#123;</span><br><span class="line">   state.count += payload.data;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"> //store.commit写法</span><br><span class="line"> test(data) &#123;</span><br><span class="line">   this.$store.commit(&quot;user/PLUS_NUM&quot;, data);</span><br><span class="line"> &#125;,</span><br><span class="line">&lt;div @click=&quot;test(&#123; data: 11 &#125;)&quot;&gt;mutation自增&lt;/div&gt;   </span><br></pre></td></tr></table></figure>



<p>action写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mapActions写法</span><br><span class="line">...mapActions(&#123;</span><br><span class="line">  add: &quot;user/actionA&quot;,</span><br><span class="line">&#125;),</span><br><span class="line">//store.dispatch写法</span><br><span class="line">test(data) &#123;</span><br><span class="line">  this.$store.dispatch(&quot;user/actionA&quot;, data);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>假如，在vuex模块化当中，在b模块，获取到a模块的getter派生出来的值。要如何获取呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是模块a</span><br><span class="line">export default &#123;</span><br><span class="line">  namespaced: true,</span><br><span class="line">  state: &#123;</span><br><span class="line">    price: 100,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doublePrice(state) &#123;</span><br><span class="line">      return state.price * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模块b，</span><br><span class="line"></span><br><span class="line"> getters: &#123;</span><br><span class="line">    doneCount(state, getters, rootState, rootGetters) &#123;</span><br><span class="line">      console.log(&quot;另一个模块化getter的值&quot;,  </span><br><span class="line">      rootGetters[&quot;cart/doublePrice&quot;]);</span><br><span class="line">      return state.count * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>带命名空间的模块，如果想要使用全局的state，getter，rootState 和 rootGetters 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。</p>
<p>带命名空间绑定函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  // 使用对象展开运算符将此对象混入到外部对象中</span><br><span class="line">  // ...mapState(&#123;</span><br><span class="line">  //   count: (state) =&gt; state.user.count,</span><br><span class="line">  //   plus: (state) =&gt; &#123;</span><br><span class="line">  //     return state.user.count;</span><br><span class="line">  //   &#125;,</span><br><span class="line">  // &#125;),</span><br><span class="line">  ...mapState(&quot;user&quot;, &#123;</span><br><span class="line">    count: (state) =&gt; state.count,</span><br><span class="line">    plus: (state) =&gt; state.count,</span><br><span class="line">  &#125;),</span><br><span class="line">  plusNum: () =&gt; &#123;</span><br><span class="line">    return thit.num + 10;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...mapGetters(&#123;</span><br><span class="line">  //   doneCount: &quot;user/doneCount&quot;,</span><br><span class="line">  // &#125;),</span><br><span class="line">  ...mapGetters(&quot;user&quot;, &#123;</span><br><span class="line">    doneCount: &quot;doneCount&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line">  thit = this;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations(&quot;user&quot;, &#123;</span><br><span class="line">    PLUS_NUM: &quot;PLUS_NUM&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  //mapActions写法</span><br><span class="line">  ...mapActions(&quot;user&quot;, &#123;</span><br><span class="line">    add: &quot;actionA&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  //store.dispatch写法</span><br><span class="line">  test(data) &#123;</span><br><span class="line">    this.$store.dispatch(&quot;user/actionA&quot;, data);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>我有点反感，vuex 的写法。。mapstate(‘路径’，导出的参数)，这样只能导出一个模块的参数。觉得更低效了。。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>vuex核心概念，state，与，getter，mutation，action。</p>
<p>mutation与action的区别是，一个同步一个异步。任何对store进行修改的操作都要经过，mutation。</p>
<p>action，可以提交mutation。也可以多重action。嵌套着玩。</p>
<p>getter，派生出来的东西 rootgetter，获取其他模块的getter。</p>
<p>namespaced，开启空间命名。。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>VueX</tag>
      </tags>
  </entry>
  <entry>
    <title>ES Modules的特性</title>
    <url>/blogs/2022/12/06/es_modules%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>很长的一段时间内，我以为，es modules的关键字import，export,只能在vue里面，使用，是因为webpack，这样的打包工具，才能得已实现的。<br>甚至让我觉得，原生js不行的原因就是因为，不支持es moduls。</p>
<p>陷入了一定的误区，这篇文章，来修正我的认知错误。</p>
<h5 id="原生js使用es-module进行模块化。"><a href="#原生js使用es-module进行模块化。" class="headerlink" title="原生js使用es module进行模块化。"></a>原生js使用es module进行模块化。</h5><p>使用script 加载js文件的时候 <strong><u>type = ‘module’</u></strong> 就可以开启模块化。</p>
<p><a href="https://imgse.com/i/xTjKx0"><img src="https://s1.ax1x.com/2022/11/01/xTjKx0.md.png" alt="xTjKx0.md.png"></a></p>
<h5 id="注意，es-module，默认开启的严格模式。我来证明给您看。"><a href="#注意，es-module，默认开启的严格模式。我来证明给您看。" class="headerlink" title="注意，es module，默认开启的严格模式。我来证明给您看。"></a>注意，es module，默认开启的严格模式。我来证明给您看。</h5><p><a href="https://imgse.com/i/xTj92t"><img src="https://s1.ax1x.com/2022/11/01/xTj92t.png" alt="xTj92t.png"></a></p>
<p><a href="https://imgse.com/i/xTjVaQ"><img src="https://s1.ax1x.com/2022/11/01/xTjVaQ.png" alt="xTjVaQ.png"></a></p>
<p>看吧，控制台上this是 undefined</p>
<h5 id="原生js，使用import，export"><a href="#原生js，使用import，export" class="headerlink" title="原生js，使用import，export"></a>原生js，使用import，export</h5><p>在上图的index.html文件下的index.js export抛出，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p>
<p>在test import，引入。<br><a href="https://imgse.com/i/xTjnGn"><img src="https://s1.ax1x.com/2022/11/01/xTjnGn.png" alt="xTjnGn.png"></a></p>
<p>控制台，打印的结果是，{a: 11}</p>
<h5 id="es-module，加载是通过cors进行的。"><a href="#es-module，加载是通过cors进行的。" class="headerlink" title="es module，加载是通过cors进行的。"></a>es module，加载是通过cors进行的。</h5><p>如果 <strong><script type='module' src=''> </script></strong><br>如果，这里的 <strong>src</strong>加载的是服务器资源的话，如果资源不支持cors的话，会被浏览器拦截。</p>
<p>例子如下，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p>
<p>支持，cors 加载的资源，type = ‘module’ 会被浏览器所加载，不支持cors的，会被浏览器拦截，这点服务端需要注意。</p>
<p><a href="https://imgse.com/i/xTj1qU"><img src="https://s1.ax1x.com/2022/11/01/xTj1qU.png" alt="xTj1qU.png"></a></p>
<p>cors，不支持文件的访问，所以，必须使用，http，serve的方式进行访问。</p>
<p><strong>使用，文件访问导致的后果</strong></p>
<p><a href="https://imgse.com/i/xTjlrT"><img src="https://s1.ax1x.com/2022/11/01/xTjlrT.png" alt="xTjlrT.png"></a></p>
<h5 id="es-module，自带脚本延迟效果"><a href="#es-module，自带脚本延迟效果" class="headerlink" title="es module，自带脚本延迟效果"></a>es module，自带脚本延迟效果</h5><p>当页面，加载完毕后，才会加载，es module脚本。<br><a href="https://imgse.com/i/xTjQMV"><img src="https://s1.ax1x.com/2022/11/01/xTjQMV.png" alt="xTjQMV.png"></a></p>
<p>当所有的，非es module加载完毕后，才能加载es module模块。</p>
<p>总结，<br>es module的特性是，<br>1，默认就是严格模式<br>2，每个module模块，都拥有私有的作用域。<br>3，只支持cors，加载。本地必须开启 web serve<br>4，自带延迟效果</p>
<h5 id="关于import-export-一些小知识。"><a href="#关于import-export-一些小知识。" class="headerlink" title="关于import export 一些小知识。"></a>关于import export 一些小知识。</h5><p>我们可以使用，export，到处一些变量方法，也可以，export，设置默认导出的方法。</p>
<p><a href="https://imgse.com/i/xTjEVg"><img src="https://s1.ax1x.com/2022/11/01/xTjEVg.jpg" alt="xTjEVg.jpg"></a></p>
<p>接收默认到处的值</p>
<p><a href="https://imgse.com/i/xTjiKf"><img src="https://s1.ax1x.com/2022/11/01/xTjiKf.png" alt="xTjiKf.png"></a></p>
<p>接收默认导出的值</p>
<p><a href="https://imgse.com/i/xTjmPs"><img src="https://s1.ax1x.com/2022/11/01/xTjmPs.png" alt="xTjmPs.png"></a></p>
<p><strong>as 关键字，修改默认导出的值</strong></p>
<p>export <strong>as关键字修改 变量名</strong></p>
<p><a href="https://imgse.com/i/xTj8ZF"><img src="https://s1.ax1x.com/2022/11/01/xTj8ZF.png" alt="xTj8ZF.png"></a></p>
<p><a href="https://imgse.com/i/xTjGa4"><img src="https://s1.ax1x.com/2022/11/01/xTjGa4.png" alt="xTjGa4.png"></a><br>import <strong>as修改接收参数的变量名</strong></p>
<h5 id="export-导出的并不是一个对象-import-引入的也不是个对象的解构。"><a href="#export-导出的并不是一个对象-import-引入的也不是个对象的解构。" class="headerlink" title="export 导出的并不是一个对象 import 引入的也不是个对象的解构。"></a>export 导出的并不是一个对象 import 引入的也不是个对象的解构。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">export &#123;</span><br><span class="line">    num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然export后面跟着 {} 看起来很像对象， { name },看起来很像es6，字面量的写法。</p>
<p>import 在这里 **{}**，就像使用对象字面量解构一样，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; num &#125; from &#x27;./test.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>export {}</strong> 和 <strong>import {}</strong> 是 es modulc的固定语法。</p>
<p>export 导出的只是，内存地址。<br>export 导出的，是常量。只能在 export 内部修改。</p>
<p><strong>例子如下</strong></p>
<p>导出num</p>
<p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p>
<p><a href="https://imgse.com/i/xTjNGR"><img src="https://s1.ax1x.com/2022/11/01/xTjNGR.png" alt="xTjNGR.png"></a></p>
<p>控制台报错，index.js:4 Uncaught TypeError: Assignment to constant variable.<br>    at index.js:4:4</p>
<p>因为，我们import引入的，<strong>num</strong> 是个常量。无法在外部，对 import 引入的 num进行修改。</p>
<p><strong>那么，怎么样导入，一个字面量对象呢？</strong></p>
<p>使用 <strong>export default</strong></p>
<p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p>
<h5 id="import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"><a href="#import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。" class="headerlink" title="import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"></a>import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。</h5><p>如果export 导入了很多属性。我们可以使用import * 把所有的导出全部接收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">let name = &#x27;张三&#x27;;</span><br><span class="line">let age = 12;</span><br><span class="line">let sigin = &#x27;为什么&#x27;</span><br><span class="line">export &#123;</span><br><span class="line">    num,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sigin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import * as module from &#x27;./test.js&#x27;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure>

<p>import * as module 导入全部的要导出的模块。</p>
<p>试想，我们有一个这样的需求，根据判断条件，来决定要导入，那个模块。</p>
<p>import 必须要在最外层，最顶层的作用域当中。不能嵌套在if，或者funtion当中。</p>
<p>es modulc，提供了一个，<strong>import</strong>函数，来帮助我们动态的导入模块。而且，import(),本身是一个promise函数。</p>
<p><a href="https://imgse.com/i/xTjFr8"><img src="https://s1.ax1x.com/2022/11/01/xTjFr8.png" alt="xTjFr8.png"></a></p>
<p>这样通过，then,那么就能读取到模块了。</p>
<p>import 可以导入一个，url链接模块<br><a href="https://imgse.com/i/xTju2q"><img src="https://s1.ax1x.com/2022/11/01/xTju2q.png" alt="xTju2q.png"></a></p>
<p>import 导出默认成员与，命名成员<br><a href="https://imgse.com/i/xTjkqS"><img src="https://s1.ax1x.com/2022/11/01/xTjkqS.png" alt="xTjkqS.png"></a></p>
<p>总结，es module，</p>
<ol>
<li>在原生js当中使用，script标签，type应该使用，module。module默认就在严格模式环境下，this不可能指向全局。</li>
<li>每个模块都拥有了独立的，私有的作用域。</li>
<li>module加载，模块，会存在cors问题，需要服务端专门设置，本地必须开启，web sever</li>
<li>type = module后，会存在延迟效果，等页面资源加载完毕后，再去加载。</li>
</ol>
<p>总结，import的特性</p>
<ol>
<li>import {} 并非对象的解构，而是语法就是这样的。</li>
<li>import，导入的属性，只可以读取。import导入的是常量，无法修改。</li>
<li>import * model from 可以把，所有导出的属性，全部导入到一个对象里面。</li>
<li>import，可以导入url模块，</li>
<li>import必须在顶部，不可以在函数，条件语句下面。</li>
<li>import()，可以动态导入，<strong>import</strong>默认本身就是一个promise方法。</li>
<li>import as 可以更换导入的属性别名。</li>
<li>import num，{age,age1} from ‘../../‘可以导入，默认的成员与命名的成员。</li>
</ol>
<p>总结，export的特性</p>
<ol>
<li>export {} 这是语法，抛出的不是一个，字面量对象，export default是抛出对象。</li>
<li>export 抛出去的值是内存地址的引用，值，只能在export模块里面修改。</li>
<li>as 可以修改默认要导出的值的别名。</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>import export的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>初学webpack</title>
    <url>/blogs/2022/12/06/%E5%88%9D%E5%AD%A6webpack/</url>
    <content><![CDATA[<h5 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h5><blockquote>
<p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些预设，打包为合适的格式以供浏览器使用。</p>
</blockquote>
<p>1，webpack可以分析你项目当中的代码，提取使用到的代码，去除用不到代码。<br>2，配合各种loader，来把sass，less，scss，ts，es新语法，解析成各种各样的文件。<br>3，帮忙把打包的项目，文件通过plugin，进行各种优化，比如压缩，混淆。</p>
<h5 id="webpack模块化打包的原因。"><a href="#webpack模块化打包的原因。" class="headerlink" title="webpack模块化打包的原因。"></a>webpack模块化打包的原因。</h5><ol>
<li>浏览器内核不同，对于技术支持的情况不一样，会存在兼容性问题。</li>
<li>模块化划分下，会增加多余的http请求次数。</li>
<li>不仅仅是js需要模块化，css，img，整个前端项目都需要，进行模块化。</li>
</ol>
<h5 id="webpack的概念"><a href="#webpack的概念" class="headerlink" title="webpack的概念"></a>webpack的概念</h5><p>webpack4以后，webpack配置默认的<strong>entry</strong>就是src目录下的js文件。<br><strong>output</strong>默认输出的path，就是dist下的main.js文件。</p>
<p>我们也可以，新建一个webpack.config.js文件。来设置，<strong>entry与output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//path是node里面的path</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //webpck的入口文件，要模块化打包的js代码目录，是个相对路径，&quot;./&quot;，不能丢。</span><br><span class="line">    entry: &#x27;./src&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;pc&#x27;),//path.resolve,是一个绝对路径，</span><br><span class="line">        filename: &#x27;dist.js&#x27;//要输出的文件名称</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>关于webpack的loader</strong></p>
<p>webpack，可以把，js代码模块化打包，但是，前端不仅仅是css需要打包。还有还有，css，ts，各种资源。</p>
<p>这个时候就得需要配置loader，来处理这些文件。</p>
<h5 id="webpack的工作模式"><a href="#webpack的工作模式" class="headerlink" title="webpack的工作模式"></a>webpack的工作模式</h5><table>
<thead>
<tr>
<th>webpack的工作模式</th>
<th>语法</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>开发环境</td>
<td>webpack –mode development</td>
<td>开发环境下的代码</td>
</tr>
<tr>
<td>原始环境</td>
<td>webpack –mode none</td>
<td>最原始的代码</td>
</tr>
<tr>
<td>生产环境</td>
<td>webpack –mode production</td>
<td>默认就是生产环境下的压缩代码</td>
</tr>
</tbody></table>
<h5 id="关于webpack的loader"><a href="#关于webpack的loader" class="headerlink" title="关于webpack的loader"></a>关于webpack的loader</h5><p><strong>如何去使用loader编译，css代码。</strong></p>
<p>首先使用npm，css loader。</p>
<p>npm i css-loder –dev<br>npm i style-loader –dev</p>
<p>然后设置。webpack.config.js配置的module。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rules，是数组，决定都要使用，那些loader，test，<br>use是个数组，指定要，使用哪些loader。</p>
<p><strong>use设置要使用的loader，打包的时候，会存在先后顺序，比如，把css文件，模块化，打包到，dist文件资源里面，css-loader，解析css文件上使用到的样式，而，style loadr 把样式放入，style到页面上。</strong></p>
<p>并且，通常我们都会把，所有的资源都汇总到，src/main.js，至少是个js文件到情况下。<br>要加载，或者使用到的css文件，直接import到，main.js页面就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //webpck的入口文件，要模块化打包的js代码目录</span><br><span class="line">    entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">        filename: &#x27;bundle.js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.js</span><br><span class="line"></span><br><span class="line">import createHeading from &#x27;./test.js&#x27;</span><br><span class="line">import &#x27;./css/index.css&#x27;</span><br><span class="line">import &#x27;../sass/index.css&#x27;</span><br><span class="line">const heading = createHeading();</span><br><span class="line">console.log(createHeading())</span><br><span class="line">document.body.append(heading);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**entry: ‘./src/index.js’,**输出来的，webpack打包出来的还是一个js文件。顺便把css模块给整合进入。</p>
<h5 id="如何使用loader-file-loader与url-loader。"><a href="#如何使用loader-file-loader与url-loader。" class="headerlink" title="如何使用loader file-loader与url-loader。"></a>如何使用loader file-loader与url-loader。</h5><p>安装file-loader</p>
<p>yarn add file-loader</p>
<p>webpack.config.js配置 file-loader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;,</span><br><span class="line">        &#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: [&#x27;file-loader&#x27;] &#125;,</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后运行，yarn webapck 命令。</p>
<p>输出的dist目录下，会有图片。</p>
<p>但是，如果加载的项目静态资源过多的话，会导致，请求变多。网页卡顿。这个时候，url-loader，就能解决问题。</p>
<p>base64，可以减少我们http请求次数。</p>
<p>设置url-loader的情况下的前提下是，必须安装<strong>file-loader</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123; test: /.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.(jpg|png|gif|bmp|jpeg)$/,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: &#x27;url-loader&#x27;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: 10 * 1024,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后通过，use下的option设置规则，limit: 10 * 1024,这里的10是字节，1024字节是1kb，大于10kb的图片，我们就通过，file-loader，加载到项目当中，小于10kb到情况下，就使用url-loader，base64.</p>
<h4 id="使用webpack-，转换es6代码。"><a href="#使用webpack-，转换es6代码。" class="headerlink" title="使用webpack ，转换es6代码。"></a>使用webpack ，转换es6代码。</h4><p>webpack，只是打包工具。虽然队，import，export，能够转换，但是，对es6并没有进行。</p>
<p>所以我们需要使用，bable-loader插件对es6的代码转换。</p>
<p>例子如下，</p>
<p><strong>安装bable-loader插件</strong></p>
<p>yarn add bable-loader @babel/core @babel/preset-env –dev</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /.js$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &#x27;babel-loader&#x27;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&#x27;@babel/preset-env&#x27;],</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>option,选择 persets，使用@babel/preset-env插件。来对es6代码进行转换。。</p>
<h4 id="webpack加载的资源方式"><a href="#webpack加载的资源方式" class="headerlink" title="webpack加载的资源方式"></a>webpack加载的资源方式</h4><p>webpack不仅仅会通过css-loader 和style-loader 把css样式给打包到一个模块js文件里面。<br>也会，把图片资源 通过，file-loader 或者 url-loadr，打包到js文件里面。</p>
<p>连html都模块也可以打包，但是，html当中我们会引用到其他资源，比如a标签的地址，比如图片加载的资源文件。</p>
<p>所以我们先安装html-loader</p>
<p>yarn add html-loader @1.3.2</p>
<p>配置，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    test: /.html$/,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: &#x27;html-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">        //仅仅限制版本号。1.3.2</span><br><span class="line">            attributes: &#123;</span><br><span class="line">                list: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        tag: &#x27;img&#x27;,</span><br><span class="line">                        attribute: &#x27;src&#x27;,</span><br><span class="line">                        type: &#x27;src&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        tag: &#x27;a&#x27;,</span><br><span class="line">                        attribute: &#x27;href&#x27;,</span><br><span class="line">                        type: &#x27;src&#x27;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过配置attributes的方式，对需要加载资源的标签，进行处理。。</p>
<h5 id="如何自己开发一个loader出来。。"><a href="#如何自己开发一个loader出来。。" class="headerlink" title="如何自己开发一个loader出来。。"></a>如何自己开发一个loader出来。。</h5><p><strong>weboack</strong>除了给我们提供了许许多多的loader以外，我们也可以开发自己的loader来进行使用。。</p>
<p>比如，我们需要把markdown 文件，在webpack打包的时候，转化为html，并且渲染到页面上。。</p>
<p>首先第一步，新建一个markdown-loader.js文件。在src目录下。。<br>然后安装yarn add marked</p>
<p>然后在weback-config.js下，配置loader<br>webpack-config.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">               test: /.md$/,</span><br><span class="line">               use: [</span><br><span class="line">                   &#x27;./src/markdown-loader.js&#x27;,</span><br><span class="line">               ]</span><br><span class="line">           &#125;</span><br><span class="line">       ],</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>use,可指定加载相对路径的loader</p>
<p>//source 是webpack在打包过程中，输入的md文件<br>// return 出去必须是，js语法。通过<strong>module.exports</strong>或者 <strong>return export default</strong> 输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入 marked</span><br><span class="line">const marked = require(&#x27;marked&#x27;);</span><br><span class="line">module.exports = (source) =&gt; &#123;</span><br><span class="line">    const html = marked.marked(source);</span><br><span class="line">    return ` module.exports = $&#123;JSON.stringify(html)&#125;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>然后就能在dist下的markdown 被转换到html到，bundle.js当中了。</p>
<p>当然loader之间可以相互配合使用，比如，markdown文件被转换到，html之后，我们也可以不选择，return export default html。</p>
<p>我们也可以交给，html-loader来处理。</p>
<hr>
<p>markdown-loader 和 html-loader 配合使用。。</p>
<p>mackdown-loader.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const marked = require(&#x27;marked&#x27;);</span><br><span class="line">module.exports = (source) =&gt; &#123;</span><br><span class="line">    const html = marked.marked(source);</span><br><span class="line">    return html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>webpack-config.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /.md$/,</span><br><span class="line">            use: [</span><br><span class="line">                &#x27;html-loader&#x27;,</span><br><span class="line">                &#x27;./src/markdown-loader.js&#x27;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="webpack-Plugins"><a href="#webpack-Plugins" class="headerlink" title="webpack Plugins"></a>webpack Plugins</h4><p>webpack plugins的功能可以，让我们在打包的时候，webpack运行到某个阶段的时候，帮我们做一些事情。</p>
<p>比如，在dist文件夹下面，生成html，比如，每次打包之前，清空dist文件夹。</p>
<p>例子如下，</p>
<p>安装CleanWebpackPlugin，每次打包的dist文件夹的时候，把dist文件下下面上次打包的资源文件清空。</p>
<p>yran add clean-webpack-plugin –dev</p>
<p>webpack-config.js下面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">    ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再比如，dist文件夹下面每次打包发布资源的时候，都没有html页面。</p>
<p>这个时候，我们需要html-webpack-plugin，来使用。</p>
<p>yran add html-webpack-plugin –dev</p>
<p>webpack-config.js</p>
<p>template可以指定html模版作为，HtmlWebpackPlugin输出的index.html模版。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)</span><br><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: &#x27;Webpack Plugin Sample&#x27;,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            viewport: &#x27;width-device-width&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &#x27;./src/template.html&#x27;</span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>webpack初学</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现网站的哀悼模式</title>
    <url>/blogs/2022/12/06/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%93%80%E6%82%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">body&#123;</span><br><span class="line"> filter: grayscale(100%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/WeChat1d1ad09b1ab494616acafe5348a975e4.png" alt="黑白效果图"></p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6844904114053185544">明天全国哀悼日，一段css让全站变灰</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter">mdn</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Data URL</title>
    <url>/blogs/2022/12/06/DataUrl%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h4 id="什么是Data-URL"><a href="#什么是Data-URL" class="headerlink" title="什么是Data URL"></a>什么是Data URL</h4><p>Data URL指的是，前缀为data:协议url。<br>现代浏览器将 <strong>Data URL</strong> 视作唯一的不透明来源，而不是可以用于导航的 URL，<br>不透明质指的是，在浏览器url上，输入上，一段比如<a href="https://baidu.com,我们可以看到这段url最终是要访问那里,而/">https://baidu.com,我们可以看到这段url最终是要访问那里，而</a> <strong>Data Url</strong>，则不是不透明，又长又臭，我们看不出这段url是什么。</p>
<h5 id="Data-URL语法"><a href="#Data-URL语法" class="headerlink" title="Data URL语法"></a>Data URL语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAA2CAYAAAB3Ep8CAAAAAXNSR0IArs4c6QAABTtJREFUaEPVW1Fy4kYU7CflI1W4Kr5B2BME2wcInCDrE8ScIMbs/9oHAPkGi08Q7wnMBWDxDZwb2FUmlY/VvK0RiGAxM280SID5RTNMt1pv+vUIQvCndYwo+gyiFoB28DShA5mfQTQD4x4qvQNmzyFTUcggoNVGFH0BUTNsfMWjGDOotAvMZmVnDiCg1UYcP5T9odqv14pQqlOWhJIEtFqIogcQHdcOKOQHAkgoQcCBg88JY36CUie+NcGTgFYTUfTtYO98US2LmqAfB7EwehCgq338AIKu9uZPmmrGSxegEJWvxsSnFwB9sc7hSYJAgAd4cBfpdLQVmNDBEgnAGOmk45reQcCBg89RRafXIPpsVwKPoKZd2/d2AqJTvc9f2Nnb450vLio6G4HwZwgJZgIk8Iw7qImDnFBNbzFOJuEGanpd/IVNAt4j+BxVfHYP4I8yqn1LgFRUDvHOv0Gb9SdjEP3mS8L/BIjg+RFqat8Kt1BvtUM9SEhxDky0WrAkQPD3rMGrto+xqBZM6GwCCWuWmYDsYu3yzJ3duwOfk6atezwG4RcjjZlRmpwQotNLECWWi16g0ub7ufNFFAIJadrRBNyC6K8NAhgavJb9bi1uqOqt4xwkMN8Q7FvHPdLJeeXr2ceE8ZnOLzZTq4wAl5VkNpoHJ4YkOW4AzXmvV6lyjpKk/drrjUvz5/Q13NVFsIU4/ua7b7oWcDQYrHw5AzMQdbclopEkLWLWd1CHMM/M3Jv3+37Nl9QnpOmHxTZoqwM52rV900ZAYzC4INpoT5+/E5381+s9lb5zAArgV1Mopc7//fQp28etH9nX9KCmt7kPcDsoj6jpaDjU8vy9uCCthDlRB72eGE6sj/05SZo/MWtlmuK3r69XVx/t6M8+IsbfDnq+Ip1k49escOYHtGx/NW+JWeiogw/j3bQRoOcqTYKuI8wP+vk0rYWBu/nVlaUZE6K7gq8pNEM+5sEcNekihcWzauGPR/N+39qXrwYJ4PV134k+mB8rIbpj/gdKtdZ9jaEdDifBUgdW2JhlEhrD4Yhg7+2ZuWsugkKAY/E15jxALiDWlMUDgK7ityaZeIytFHyhBhSWVC8JG0Aag8El2Sz5oo7Yn3spw3Dklu5QVEpZHBM3BoMZufpyok5ubMRHpybwbgXkggglQRczpcYOEp6ZqEN6m3MXz8d5v2/OIUSVytGdx7lAZpT09mhPWWznAklyfKTUE4jMLSmQewPjURszP86jqG30EBWA91NApgT/gKFY3DI3p5SOqWwk2PbNl9coapoNlGDfs73eL73yU8CChCaieGYPGOxncktL6+g3Chwwv3AUtc19RDmj43LLJRSQT1OfR1hfKBOdWMAL6VWWYWij4917lFDAigTp/QDrcZRU7TPbXLHRqVgBy+nEAmQ/jnKZHTt4ALZQI0eYZha9dF4QoIDlL0q9tiNMMZFQl9GpRwHbegTd6w+HuhdfZJHMN6/9/saxVfbdFkRL4AOKoGFK6TjKI0yxLlR81GSjI5EQ/gisZg73CO7F+YcaEkjX9xUQsDJKwWHK5gKr3et3QEBGgsdJjM97O+VDjQNQwPZGaTFDWKhxQATo/Vp6ecnmEXYPvppdwER/CAlbhBqHpYAQj7An8PUpoAwJ2bXO9/1qfR+pom3QIUIpTHHpdwev5NRPgBSm2AgoEWocZg14syohTCki2OFbKTtQgKdHyC9bHGCUCjXegQJWJLjDlD28lbJDBSxJsHmEPYCvfxu0ajNLda/B+rWV5Z+f0vSyTJa3jezXx/4AhsQjITcm0vsAAAAASUVORK5CYII=</span><br><span class="line">    &quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>mediatype</strong>为image/png，指的是，文件的类型。<br>base64为64位字符表示二进制的流。</p>
<p>Data URL，减少http请求次数</p>
<p><a href="https://imgse.com/i/zyBco6"><img src="https://s1.ax1x.com/2022/12/05/zyBco6.jpg" alt="zyBco6.jpg"></a></p>
<p>Data URL，会占html文件的内存空间。<br><a href="https://imgse.com/i/zyBco6"><img src="http://rmeu5gdxe.hd-bkt.clouddn.com/blog2.jpg" alt="zyBco6.jpg"></a></p>
<p>Data URL，加载的图片，不会被缓存下来，每次访问图片都得再下载一次。除非放入css当中缓存下来。</p>
<p>http加载的图片，只需要加载一次，就可以在页面上使用了，而每次使用Data URL作为图片，都会被重新加载。</p>
<p>base64 编码后的图片会比原来的体积大三分之一左右。</p>
<p>使用Data URL方式的Demo在渲染时会比不使用 多消耗53%左右的CPU资源，内存多出4倍左右，耗时平均高出24.6倍 。由此可见，使用Data URl方式还是需要更多的考量，在可接受的范围内适量使用。</p>
<p>Data URL的适用场景。</p>
<p>减轻http并发，减少http请求数量，加载icon的时候，或者作为css文件，引入，iconfont的时候。非常好用。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>使用Data URL，对页面进行优化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用es module模块化编程</title>
    <url>/blogs/2022/11/01/%E5%85%B3%E4%BA%8Ees%20module%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>很长的一段时间内，我以为，es modules的关键字import，export,只能在vue里面，使用，是因为webpack，这样的打包工具，才能得已实现的。<br>甚至让我觉得，原生js不行的原因就是因为，不支持es moduls。</p>
<p>陷入了一定的误区，这篇文章，来修正我的认知错误。</p>
<h5 id="原生js使用es-module进行模块化。"><a href="#原生js使用es-module进行模块化。" class="headerlink" title="原生js使用es module进行模块化。"></a>原生js使用es module进行模块化。</h5><p>使用script 加载js文件的时候 <strong><u>type = ‘module’</u></strong> 就可以开启模块化。</p>
<p><a href="https://imgse.com/i/xTjKx0"><img src="https://s1.ax1x.com/2022/11/01/xTjKx0.md.png" alt="xTjKx0.md.png"></a></p>
<h5 id="注意，es-module，默认开启的严格模式。我来证明给您看。"><a href="#注意，es-module，默认开启的严格模式。我来证明给您看。" class="headerlink" title="注意，es module，默认开启的严格模式。我来证明给您看。"></a>注意，es module，默认开启的严格模式。我来证明给您看。</h5><p><a href="https://imgse.com/i/xTj92t"><img src="https://s1.ax1x.com/2022/11/01/xTj92t.png" alt="xTj92t.png"></a></p>
<p><a href="https://imgse.com/i/xTjVaQ"><img src="https://s1.ax1x.com/2022/11/01/xTjVaQ.png" alt="xTjVaQ.png"></a></p>
<p>看吧，控制台上this是 undefined</p>
<h5 id="原生js，使用import，export"><a href="#原生js，使用import，export" class="headerlink" title="原生js，使用import，export"></a>原生js，使用import，export</h5><p>在上图的index.html文件下的index.js export抛出，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p>
<p>在test import，引入。<br><a href="https://imgse.com/i/xTjnGn"><img src="https://s1.ax1x.com/2022/11/01/xTjnGn.png" alt="xTjnGn.png"></a></p>
<p>控制台，打印的结果是，{a: 11}</p>
<h5 id="es-module，加载是通过cors进行的。"><a href="#es-module，加载是通过cors进行的。" class="headerlink" title="es module，加载是通过cors进行的。"></a>es module，加载是通过cors进行的。</h5><p>如果 <strong><script type='module' src=''> </script></strong><br>如果，这里的 <strong>src</strong>加载的是服务器资源的话，如果资源不支持cors的话，会被浏览器拦截。</p>
<p>例子如下，<br><a href="https://imgse.com/i/xTjZ5j"><img src="https://s1.ax1x.com/2022/11/01/xTjZ5j.png" alt="xTjZ5j.png"></a></p>
<p>支持，cors 加载的资源，type = ‘module’ 会被浏览器所加载，不支持cors的，会被浏览器拦截，这点服务端需要注意。</p>
<p><a href="https://imgse.com/i/xTj1qU"><img src="https://s1.ax1x.com/2022/11/01/xTj1qU.png" alt="xTj1qU.png"></a></p>
<p>cors，不支持文件的访问，所以，必须使用，http，serve的方式进行访问。</p>
<p><strong>使用，文件访问导致的后果</strong></p>
<p><a href="https://imgse.com/i/xTjlrT"><img src="https://s1.ax1x.com/2022/11/01/xTjlrT.png" alt="xTjlrT.png"></a></p>
<h5 id="es-module，自带脚本延迟效果"><a href="#es-module，自带脚本延迟效果" class="headerlink" title="es module，自带脚本延迟效果"></a>es module，自带脚本延迟效果</h5><p>当页面，加载完毕后，才会加载，es module脚本。<br><a href="https://imgse.com/i/xTjQMV"><img src="https://s1.ax1x.com/2022/11/01/xTjQMV.png" alt="xTjQMV.png"></a></p>
<p>当所有的，非es module加载完毕后，才能加载es module模块。</p>
<p>总结，<br>es module的特性是，<br>1，默认就是严格模式<br>2，每个module模块，都拥有私有的作用域。<br>3，只支持cors，加载。本地必须开启 web serve<br>4，自带延迟效果</p>
<h5 id="关于import-export-一些小知识。"><a href="#关于import-export-一些小知识。" class="headerlink" title="关于import export 一些小知识。"></a>关于import export 一些小知识。</h5><p>我们可以使用，export，到处一些变量方法，也可以，export，设置默认导出的方法。</p>
<p><a href="https://imgse.com/i/xTjEVg"><img src="https://s1.ax1x.com/2022/11/01/xTjEVg.jpg" alt="xTjEVg.jpg"></a></p>
<p>接收默认到处的值</p>
<p><a href="https://imgse.com/i/xTjiKf"><img src="https://s1.ax1x.com/2022/11/01/xTjiKf.png" alt="xTjiKf.png"></a></p>
<p>接收默认导出的值</p>
<p><a href="https://imgse.com/i/xTjmPs"><img src="https://s1.ax1x.com/2022/11/01/xTjmPs.png" alt="xTjmPs.png"></a></p>
<p><strong>as 关键字，修改默认导出的值</strong></p>
<p>export <strong>as关键字修改 变量名</strong></p>
<p><a href="https://imgse.com/i/xTj8ZF"><img src="https://s1.ax1x.com/2022/11/01/xTj8ZF.png" alt="xTj8ZF.png"></a></p>
<p><a href="https://imgse.com/i/xTjGa4"><img src="https://s1.ax1x.com/2022/11/01/xTjGa4.png" alt="xTjGa4.png"></a><br>import <strong>as修改接收参数的变量名</strong></p>
<h5 id="export-导出的并不是一个对象-import-引入的也不是个对象的解构。"><a href="#export-导出的并不是一个对象-import-引入的也不是个对象的解构。" class="headerlink" title="export 导出的并不是一个对象 import 引入的也不是个对象的解构。"></a>export 导出的并不是一个对象 import 引入的也不是个对象的解构。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">export &#123;</span><br><span class="line">    num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然export后面跟着 {} 看起来很像对象， { name },看起来很像es6，字面量的写法。</p>
<p>import 在这里 **{}**，就像使用对象字面量解构一样，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; num &#125; from &#x27;./test.js&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>export {}</strong> 和 <strong>import {}</strong> 是 es modulc的固定语法。</p>
<p>export 导出的只是，内存地址。<br>export 导出的，是常量。只能在 export 内部修改。</p>
<p><strong>例子如下</strong></p>
<p>导出num</p>
<p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p>
<p><a href="https://imgse.com/i/xTjNGR"><img src="https://s1.ax1x.com/2022/11/01/xTjNGR.png" alt="xTjNGR.png"></a></p>
<p>控制台报错，index.js:4 Uncaught TypeError: Assignment to constant variable.<br>    at index.js:4:4</p>
<p>因为，我们import引入的，<strong>num</strong> 是个常量。无法在外部，对 import 引入的 num进行修改。</p>
<p><strong>那么，怎么样导入，一个字面量对象呢？</strong></p>
<p>使用 <strong>export default</strong></p>
<p><a href="https://imgse.com/i/xTjCxP"><img src="https://s1.ax1x.com/2022/11/01/xTjCxP.png" alt="xTjCxP.png"></a></p>
<h5 id="import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"><a href="#import-全部导入和import-动态导入模块和import导出，url，以及import导出，默认成员和命名成员。" class="headerlink" title="import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。"></a>import 全部导入和import 动态导入模块和import导出，url，以及import导出，默认成员和命名成员。</h5><p>如果export 导入了很多属性。我们可以使用import * 把所有的导出全部接收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = 1;</span><br><span class="line">let name = &#x27;张三&#x27;;</span><br><span class="line">let age = 12;</span><br><span class="line">let sigin = &#x27;为什么&#x27;</span><br><span class="line">export &#123;</span><br><span class="line">    num,</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sigin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import * as module from &#x27;./test.js&#x27;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure>

<p>import * as module 导入全部的要导出的模块。</p>
<p>试想，我们有一个这样的需求，根据判断条件，来决定要导入，那个模块。</p>
<p>import 必须要在最外层，最顶层的作用域当中。不能嵌套在if，或者funtion当中。</p>
<p>es modulc，提供了一个，<strong>import</strong>函数，来帮助我们动态的导入模块。而且，import(),本身是一个promise函数。</p>
<p><a href="https://imgse.com/i/xTjFr8"><img src="https://s1.ax1x.com/2022/11/01/xTjFr8.png" alt="xTjFr8.png"></a></p>
<p>这样通过，then,那么就能读取到模块了。</p>
<p>import 可以导入一个，url链接模块<br><a href="https://imgse.com/i/xTju2q"><img src="https://s1.ax1x.com/2022/11/01/xTju2q.png" alt="xTju2q.png"></a></p>
<p>import 导出默认成员与，命名成员<br><a href="https://imgse.com/i/xTjkqS"><img src="https://s1.ax1x.com/2022/11/01/xTjkqS.png" alt="xTjkqS.png"></a></p>
<p>总结，es module，</p>
<ol>
<li>在原生js当中使用，script标签，type应该使用，module。module默认就在严格模式环境下，this不可能指向全局。</li>
<li>每个模块都拥有了独立的，私有的作用域。</li>
<li>module加载，模块，会存在cors问题，需要服务端专门设置，本地必须开启，web sever</li>
<li>type = module后，会存在延迟效果，等页面资源加载完毕后，再去加载。</li>
</ol>
<p>总结，import的特性</p>
<ol>
<li>import {} 并非对象的解构，而是语法就是这样的。</li>
<li>import，导入的属性，只可以读取。import导入的是常量，无法修改。</li>
<li>import * model from 可以把，所有导出的属性，全部导入到一个对象里面。</li>
<li>import，可以导入url模块，</li>
<li>import必须在顶部，不可以在函数，条件语句下面。</li>
<li>import()，可以动态导入，<strong>import</strong>默认本身就是一个promise方法。</li>
<li>import as 可以更换导入的属性别名。</li>
<li>import num，{age,age1} from ‘../../‘可以导入，默认的成员与命名的成员。</li>
</ol>
<p>总结，export的特性</p>
<ol>
<li>export {} 这是语法，抛出的不是一个，字面量对象，export default是抛出对象。</li>
<li>export 抛出去的值是内存地址的引用，值，只能在export模块里面修改。</li>
<li>as 可以修改默认要导出的值的别名。</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JavaScript的严格模式那些事</title>
    <url>/blogs/2022/06/08/JavaScript%E5%BD%93%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>JavaScript通常情况下隐式运行在正常模式-“Sloppy Mode”，ES5及其版本之后，javaScript可以显示运行在严格模式-“Strict Mode”！在严格模式下。可以减少我们编写不安全的JavaScript代码，获得更加清大的错误检查机制。为了向后兼容，严格模式需要我们手动开启！</p>
</blockquote>
<ol>
<li>变量必须先声明后使用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">console.log(&quot;🚀 ~ file: index.js ~ line 4 ~ a&quot;, a)</span><br><span class="line">a = 11;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数型参不允许重复</li>
</ol>
<p>bad</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(x, y, y) &#123;</span><br><span class="line">   return x + y + y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(1, 2, 1));//Uncaught SyntaxError: Duplicate parameter name not allowed in this context (at index.js:4:21)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test(x, y, z) &#123;</span><br><span class="line">   return x + y + z;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(1, 2, 1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数的arguments 在严格模式和非严格模式下也有区别。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">   console.dir(arguments)</span><br><span class="line">   console.log(arguments.callee, arguments.caller);</span><br><span class="line">   /**</span><br><span class="line">    * @非严格模式</span><br><span class="line">   0: (4) [1, 2, 3, 4]</span><br><span class="line">   callee: ƒ test()</span><br><span class="line">   length: 1</span><br><span class="line">   Symbol(Symbol.iterator): ƒ values()</span><br><span class="line">   [[Prototype]]: Object</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * @严格模式</span><br><span class="line">    * 0: (4) [1, 2, 3, 4]</span><br><span class="line">      callee: [Exception: TypeError: &#x27;caller&#x27;, &#x27;callee&#x27;, and &#x27;arguments&#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them at Arguments.s (&lt;anonymous&gt;:1:83)]</span><br><span class="line">      length: 1</span><br><span class="line">      Symbol(Symbol.iterator): ƒ values()</span><br><span class="line">      get callee: ƒ ()</span><br><span class="line">      set callee: ƒ ()</span><br><span class="line">      [[Prototype]]: Object</span><br><span class="line">   */</span><br><span class="line">&#125;</span><br><span class="line">test([1, 2, 3, 4]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>严格模式下的arguments消失了。</p>
<p>arguments.callee, arguments.caller</p>
<h4 id="width不可用"><a href="#width不可用" class="headerlink" title="width不可用"></a>width不可用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">   name: &#x27;使用with读取对象属性&#x27;</span><br><span class="line">&#125;</span><br><span class="line">with (obj) &#123;		//严格模式下将禁用with关键字</span><br><span class="line">   console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="八进制数不可用"><a href="#八进制数不可用" class="headerlink" title="八进制数不可用"></a>八进制数不可用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">console.log(010 === 8)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="严格模式下的this指向"><a href="#严格模式下的this指向" class="headerlink" title="严格模式下的this指向"></a>严格模式下的this指向</h4><p>请注意：这里的函数时非方法函数！因为方法与对象挂钩，有具体的this!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line">function foo() &#123;</span><br><span class="line">   console.log(this)//undefined</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>总结</p>
<ul>
<li>js严格模式下 必须要显式声明变量才允许使用</li>
<li>width 方法不可用</li>
<li>arguments少了一些东西</li>
<li>八进制不可用</li>
<li>非方法函数this指向undefined</li>
<li>形参不允许 重复定义</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>严格模式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的去console</title>
    <url>/blogs/2022/06/08/%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%9B%E8%A1%8Cconsole/</url>
    <content><![CDATA[<h4 id="不要再去console一把梭了。"><a href="#不要再去console一把梭了。" class="headerlink" title="不要再去console一把梭了。"></a>不要再去console一把梭了。</h4><h5 id="使用console-time-console-timeEnd"><a href="#使用console-time-console-timeEnd" class="headerlink" title="使用console.time,console.timeEnd"></a>使用console.time,console.timeEnd</h5><p>可以获取到代码的执行时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.time(1);</span><br><span class="line">console.timeEnd(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="Console-assert-如果结果是true-就不会打印出来。"><a href="#Console-assert-如果结果是true-就不会打印出来。" class="headerlink" title="Console.assert()如果结果是true 就不会打印出来。"></a>Console.assert()如果结果是true 就不会打印出来。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let len = 10;</span><br><span class="line">console.assert(len !== 10, &#x27;失败&#x27;);</span><br></pre></td></tr></table></figure>

<h5 id="console-trace对栈的追踪"><a href="#console-trace对栈的追踪" class="headerlink" title="console.trace对栈的追踪"></a>console.trace对栈的追踪</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.trace(test)</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="console-table-打印出来一个表格，比较适合对-引用类型的数据"><a href="#console-table-打印出来一个表格，比较适合对-引用类型的数据" class="headerlink" title="console.table 打印出来一个表格，比较适合对 引用类型的数据"></a>console.table 打印出来一个表格，比较适合对 引用类型的数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let tableData = [&#123;</span><br><span class="line">    date: &#x27;2016-05-02&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1518 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-04&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1517 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-01&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1519 弄&#x27;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    date: &#x27;2016-05-03&#x27;,</span><br><span class="line">    name: &#x27;王小虎&#x27;,</span><br><span class="line">    address: &#x27;上海市普陀区金沙江路 1516 弄&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">console.table(tableData)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据的展示会更加直观。。</p>
<h5 id="对log进行分级"><a href="#对log进行分级" class="headerlink" title="对log进行分级"></a>对log进行分级</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">console.info(1);</span><br><span class="line">console.debug(1);</span><br><span class="line">console.warn(1);</span><br><span class="line">console.error(1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>像百度一样骚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;每一个星球都有一个驱动核心，\n每一种思想都有影响力的种子。\n感受世界的温度，\n年轻的你也能成为改变世界的动力，\n百度珍惜你所有的潜力。\n你的潜力，是改变世界的动力！\n\n&quot;), console.log(&quot;%c百度2022校园招聘简历投递：https://talent.baidu.com/external/baidu/campus.html&quot;, &quot;color:red&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript标签页通讯问题</title>
    <url>/blogs/2022/06/08/js%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h4 id="浏览器中的标签页如何通讯"><a href="#浏览器中的标签页如何通讯" class="headerlink" title="浏览器中的标签页如何通讯"></a>浏览器中的标签页如何通讯</h4><ol>
<li>标签页必须是同源的页面，必须是同源的页面。</li>
<li>使用BroadcastChannel。</li>
</ol>
<p>例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let channel = new BroadcastChannel(&#x27;test&#x27;);</span><br><span class="line">channel.postMessage(&#x27;hello,word&#x27;)</span><br><span class="line">channel.onmessage = (res =&gt; &#123;</span><br><span class="line">    console.log(res.data);</span><br><span class="line">&#125;)</span><br><span class="line">channel.onmessageerror = (err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实例话BroadcastChannel<br>postMessage方法发送数据</p>
<p>onmessageerror 监听错误信息<br>onmessage 获取消息</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的Promise</title>
    <url>/blogs/2022/05/30/%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>关于ES6中<strong>promise</strong>的使用，我已经熟练掌握了不少。至少能顺顺利利的写上一个异步方法。<br>但是对promise的理解使用 并没有得到提高。</p>
<p>比如，有这么一个场景，我需要发送5个接口。拿到5个接口里面的数据，且必须五个接口全部请求完毕，有结果了，我才能拿到。因为接口的响应时间不一样的，而且这个业务里面不想，a接口好了，去请求b接口。而是abcde5个接口一起请求。</p>
<p>这就是我，重新细读promsie的原因。</p>
<h5 id="关于promise的特点。"><a href="#关于promise的特点。" class="headerlink" title="关于promise的特点。"></a>关于promise的特点。</h5><ol>
<li><p>promise有3个状态， pending（进行中），和fulfilled（已成功），和rejected（已失败）。只有异步操作才能决定promise当前是哪一种状态，任何操作都无法改变</p>
</li>
<li><p>promsie的状态一旦改变就不可能逆转。比如从pending状态，到rejected状态。这个状态，就会凝固，不会再改变了，这个就称为resolved（已定型）。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">primise-&gt;&gt;fulfilled或rejected:异步操作才能决定promise当前的状态。</span><br><span class="line">fulfilled或rejected-&gt;&gt;primise:状态处于resolved状态凝固不可改变。</span><br></pre></td></tr></table></figure>



<h5 id="关于promise的一些缺点。"><a href="#关于promise的一些缺点。" class="headerlink" title="关于promise的一些缺点。"></a>关于promise的一些缺点。</h5><ul>
<li>promise一旦建立就无法取消。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;11&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码里面的log会立刻执行。</p>
<ul>
<li>promise异步执行的时候，我们无法知道他在哪一步。</li>
</ul>
<h5 id="promise的then"><a href="#promise的then" class="headerlink" title="promise的then"></a>promise的then</h5><p>primise的then方法，能够接受2个回调函数做参数使用。第一个是，当pending状态改变为，fulfilled调用，另一个是pending状态改变为，reject调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(11);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(function (res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="promise-catch-只能接受一个回调函数做参数使用。"><a href="#promise-catch-只能接受一个回调函数做参数使用。" class="headerlink" title="promise catch 只能接受一个回调函数做参数使用。"></a>promise catch 只能接受一个回调函数做参数使用。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(11);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(function (res) &#123;</span><br><span class="line">    console.log(res);//没有打印结果</span><br><span class="line">&#125;, function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="如果promise里面有同步执行的代码呢？？？"><a href="#如果promise里面有同步执行的代码呢？？？" class="headerlink" title="如果promise里面有同步执行的代码呢？？？"></a>如果promise里面有同步执行的代码呢？？？</h5><p>我们可以来看一段代码的执行顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function promise(time) &#123;</span><br><span class="line">    console.log(&#x27;预计执行时间:&#x27;, time / 1000);</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;欢迎来到promise:&#x27;);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;promise结果:resolve&#x27;);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;codeing&#x27;);</span><br><span class="line">promise(3000).then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;执行结束&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>正确的执行顺序应该是：</p>
<ol>
<li>codeing</li>
<li>预计执行时间</li>
<li>欢迎来到promise</li>
<li>promise结果</li>
<li>执行结束。</li>
</ol>
<p>promise异步操作执行的时候，除了pending 状态发生改变之前，都是同步的代码。<br>当定时器结束，异步操作的状态改变。我们通过then 或者catch来回调promise的结果。</p>
<p>使用promise异步加载图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function imgaeLoad(src) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let image = new Image();</span><br><span class="line">        image.src = src;</span><br><span class="line">        image.onload = function () &#123;</span><br><span class="line">            resolve(&#x27;succss&#x27;);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = function () &#123;</span><br><span class="line">            reject(&#x27;error&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">imgaeLoad(&#x27;https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/04/26/6267bb50cad26.jpeg&#x27;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="关于promise的异步操作的结果是返回另一个异步操作"><a href="#关于promise的异步操作的结果是返回另一个异步操作" class="headerlink" title="关于promise的异步操作的结果是返回另一个异步操作"></a>关于promise的异步操作的结果是返回另一个异步操作</h5><p>如果调用resolve或者reject函数带有参数，那么参数会被传递到回调函数。<br>reeject通常的参数是new Error的参数实例，无论reslove，还是reject来说，都有可能接受一个promise实例作为参数。</p>
<p>比如下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        reject(new Error(&#x27;fail&#x27;))</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">&#125;)</span><br><span class="line">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(p1)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err.message);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>p2的resolve的方法，将p1作为参数，即一个异步操作的结果返回另一个异步操作。</p>
<p>这个时候p1的状态就会传递给p2，如果p1，在pending，那么p2会等待。直到p1的状态从pending改变到resolved，或者rejectd，这个时候。p2的回调函数会马上执行。。</p>
<p>白话文就是，如果p2的异步操作把p1作为参数的话。那么p2的回调函数的状态就由p1异步操作来决定。</p>
<p>再浅一点，p2的异步操作如果把p1作为参数的话。那么p1的异步操作会执行，且他的状态影响着p2回调函数的状态。又或者说p1的状态结果就是p2的。</p>
<p>对于promise 方法来说，一旦状态从resolved 到 rejectd后。接下来的操作，直接在then，和catch里面操作就行了。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段方法会导致，即便是promise 状态已经改变了，log方法也还是执行了。所以一旦状态从resolved 到 rejectd后，一定要return出去。</p>
<h5 id="关于promise的链式调用。"><a href="#关于promise的链式调用。" class="headerlink" title="关于promise的链式调用。"></a>关于promise的链式调用。</h5><p>曾经做过微信服务商入驻哪一块。需要调上传接口，上传图片，然后在上传给图片给微信，然后再去给后端。</p>
<p>要发送4个请求，其中错了一个之后，就算失败。<br>于是代码就成了这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promiseA().then(()=&gt;&#123;</span><br><span class="line">    promiseB().then(()=&gt;&#123;</span><br><span class="line">            promiseC().then(()=&gt;&#123;</span><br><span class="line">                 promiseD().then(()=&gt;&#123;</span><br><span class="line">        </span><br><span class="line">                &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是promise 是可以使用链式调用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结其他来是，链式调用可以避免回调地狱的产生，你需要then下去就好了。<br>无非就promiseA好了那就去调用promiseB。如果失败了直接在catch捕捉就可以了。</p>
<p>当然如果promiseA失败了，catch捕捉到的肯定是，promiseA的catch。</p>
<p>我们只需要在第五个then下面，进行操作就可以了。</p>
<p>好处是。catch捕捉一次就够了。</p>
<h5 id="关于promise的catch"><a href="#关于promise的catch" class="headerlink" title="关于promise的catch"></a>关于promise的catch</h5><ol>
<li>promise的catch具有冒泡性。</li>
</ol>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段方法会导致，即便是promise 状态已经改变了，log方法也还是执行了。所以一旦状态从resolved 到 rejectd后，一定要return出去。</p>
<h5 id="关于promise的链式调用。-1"><a href="#关于promise的链式调用。-1" class="headerlink" title="关于promise的链式调用。"></a>关于promise的链式调用。</h5><p>曾经做过微信服务商入驻哪一块。需要调上传接口，上传图片，然后在上传给图片给微信，然后再去给后端。</p>
<p>要发送4个请求，其中错了一个之后，就算失败。<br>于是代码就成了这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promiseA().then(()=&gt;&#123;</span><br><span class="line">    promiseB().then(()=&gt;&#123;</span><br><span class="line">            promiseC().then(()=&gt;&#123;</span><br><span class="line">                 promiseD().then(()=&gt;&#123;</span><br><span class="line">        </span><br><span class="line">                &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;).catch(()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(err=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是promise 是可以使用链式调用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不管是say1 到say5promise方法，只要有一个错误都会被catch捕捉到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say2(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;河南&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say3(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(data + &#x27;郑州&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function say4(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(data + &#x27;二七区&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// promise 链式调用</span><br><span class="line">// 避免给每个方法里面写catch</span><br><span class="line">say1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say2(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say3(res);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return say4(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function say5(data) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;把promise结果使用return出去的&#x27;);</span><br><span class="line">            console.log(111111);</span><br><span class="line">            reject(&#x27;ss&#x27;);//prmise 状态改变就不可逆。</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say5().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>且尽可能不要尝试在then方法里面捕捉，错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            reject(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say1().then(function (value) &#123;</span><br><span class="line">    console.log(&#x27;succss&#x27;);</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">    // failure</span><br><span class="line">    console.log(&#x27;error&#x27;);</span><br><span class="line">&#125;)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>promise方法的任何报错都会导致，promise进入rejected状态，被catch捕捉到错误信息。</p>
<p>比如我们人为制造一些报错信息。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function say1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">        let a;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&#x27;中国&#x27;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">say1().then(succss =&gt; &#123;</span><br><span class="line">    console.log(succss);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本身promise应该是resolved的。因为报错信息，导致变成rejected，然后被catch捕捉。</p>
<p>promise 会把报错信息给吞掉。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const someAsyncThing = function () &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        // 下面一行会报错，因为x没有声明</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">someAsyncThing().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">&#125;, 2000)//11</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在promise中如果没有使用catch函数去接受捕捉错误信息的话，promsie对象抛出错误，不会传递到外层的代码。也不会有任何反应。</p>
<p>在看下个例子，当promise已经结束了，下轮事件循环再抛出错误，这个时候，promise已经执行完毕了，所以这个错误是promise函数体外抛出的，会冒泡到最外层。导致无法捕获该错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let test = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&#x27;succss&#x27;);</span><br><span class="line">    setTimeout(function () &#123; throw new Error(&#x27;test&#x27;) &#125;, 0)</span><br><span class="line">&#125;)</span><br><span class="line">test.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>promise 可以运行catch函数方法，再去运行，then函数方法。如果没有报错会绕过catch，运行then方法指定的回调函数。。</p>
<p>如果存在报错，catch捕捉错误后继续执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;errors:&#x27;, error);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    alert(&#x27;11&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>没有报错，catch被绕过，直接执行then。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1(x = 1) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().catch(error =&gt; &#123;</span><br><span class="line">    console.log(&#x27;errors:&#x27;, error);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>catch内部也会报错。如果catch报错了，在后面再写一个catch捕获错误信息就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(x + 2);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return p1();</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    y + 2;</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="promise-finally方法。"><a href="#promise-finally方法。" class="headerlink" title="promise finally方法。"></a>promise finally方法。</h5><p>不管promise的状态如何，他都会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(0);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">p1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;).finally(e =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>then回调函数与finally函数，分别console.log出来了，0和1</p>
<h5 id="promise-all"><a href="#promise-all" class="headerlink" title="promise all"></a>promise all</h5><p>假设，我是说假设，我们有3个promise方法，p1，p2，p3。<br>让p1，p2，p3，几乎同时发送，p1，p2，p3全部是resloved，那就then回调函数捕获。不然就使用，catch捕获。。</p>
<p>我们该怎么去写呢。</p>
<p>这个时候就可以使用promise all来处理。</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            resolve(&#x27;p3成功&#x27;);</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1(), p2(), p3()]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.all（）把p1-p3函数全部放入。</p>
<p>等到p1-p3函数的promise状态全部都为resovled 或者rejected的话。promise.all的状态是rejected或者resovled</p>
<p>promise.all的成员可以不是数组，但是必须具有Iterator，且每个成员都是返回了promise实例。</p>
<p>如果primise.all内的promise实例，catch捕获了错误信息，那么promise.all，的状态不会受rejected的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            reject(new Error(&#x27;p3失败&#x27;));</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1(), p2(), p3().catch(err =&gt; &#123; console.log(err); &#125;)]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//因为p3函数使用catch函数捕获了，报错信息。所以promise.all的 没有捕获到错误，导致还是then回调函数正常使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="promise的race方法。"><a href="#promise的race方法。" class="headerlink" title="promise的race方法。"></a>promise的race方法。</h5><p>promise.race 函数的特点是，假设，我们拥有，p1-p3多个promise函数，如果p2promise方法，状态首先改变了，那么会改变promise.race的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;1&#x27;);</span><br><span class="line">            resolve(&#x27;p1成功&#x27;);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;2&#x27;);</span><br><span class="line">            resolve(&#x27;p2成功&#x27;);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(&#x27;3&#x27;);</span><br><span class="line">            reject(new Error(12121));</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.race([p1(), p2(), p3()]);</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;res:&#x27;, res);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和promise.all不同，里面的成员必须是promise实例。promise.race，成员什么参数都可以接收。。</p>
<p>并且，promise.race()的成员里非primise实例的成员，会立马，触发promise.race的then回调函数。</p>
<h5 id="promise-race，all的区别。"><a href="#promise-race，all的区别。" class="headerlink" title="promise race，all的区别。"></a>promise race，all的区别。</h5><p>promise all，p1-p4….promise方法，同时执行，全部成功了，会成功，一个失败，那就是失败咯，all方法的成员不一定非得是数组，但是一定要有，有Iterator接口。</p>
<p>promise race，p1-p4…..promise方法，promis.race的实例的状态是，p1-p4promise函数中那个函数的结果改变了，那么改变的状态就是promise.race的状态。</p>
<h5 id="promise-allSettled方法。"><a href="#promise-allSettled方法。" class="headerlink" title="promise allSettled方法。"></a>promise allSettled方法。</h5><p>假设，我们有p1-p4，4个promise实例，不管成功与否，我都想让他走完，又或者（等待所有的promise实例，全部结束），再去做一些操作。</p>
<p>promise.all的前提是，p1-p4实例，必须要走完，才能进行操作，如果但凡有个失败，那就直接报错，不管另外的promise是否结束。。</p>
<p>alisettled不是这样的，promise多个实例，都会执行，并且全部执行结束了promise.allsettled的promise状态才改变，并且then回调函数下面，我们会拿到所有promise的结果，以对象的形式</p>
<h5 id="关于promise的any"><a href="#关于promise的any" class="headerlink" title="关于promise的any"></a>关于promise的any</h5><p>与promise，reac函数不同的是，reac，在promise实例当中，找到最快响应的实例，</p>
<p>promise，any，找到最快响应的实例，必须得是，resovled，状态的。</p>
<p>p1-p4，4个promise实例，是promise，any的成员。<br>p1-p4，最快执行完毕，且实例本身，是resolved的，成为any的状态。<br>假设p1-p4全部rejected的话，那么，就得使用catch去捕获异常。。</p>
<p>p1-p4，只要有一个resolved，那就算成功了。</p>
<h5 id="关于promise-try"><a href="#关于promise-try" class="headerlink" title="关于promise try"></a>关于promise try</h5><p>关于promise的执行顺序。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(0);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印的顺序居然是，1 0；</p>
<p>因为promise是异步函数，除非你给他做一个匿名立即执行函数。绕过去。不然的话。</p>
<p>可是我们即想要使用，promise函数，但也没有什么，异步操作。。。</p>
<p>这个时候，promise，try就诞生了。</p>
<p>promise try文档不全，最新还没有进行适配。后面补上。。</p>
<h5 id="关于promise-resolve。"><a href="#关于promise-resolve。" class="headerlink" title="关于promise resolve。"></a>关于promise resolve。</h5><ol>
<li>primise resolve，可以将一个对象转换为，promise方法。</li>
</ol>
<p>promise.resolve等于 new prmise((resolve,reject)=&gt;{});</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let object = &#123;</span><br><span class="line">    name: 111,</span><br><span class="line">    age: &#x27;12&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Promise.resolve(object);</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res.name)//111</span><br><span class="line">&#125;)</span><br><span class="line">console.log(p1)//Promise &#123;&lt;fulfilled&gt;: &#123;…&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>成功的把一个promise例子转换为，真实的例子。</p>
<p>primise.resolve()的参数有四种。</p>
<p>resolve()的参数是一个promise实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(12121);</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">let p1 = Promise.resolve(p3())</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//12121</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>promise.resolve参数返回的还是promise实例。。</p>
<p>resolve(),thenable，参数。<br>thenable对象，指的是具有，then方法的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p1 = Promise.resolve(&#123;</span><br><span class="line">    then: () =&gt; &#123;</span><br><span class="line">        console.log(11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//11</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>resolve,then对象调用执行后，对象p1的状态就回变为resolved。</p>
<p>参数不是具有then()方法的对象，或根本就不是对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p1 = Promise.resolve(&#x27;11&#x27;)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res);//11</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p>因为hello不属于一步操作，返回promise的实例状态从医生称就是resloved，所以回调函数立即执行。<br>同时会传给回调函数。。</p>
<p>如果promise.resolved,不带参数。那么直接返回resolved状态的promise对象。</p>
<p>立即执行的promise对象，是在本轮事件循环结束时执行，而不是在下一轮事件循环开始时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(0)</span><br><span class="line">let p1 = Promise.resolve(1)</span><br><span class="line">p1.then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;, 0)</span><br><span class="line">// 0 1 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="promise-reject"><a href="#promise-reject" class="headerlink" title="promise.reject(),"></a>promise.reject(),</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p1 = Promise.reject(&#x27;出错了&#x27;);</span><br><span class="line">p1.catch(err =&gt; &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">/**</span><br><span class="line"> * Promise.reject(&#x27;出错了&#x27;) === new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line"> * reject</span><br><span class="line"> * &#125;)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的包管理器</title>
    <url>/blogs/2022/04/14/%E5%85%B3%E4%BA%8Enpm%E4%B8%8Eyran%E5%92%8Ccnpm%E5%8C%85%E6%8B%ACpnpm%E3%80%82/</url>
    <content><![CDATA[<ol>
<li>npm早起pages.json来确定node_modules依赖树关系，而且众所周知的原因，慢。v5版本之后多了，package-lock.json文件，锁定了依赖的版本，保证我们每次都能下到正确版本的依赖。</li>
<li>yran性能好，体积会小一些。早起的时候npm没有package-look.json。</li>
<li>pnpm超级快，体积小，掘金社区，说依赖少一些，不稳定。没有声明使用的依赖，好想存在一些问题。观望。</li>
<li>前端项目当中，一定要保持node版本，和包管理器的版本一致。</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Javascript闭包（Closure）</title>
    <url>/blogs/2022/04/14/%E5%AD%A6%E4%B9%A0Javascript%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89/</url>
    <content><![CDATA[<h5 id="在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。"><a href="#在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。" class="headerlink" title="在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。"></a>在弄清楚闭包之前，我们首先要明白的点是，js的作用域与作用域链。</h5><p>不bb上代码！！！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 0;</span><br><span class="line">function parent() &#123;</span><br><span class="line">    var b = 1;</span><br><span class="line">    console.log(a, b);</span><br><span class="line">    function son() &#123;</span><br><span class="line">        var c = 2;</span><br><span class="line">        console.log(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">parent();</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>


<ol>
<li>我们可以在任何地方访问变量，全局变量a。</li>
<li>局部变量，b，c，parent函数，只能访问到局部变量，b。son函数的作用域变量，parent无法访问。</li>
<li>son函数，访问，a，b，c变量的过程就是一个完整的作用域链。是一个向上的过程。</li>
</ol>
<p>通俗的语言表达，son作用域就是一个鱼缸，parent作用域是一个池塘。son可以通过吸管来抽取parent作用域的水（变量）;</p>
<h5 id="闭包问题"><a href="#闭包问题" class="headerlink" title="闭包问题"></a>闭包问题</h5><p>闭包问题，让池塘拿出吸管来抽取鱼缸的水（变量）的过程。</p>
<p><strong>所以，如何在外部访问函数内部的变量呢？</strong></p>
<p>看个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line">let val = parent();</span><br><span class="line">console.log(val);//0</span><br></pre></td></tr></table></figure>

<p>这里我们把parent函数直接return出去，就拿到了内部变量了，吗？</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    ++num;</span><br><span class="line">    console.log(num);</span><br><span class="line">    return num;</span><br><span class="line">&#125;;</span><br><span class="line">parent();//1</span><br><span class="line">parent();//1</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>我们执行了，2次parent函数，log打印出来的只有1，1。<br>函数的内部变量为什么只做了一次自增就就没有了呢？？？？</p>
<p>这里不得不谈的js的执行机制问题。</p>
<p>太复杂的不想谈，parnt方法执行完毕之后，整个方法，连变量都被回收了，num变量值只拿到了自增一次后的，parnt函数的返回值。</p>
<p>可以把js执行理解为一个机器，parent执行，回收掉。返回值1，parent执行，回收掉返回值1。</p>
<h5 id="如何得到一个闭包呢？"><a href="#如何得到一个闭包呢？" class="headerlink" title="如何得到一个闭包呢？"></a>如何得到一个闭包呢？</h5><p>我们可以看看闭包需要达成的条件。</p>
<ol>
<li>外部函数能够访问，内部函数的变量。</li>
<li>内部的变量可以一直存在内存里面，不会被js的垃圾回收机制回收掉。</li>
</ol>
<h6 id="如何在外部访问部分的函数变量。"><a href="#如何在外部访问部分的函数变量。" class="headerlink" title="如何在外部访问部分的函数变量。"></a>如何在外部访问部分的函数变量。</h6><p>在函数内部在创建一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    son();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>son有权利访问，parent内部的所有变量。那么我们如果把son函数当作返回值，在外部不就能拿到，函数内部的变量了吗。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">val();//0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>上面这个例子，只能证明，外部函数可以访问得到parent函数的内部。可是函数内部的变量，有没有被垃圾回收，下面这个例子就能证明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function parent() &#123;</span><br><span class="line">    var num = 0;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    add = function () &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    minus = function () &#123;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">minus();</span><br><span class="line">val();//2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们在函数内部，声明了2个全局变量方法。一个做自增，一个做自减。</p>
<p>还有一个例子也能证明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parent() &#123;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        num: 0</span><br><span class="line">    &#125;;</span><br><span class="line">    function son() &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var val = parent();</span><br><span class="line">var c1 = val();</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">c1.num++;</span><br><span class="line">console.log(c1.num, val());//6,6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cl.num 与函数内部的变量完全相等。<br>son函数就是 闭包。在parent函数内部，通过return，与外部函数建立一条通道。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>闭包就是外部函数访问内部函数变量，且函数内部的变量一直在内存里得到保留，不会被垃圾回收。</p>
<p>产生闭包的原因是，因为，外部函数引用了函数内部的函数，导致不会进行垃圾回收，变量得到了保留。</p>
<p>这就是函数内部建立函数，return函数内部给外部函数的原因。</p>
<h5 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h5><ol>
<li>因为闭包函数内部的变量不会被垃圾回收，需要小心内存泄漏。</li>
<li>闭包让我们有了访问函数内部变量的权利，但是不要轻易去修改函数内部的值。</li>
</ol>
<h5 id="阮一峰大佬的思考题"><a href="#阮一峰大佬的思考题" class="headerlink" title="阮一峰大佬的思考题"></a>阮一峰大佬的思考题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">　　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return this.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　var name = &quot;The Window&quot;;</span><br><span class="line"></span><br><span class="line">　　var object = &#123;</span><br><span class="line">　　　　name : &quot;My Object&quot;,</span><br><span class="line"></span><br><span class="line">　　　　getNameFunc : function()&#123;</span><br><span class="line">　　　　　　var that = this;</span><br><span class="line">　　　　　　return function()&#123;</span><br><span class="line">　　　　　　　　return that.name;</span><br><span class="line">　　　　　　&#125;;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;;</span><br><span class="line"></span><br><span class="line">　　alert(object.getNameFunc()());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个结果是，The Window”原因是因为，this的指向问题，return funtion是一个匿名函数，匿名函数默认指向window。</p>
<p>第二个结果是，My Object”原因是因为，getNameFunc，在obect下面，this自然而然就指向object。这个时候把this指针所谓变量，给了匿名函数。return的时候，this自然而然指向了objet，所以访问到name。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的new操作符</title>
    <url>/blogs/2022/01/23/javascript%E4%B8%AD%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="new操作符有什么用？"><a href="#new操作符有什么用？" class="headerlink" title="new操作符有什么用？"></a>new操作符有什么用？</h4><h5 id="试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。"><a href="#试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。" class="headerlink" title="试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。"></a>试想一个有这样一个场景，一场游戏，需要100个士兵。（我们需要一百个object），要怎么做。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(&#123;</span><br><span class="line">        id: index,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">        run: function () &#123;</span><br><span class="line">            console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">arr[0].run();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>100个士兵，我们生成了，但是，这样这样，既不优雅，对性能也是一种极大的浪费。</p>
<h5 id="可不可以再优雅一点。"><a href="#可不可以再优雅一点。" class="headerlink" title="可不可以再优雅一点。"></a>可不可以再优雅一点。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//士兵原型</span><br><span class="line">var model = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    //创建一个临时对象</span><br><span class="line">    let object = &#123;</span><br><span class="line">        id: index,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">    &#125;</span><br><span class="line">    object.__proto__ = model;</span><br><span class="line">    arr.push(object)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr[0].run();</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创建了一个原型对象 通过object的proto指向士兵的原型。</p>
<h5 id="还能不能更优雅一点，原型与对象在2个地方。"><a href="#还能不能更优雅一点，原型与对象在2个地方。" class="headerlink" title="还能不能更优雅一点，原型与对象在2个地方。"></a>还能不能更优雅一点，原型与对象在2个地方。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//士兵原型</span><br><span class="line">var model = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">        console.log(`$&#123;this.id&#125;号士兵`);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//士兵数组</span><br><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//更优雅的方式</span><br><span class="line"></span><br><span class="line">function Cat(id) &#123;</span><br><span class="line">    let object = &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        hp: Math.floor(Math.random() * (100 - 0)) + 0,</span><br><span class="line">    &#125;</span><br><span class="line">    object.__proto__ = model;</span><br><span class="line">    return object;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(Cat(index))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr, arr[0].run());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://imgtu.com/i/75NzLt"><img src="https://s4.ax1x.com/2022/01/23/75NzLt.jpg" alt="代码演示.jpg"></a></p>
<p>使用 new来实现一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//士兵们</span><br><span class="line">let arr = [];</span><br><span class="line">function Soldier(id) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">    this.hp = Math.floor(Math.random() * (100 - 0)) + 0;</span><br><span class="line">&#125;</span><br><span class="line">Soldier.prototype.run = function () &#123;</span><br><span class="line">    console.log(`$&#123;this.id&#125;号士兵在逃跑`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实例化</span><br><span class="line">for (let index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">    arr.push(new Soldier(index))</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr, arr[80].run());</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>首先实例化过程中创建了一个对象。</li>
<li>给对象添加proto，然后new自动找到了构造函数的原型并且把原型链接到了对象proto。</li>
<li>this做实例化的对象的上下文。</li>
<li>如果该函数没有返回对象，返回this。</li>
</ul>
<p>这就是new操作符的作用。<br><a href="https://zhuanlan.zhihu.com/p/23987456">参考文章</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于js中的apply bind call的使用</title>
    <url>/blogs/2022/01/20/%E5%85%B3%E4%BA%8Ethis%E7%9A%84call%EF%BC%8Capply%EF%BC%8Cbind%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="this到底指向哪里。"><a href="#this到底指向哪里。" class="headerlink" title="this到底指向哪里。"></a>this到底指向哪里。</h4><p>事实上，this基本上指向最后调用他的对象。谁最后调用了this，this最终就指向哪里。（虽然会存在着，隐式调用的时候，this就变成了默认）</p>
<h4 id="而apply-call-与-bind-，可以改变this的指向。"><a href="#而apply-call-与-bind-，可以改变this的指向。" class="headerlink" title="而apply call 与 bind ，可以改变this的指向。"></a>而apply call 与 bind ，可以改变this的指向。</h4><p>例子如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi();//芳芳</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>我们需要让sayHi方法的this指向parson</strong></p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi.call(parson)//李四</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用apply 也可以改变指向。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">sayHi.apply(parson)//李四</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="apply-与-call-的区别。"><a href="#apply-与-call-的区别。" class="headerlink" title="apply 与 call 的区别。"></a>apply 与 call 的区别。</h5><p>apply 和call的第一个参数都是，制定this的指向。第二次参数都是要传递进入的参数。不同的是 apply方法必须要制定一个数组作为参数传入，而，call则不是。</p>
<p>例子如下，，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// var name = &#x27;芳芳&#x27;</span><br><span class="line">function sayHi(a, b) &#123;</span><br><span class="line">    console.log(this.val + a + b);</span><br><span class="line">&#125;</span><br><span class="line">var parson = &#123;</span><br><span class="line">    val: 10,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sayHi.call(parson, 1, 2);</span><br><span class="line">sayHi.apply(parson, [1, 2,]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>不管是apply 与call 方法都指向了 parson，且，只不过apply参数传递必须是个数组。</p>
<p>bind 与 apply 和call不同的地方在于。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>执行</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>apply</td>
<td>改变函数的this上下文后马上执行函数</td>
<td>返回fun的执行结果</td>
</tr>
<tr>
<td>bind</td>
<td>返回函数改变了上下文的函数不马上执行</td>
<td>返回fun的拷贝，并指定了this的指向，保存函数的参数。</td>
</tr>
</tbody></table>
<p>关于apply 的一些妙用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var arr = [1, 2, 3, 4, 21, 21, 31, 32, 32, 12121, 21];</span><br><span class="line">let max = Math.max.apply(Math, arr);</span><br><span class="line">let min = Math.min.apply(Math, arr)</span><br><span class="line">console.log(max, min);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>改变this的指向</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce解决商品sku算法问题</title>
    <url>/blogs/2022/01/10/reduce%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81sku%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="sku问题。"><a href="#sku问题。" class="headerlink" title="sku问题。"></a>sku问题。</h4><p>找到了一个数组方法 特别适合计算sku。</p>
<p>就是js中的reduce方法。</p>
<p>关于reduce方法的四个参数。<br>Accumulator (acc) (累计器)<br>Current Value (cur) (当前值)<br>Current Index (idx) (当前索引)<br>Source Array (src) (源数组)<br>initialValue（初始值）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>accmulator</td>
<td>累加器（如果设置有初始值的话，第一次是初始值的参数，没有初始值，返回上次回调函数的结果）</td>
</tr>
<tr>
<td>Current Value</td>
<td>当前的值</td>
</tr>
<tr>
<td>Current Index</td>
<td>当前下标</td>
</tr>
<tr>
<td>Source Array</td>
<td>源数组</td>
</tr>
<tr>
<td>initialValue</td>
<td>默认值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var arr = [[&#x27;s&#x27;, &#x27;m&#x27;, &#x27;x&#x27;, &#x27;l&#x27;, &#x27;xl&#x27;], [&#x27; T恤&#x27;, &#x27;裤子&#x27;, &#x27;裙子&#x27;], [&#x27;蓝色&#x27;, &#x27;白色&#x27;], [&#x27;nike&#x27;, &#x27;安踏&#x27;, &#x27;李宁&#x27;]];</span><br><span class="line">console.log(...arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    let res = [];</span><br><span class="line">    pre.forEach(item =&gt; &#123;</span><br><span class="line">        cur.forEach(items =&gt; &#123;</span><br><span class="line">            res.push(item.concat(items));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">&#125;, [[]]));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码需要理解的地方在于，第一遍的时候因为设置了默认值，[[]],所以第一次遍历到的是一个空数组。第二次再去遍历的时候 <strong>此时</strong>，当前值已经T恤xxx什么的了，所以第二次，我们遍历pre数组，合并cur数组就可以了。</p>
<p>reduce方法。。</p>
<p>这样sku问题就解决了</p>
<h5 id="reduce其他妙用。"><a href="#reduce其他妙用。" class="headerlink" title="reduce其他妙用。"></a>reduce其他妙用。</h5><h6 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [12, 3, 31, 21, 21, , 31, 31];</span><br><span class="line"></span><br><span class="line">console.log(arr.reduce((per, cur) =&gt; &#123;</span><br><span class="line">    return per + cur</span><br><span class="line">&#125;));//150</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="reduce-计算数组中每个元素出现的次数"><a href="#reduce-计算数组中每个元素出现的次数" class="headerlink" title="reduce 计算数组中每个元素出现的次数"></a>reduce 计算数组中每个元素出现的次数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var names = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Tiff&#x27;, &#x27;Bruce&#x27;, &#x27;Alice&#x27;];</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">    return names.reduce((allNames, name) =&gt; &#123;</span><br><span class="line">        if (name in allNames) &#123;</span><br><span class="line">            allNames[name]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            allNames[name] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return allNames;</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(test(names));</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>includes</title>
    <url>/blogs/2022/01/10/includes/</url>
    <content><![CDATA[<h4 id="关于ES6-include的使用方法。"><a href="#关于ES6-include的使用方法。" class="headerlink" title="关于ES6-include的使用方法。"></a>关于ES6-include的使用方法。</h4><p>场景，和后端同学调试接口的时候，后端同学很喜欢返回我，status，或者type来给我判断。但是，，，如果状态多的话，那么判断可能是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let status = 0;</span><br><span class="line"></span><br><span class="line">if (status == 1 || status == 2 || status == 3) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说实话这样写一点都不优雅。但是还能接受。毕竟 1 2 3，还好判断。</p>
<p>场景，后端同学又过来，接口要改，status可能要多判断2个值，4，5。4是进行中，5是已售后，或者叫啥都行。</p>
<p><a href="https://imgtu.com/i/7VEMdI"><img src="https://s4.ax1x.com/2022/01/10/7VEMdI.jpg" alt="7VEMdI.jpg"></a></p>
<p>接下来，我们的代码就是这样。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let status = 5;</span><br><span class="line"></span><br><span class="line">if (status == 1 || status == 2 || status == 3 || status == 4 || status == 5) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>即便后端哥们不再过来改接口，添加状态。你也觉得这段代码不妥了把。</p>
<p>includes方法就可以完美解决这个问题。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let status = 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4, 5];</span><br><span class="line">if (arr.includes(status)) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>includes</strong>会找数组的成员，找到了就是true，找不到就是false。</p>
<p>可可可，有indexof，呀。为什么要使用includes。</p>
<p>的确。indexof能实现这个问题。。</p>
<p>可是，如果数组里面存在NaN呢。indexof是否还能找得到？</p>
<p>例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let status = NaN;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, NaN, null];</span><br><span class="line">if (arr.indexOf(status) != -1) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>alert 出来到是 no。</p>
<p>而，includes就不会存在这样到问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let status = NaN;</span><br><span class="line">let arr = [1, 2, 3, 4, 5, NaN, null];</span><br><span class="line">if (arr.includes(status)) &#123;</span><br><span class="line">    alert(&#x27;yes&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    alert(&#x27;no&#x27;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>indexof 无法在数组内定位到，NaN的位置。</p>
<p>结论如下，NaN无敌可能会存在数组的情况下，使用includes。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读红宝书js中的变量</title>
    <url>/blogs/2021/11/25/%E9%98%85%E8%AF%BB%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h5 id="var是什么。"><a href="#var是什么。" class="headerlink" title="var是什么。"></a>var是什么。</h5><p>1.js中的操作符，声明一个函数级的变量。<br>2.会存在变量提升的情况。</p>
<h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">var a = 11;//undefined</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为，变量提升到了最上面，所以虽然没有声明变量a，但是a变量被提到了最前面。</p>
<p>小知识，声明未使用的变量，默刃值是undefined。</p>
<h6 id="例子2，在函数里面"><a href="#例子2，在函数里面" class="headerlink" title="例子2，在函数里面"></a>例子2，在函数里面</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    var a;//undefined</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样也是变量被声明了。</p>
<p>我在变量提升上面的理解走错了路。声明变量，变量的默认中undefined，所谓的变量提升，就是声明的变量提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 11;</span><br><span class="line">代码等于 </span><br><span class="line">var a;</span><br><span class="line">a = 11;</span><br></pre></td></tr></table></figure>


<h6 id="let，块级作用域"><a href="#let，块级作用域" class="headerlink" title="let，块级作用域"></a>let，块级作用域</h6><p>1.何谓块级作用域啊。<br><code>&#123;&#125;</code><br>指的是只在代码块里有效。</p>
<p>2.最大的特点是没有变量提升。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * error  index.js:20 Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span><br><span class="line">    at index.js:20</span><br><span class="line"> * </span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">let a = 11;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不可以先使用！后声明变量。必须得先声明。因为没有变量提升！！！<br>因为let 声明执行的瞬间会存在一个暂缓性死区，不允许先使用后声明。</p>
<h6 id="3-可否重复声明？？"><a href="#3-可否重复声明？？" class="headerlink" title="3.可否重复声明？？"></a>3.可否重复声明？？</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var a = 11;</span><br><span class="line">var a = 12;</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>//众所周知，var变量的缺点是提升，与重复声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let a = 11;</span><br><span class="line">let a = 12;</span><br><span class="line">console.log(a);//error Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let 在同一作用域下,不允许重复声明。</p>
<h6 id="关于全局声明。"><a href="#关于全局声明。" class="headerlink" title="关于全局声明。"></a>关于全局声明。</h6><p>var 声明的变量会成为window对象的属性。但是let在全局声明则不然。  </p>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//全局声明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let a = 11;</span><br><span class="line">console.log(window.a);undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="let-是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。"><a href="#let-是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。" class="headerlink" title="let 是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。"></a>let 是块级作用域，无法检测到前面已经声明到到同名变量，也无法在没有声明之前使用未声明到变量。</h5><p>举个例子。</p>
<p>a.js文件里面的代码</p>
<p>`<br>let a = 11;</p>
<p>`<br>b.js文件的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// let a = 12;</span><br><span class="line">//条件声明不是一个好的方式。</span><br><span class="line">if (typeof (a) == &#x27;number&#x27;) &#123;</span><br><span class="line">    // 块级作用域下的let 声明的变量a ，无法检测前面有没有同名的变量。也无法在没有什么声明之前使用a。</span><br><span class="line">    let a = 12;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">//此处变量a，是a.js文件下声明的变量a，因为这个变量a是在全局作用域声明的变量。</span><br><span class="line">a = 13;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>关于js为什么做模块化的。就是因为上面的代码太乱了，都在一个html页面下，依赖于上下关系，而且能够很轻松的访问到全局作用域洗面的全局变量。所以很容易出现变量泄漏的问题。</p>
<p>且很难理清楚代码的关系。</p>
<h5 id="在for循环中声明let。"><a href="#在for循环中声明let。" class="headerlink" title="在for循环中声明let。"></a>在for循环中声明let。</h5><p>举个例子，因为for循环中，var 声明的变量会渗透出去。所以let声明的变量只会在代码块中存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 1; i &lt; 3; ++i) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//在这里我们能轻松访问到i</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>//如果使用let声明的话则不会。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">for (let i = 1; i &lt; 3; ++i) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);//index.js:6 Uncaught ReferenceError: i is not definedat index.js:6</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>//陷入的误区。</p>
<p>因为之前习惯使用 var来声明变量，搞不清楚为什么for循环后，var声明的变量比，<br>之前的代码多了1。</p>
<p>我tm就是脑子不好使，是个傻逼。let是块级作用域当然没这个问题了。</p>
<p>在js的for循环中只有失败了，才会停止。</p>
<p>总结，var会变量提升，在for循环中会导致变量渗透。var可以多次被声明，var 任何版本都可以使用。变量都默认值数undefined。<br>var 在windows作为属性。</p>
<p>let 没有变量提升，因为声明瞬间会暂缓性死区，let必须先声明后使用，在同块级作用域下let 变量不能重复声明。lef使用for循环不会泄漏变量。别使用条件声明let 同名变量。let不在window作为属性。</p>
<p>for循环只有失败都时候会终止。</p>
<p>最重要的知识点是弄清楚了for循环失败结束，太蠢了我。和上古时期的前端开发者的苦恼，没有模块化之前很容易全局变量污染。不易维护。</p>
<p>感同身受。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年11月22日日报</title>
    <url>/blogs/2021/11/23/2021%E5%B9%B411%E6%9C%8822%E6%97%A5%E6%97%A5%E6%8A%A5/</url>
    <content><![CDATA[<h4 id="已完成"><a href="#已完成" class="headerlink" title="已完成"></a>已完成</h4><h5 id="看js的红宝书"><a href="#看js的红宝书" class="headerlink" title="看js的红宝书"></a>看js的红宝书</h5><p>标识符<br>js中的标识符指的是，变量，属性，方法。最好使用小驼峰写法（首字母小写），标识符开头必须是字母或者_下划线，或者美元符号$来表示。</p>
<p>语句<br>{}来表示代码块，那怕就一句，;号表示语句的结束，如果不写分号也许。只不过js引擎会解析都时候带上，对性能不好。<br>最好使用控制语句来控制代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(true)</span><br><span class="line">log(&#x27;坏的写法&#x27;)</span><br><span class="line"></span><br><span class="line">if(ture)&#123;</span><br><span class="line">    log(&#x27;好的写法&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>es6之后才加了let 与const，任何版本变量都可以使用var 声明。<br>var 自带变量提升。</p>
<p>关键字是js中定义好的东西，不可以声明为标识符。保留字是不是关键字的关键字。下个版本也许就是关键字了。</p>
<h5 id="商城项目"><a href="#商城项目" class="headerlink" title="商城项目"></a>商城项目</h5><p>瀑布流的数据push入数组里面，这个时候转成josn字符串再转出来。</p>
<p>uniapp编译的时候存在问题。（猜测）</p>
<p>写分页的时候，上拉加载的时候就做判断。</p>
<h5 id="催宋哥工厂图"><a href="#催宋哥工厂图" class="headerlink" title="催宋哥工厂图"></a>催宋哥工厂图</h5><h4 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h4><p>尽快结束商城<br>给爸爸打电话<br>找媳妇聊天。<br>恢复状态<br>减肥。</p>
<h5 id="心得。"><a href="#心得。" class="headerlink" title="心得。"></a>心得。</h5><p>调整状态，多学习。经验。勤为径。</p>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常用的单位和计算说明</title>
    <url>/blogs/2021/10/24/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E4%BD%8D%E5%92%8C%E8%AE%A1%E7%AE%97%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单位</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>px</td>
<td>相对长度单位</td>
</tr>
<tr>
<td>pt</td>
<td>绝对单位</td>
</tr>
<tr>
<td>rem</td>
<td>相对单位</td>
</tr>
<tr>
<td>em</td>
<td>相对单位</td>
</tr>
<tr>
<td>upx</td>
<td>uniapp主动放弃了</td>
</tr>
<tr>
<td>rpx</td>
<td>相对单位-动态宽度单位</td>
</tr>
<tr>
<td>vw</td>
<td>相对单位</td>
</tr>
<tr>
<td>vh</td>
<td>相对单位</td>
</tr>
<tr>
<td>vmin</td>
<td>相对单位，屏幕宽高相对较小的那个。</td>
</tr>
<tr>
<td>vmax</td>
<td>相对单位，屏幕宽高相对较大的那个。</td>
</tr>
</tbody></table>
<h4 id="关于px"><a href="#关于px" class="headerlink" title="关于px"></a>关于px</h4><p>1.px,是一块屏幕能展示能显示最小的像素点。<br>2.px是一个相对的绝对单位。相对指的是 都是屏幕,但是1px在不同屏幕上可能展示的大小不一样。  A屏幕的1px的长度也许会大于B屏幕的1px。</p>
<p>3.但是在网页设计中，A屏幕分辨率 300x300px  B屏幕 600x600px，各设一个width 2px，height 2px的盒子。他们大小会是一样的。</p>
<p>因为浏览器，在A屏幕是 1px 也许只是1个像素点。但是 B屏幕这样的高清屏幕，1px也许就是 2个像素点来表示1px。所以就是屏幕像素密度存在差异，但是会在浏览器会经过逻辑计算。这就是绝对。</p>
<h4 id="关于pt"><a href="#关于pt" class="headerlink" title="关于pt"></a>关于pt</h4><p>印刷行业表示字体的单位， 1/72英寸。绝对单位。<br>计算公式等于 100px * 4/3</p>
<h4 id="关于rem单位。"><a href="#关于rem单位。" class="headerlink" title="关于rem单位。"></a>关于rem单位。</h4><p>htlm根元素字体大小。 1rem 等于16px</p>
<h4 id="关于em-单位"><a href="#关于em-单位" class="headerlink" title="关于em 单位"></a>关于em 单位</h4><p>我对em单位超级超级陌生。培训班大师兄跟我说 国外喜欢用em作为字体大小来使用。<br>但是国内没必要，选择rem或者px就行了。</p>
<p>今天写这篇博客的时候，看到这篇文章<a href="https://jorux.com/archives/95-websites-of-china-need-to-rewrite-css/">。95%的中国网站需要重写CSS</a></p>
<p>由于ie浏览器的内核不支持调整网站px字体的大小。所以国外都使用了em作为web网站的字体单位。</p>
<p>但是国内没有这样去做。以至于今天，ie已经成为会议了。</p>
<p>那么em单位是什么呢。</p>
<p>em的值不是固定的，em会继承父级字体的大小。</p>
<h4 id="rpx单位。"><a href="#rpx单位。" class="headerlink" title="rpx单位。"></a>rpx单位。</h4><p>uniapp 针对屏幕的宽度会动态调整的单位。<br>计算规则如下，2px == 4rpx</p>
<p>设计稿 * A元素的px / 750 就是rpx。</p>
<p>设计稿 * 页面测试的元素宽度 / 设计稿基准宽度。</p>
<p>通常1px 等于2rpx</p>
<h4 id="vw-和-vh单位。"><a href="#vw-和-vh单位。" class="headerlink" title="vw 和 vh单位。"></a>vw 和 vh单位。</h4><p>vw 是视口的宽度 vh是视口的高度</p>
<p>vw 等于 视口的1%。<br>也是相对单位</p>
<p>1920 * 1080 1vw 等于 1920 / 100% 19.2px。</p>
<h4 id="vmax-与vmin。"><a href="#vmax-与vmin。" class="headerlink" title="vmax 与vmin。"></a>vmax 与vmin。</h4><p>vmax vmin 针对与我们字体 比如，我们手机从竖屏来到横屏。vw 和vh会发生变化。</p>
<p>vmax vmin 一个是取vw 和vh 最大的值，一个是取最小的值。</p>
<p>ps：写此篇博客是为了和ui撕逼。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css常用单位</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年9月7日日报</title>
    <url>/blogs/2021/09/07/2021%E5%B9%B49%E6%9C%887%E6%97%A5%E6%97%A5%E6%8A%A5/</url>
    <content><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><p>1.写秒杀专区。<br>2.找春鹏对接。<br>3.帮樊解决上传的问题。  </p>
<h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><p>1.秒杀专区欠支付成功页面。<br>2.小程序导航栏。<br>3.开碰头会。  </p>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1.使用vuex，不顺手。<br>2.父组件的子组件的组件库组件的样式不能在子组件修改。<br>3.上传formdata。</p>
<h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><p>1.父组件的子组件的组件库组件的样式不能在子组件修改<br>解决方法。在父组件 /deep/.子组件.ui库组件。</p>
<p>这一块需要在看看。</p>
<p>2.vuex的使用。和组件的运用。</p>
<h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ol>
<li>给家人打电话。</li>
<li>减肥</li>
<li>焦躁</li>
</ol>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>git团队协作</title>
    <url>/blogs/2021/09/02/git%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>客驾到的时候，我使用了breach，来进行分支管控。<br>dev分支用来开发。master用来合并。</p>
<p>如果我和A君一起开发的话，我俩一起在一个dev分支下进行开发。然后去master进行合并。<br>春鹏告诉我，我们可以一人一个分支去玩的。一起往master上面合并。我意识到我对breach 的使用略显不足，所以补充一下我的理解。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>客驾到项目中，我想的更多的是 ，想通过分支来做一个<strong>沙盒</strong>。进行<strong>隔绝</strong>。<br>去进行<strong>区分</strong>。</p>
<p>但是，分支给我带来的体验并不好，因为2个人使用一个分支，我与A君，我们两个人之间，没有沙盒。</p>
<p>如果这个时候 B君也参与了进来，我们三个人，使用一个dev分支。超级容易打架。</p>
<h4 id="多分支开发。"><a href="#多分支开发。" class="headerlink" title="多分支开发。"></a>多分支开发。</h4><p>标准团队协作模式下进行开发。</p>
<p>应该有这样的分支。</p>
<p><strong>master</strong>  <strong>hotfix</strong> <strong>develop</strong> <strong>feature</strong> <strong>release</strong></p>
<table>
<thead>
<tr>
<th>分支名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>主分支，随时都得处于发布状态。</td>
</tr>
<tr>
<td>hotfix</td>
<td>修复线上的bug</td>
</tr>
<tr>
<td>develop</td>
<td>开发分支</td>
</tr>
<tr>
<td>feature</td>
<td>开发功能分支。</td>
</tr>
<tr>
<td>release</td>
<td>预发布分支。</td>
</tr>
</tbody></table>
<p>首先咱们先从 master分支下 创建 develop<br>develop 下创建 feature分支，用来开发功能。<br>功能开发结束，develop合并feature的功能。<br>然后从develop签出一条 release分支。用来准备发布。<br>出现bug，release修复bug，修复结束，同步给develop，与matser分支。</p>
<p>master分支 出现bug。</p>
<p>建立hotfix分支。修复bug。修复成功同步给master 与develop。</p>
<p>主要还是围绕着master 与 develop来展开的。</p>
<p>这就是标准的 git团队协作。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年8月14日日报</title>
    <url>/blogs/2021/08/14/2021%E5%B9%B48%E6%9C%8814%E6%97%A5%E6%97%A5%E6%8A%A5/</url>
    <content><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><ol>
<li>看webview与iframe</li>
<li>对着html进行查漏补缺</li>
<li>gitee，实名</li>
<li>看naive ui</li>
<li>uniapp，阅读了一下入门知识</li>
<li>html语义化规范</li>
</ol>
<h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><ul>
<li>递归算法</li>
<li>nuxt</li>
<li>uniapp router权限控制</li>
</ul>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><ul>
<li><p>webview是什么。  </p>
<blockquote>
<ol>
<li>浏览器专门针对像java啊，ios 安卓这样原生语言来设计的</li>
<li>原生应用就像一个孤岛。需要使用webview来接入web服务端的内容。</li>
<li>webview更像一个浏览器的渲染引擎。</li>
<li>通过webview，JavaScript可以调用原生的api，原生也可以加载web端的信息。</li>
</ol>
</blockquote>
</li>
<li><p>iframe是什么。</p>
<blockquote>
<p>1.html标签<br>2.加载网页。<br>3.上古时期的前端开发者用它来轮询。<br>4.自带一个沙盒机制。与页面代码互不打扰。<br>5.网页广告情况泛滥。<br>6.因为不知道别人有没有拿你的页面iframe，你会不会拿别人的页面iframe 所以不安全。</p>
</blockquote>
</li>
<li><p>html 标签查漏补缺。</p>
<blockquote>
<p>1.里面有个details标签。<br>2.meter 标签很有意思。<br>3.做好语义化。</p>
</blockquote>
</li>
</ul>
<h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><ul>
<li>html语义化与html常用标签。</li>
<li>webview与iframe</li>
</ul>
<h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ul>
<li>效率低下</li>
<li>今天没有使用番茄钟</li>
</ul>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>html查漏补缺</title>
    <url>/blogs/2021/08/14/%E9%87%8D%E6%96%B0%E5%A4%8D%E4%B9%A0html/</url>
    <content><![CDATA[<h5 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h5><p>一个优秀的前端开发者，一定不是靠着一手所谓的<div><p>标签一把梭的。</p>
<p>即使html是一个超文本标记语言。JavaScript一直以来才是web开发者中的重中之重。</p>
<h5 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h5><ol>
<li><code>&lt;article&gt;&lt;/article&gt;</code>标签</li>
</ol>
<blockquote>
<p>w3cschool 是这样描述它的。article元素规定独立的自包含内容。  </p>
<article>元素的应用场景是 论坛，博客，新闻。
</blockquote>
<p>独立的自包含内容，指的是，article标签，内部可以设置header，footer各种标签。来展示一篇独立的文章内容。</p>
<ol start="2">
<li><code>&lt;aside&gt;&lt;/aside&gt;</code></li>
</ol>
<blockquote>
<p>aside标签2种用法。<br>要么文章标题的补充部分。<br>要么就是侧边栏。<br>与div差不多，但是html5 推行语义化标签的结果。</p>
</blockquote>
<ol start="3">
<li><code>&lt;bdi&gt;&lt;bdi&gt;</code></li>
</ol>
<blockquote>
<p>我感觉 bdi标签没啥卵用。<br>标签允许您设置一段文本，使其脱离其父元素的文本方向设置。在发布用户评论或其他您无法完全控制的内容时</p>
</blockquote>
<blockquote>
<p>文档上是这么说。</p>
</blockquote>
<blockquote>
<p>但是在我眼里，这标签只会把 所谓的文字 如果是数字的话 改变一些排列的方向而已。</p>
</blockquote>
<ol start="4">
<li><code>&lt;details&gt;&lt;/details&gt;与, &lt;summary&gt;&lt;summary/&gt;    </code></li>
</ol>
<blockquote>
<p>details是用于描述文档的细节。<br>summary details的标题。</p>
</blockquote>
<p>上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;details draggable=&quot;true&quot;&gt;</span><br><span class="line">    &lt;summary&gt;详情菜单&lt;/summary&gt;</span><br><span class="line">    &lt;div&gt;详情内容&lt;/div&gt;</span><br><span class="line">&lt;/details&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>&lt;dialog&gt;&lt;/dialog&gt;</code></li>
</ol>
<blockquote>
<p>一个对话框，弹窗标签。open 打开关闭与否。<br>能和form配合使用。</p>
</blockquote>
<ol start="6">
<li><code>&lt;figure&gt;&lt;/figure&gt;   &lt;figcaption&gt;&lt;/figcaption&gt;</code></li>
</ol>
<blockquote>
<p>用作文档中插图的图像，带有一个标题：figcaption。使用场景语焉不详</p>
</blockquote>
<ol start="7">
<li><code>&lt;main&gt;&lt;/main&gt;</code></li>
</ol>
<blockquote>
<p>main标签对于文档来说 应该是唯一的。<br>文档最重要的内容。<br>不能嵌套hader footer等。应该保持平级。</p>
</blockquote>
<ol start="8">
<li><code>&lt;mark&gt;&lt;/mark&gt;</code></li>
</ol>
<blockquote>
<p>定义重要或强调的内容。</p>
</blockquote>
<ol start="9">
<li><code>&lt;meter&gt;&lt;/meter&gt;</code></li>
</ol>
<blockquote>
<p>它进度条<progress>的标签不一样的是，它更适合在磁盘用量，手机电量的展示上面。</p>
</blockquote>
<p>上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meter value=&quot;0.2&quot; max=&quot;1&quot; min=&quot;0&quot; low=&quot;0.1&quot; high=&quot;0.2&quot; optimum=&quot;1&quot; &gt;&lt;/meter&gt;</span><br><span class="line">/**</span><br><span class="line">   * max 最大的值</span><br><span class="line">   * min 最小的值</span><br><span class="line">   * high 被规定高的范围</span><br><span class="line">   * low 被规定低的范围</span><br><span class="line">   * optimum 规定度量的优化值。</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="10">
<li><code>&lt;nav&gt;&lt;/nav&gt;</code></li>
</ol>
<blockquote>
<nav> 标签定义导航链接的部分。
</blockquote>
<ol start="11">
<li><code>&lt;progress&gt;&lt;/progress&gt;</code></li>
</ol>
<blockquote>
<p>进度条 无需多言。</p>
</blockquote>
<ol start="12">
<li><code>&lt;section&gt;&lt;/section&gt;</code></li>
</ol>
<blockquote>
<p>表示文档中的一个章节。</p>
</blockquote>
<ol start="13">
<li><code>&lt;&lt;wbr&gt;</code></li>
</ol>
<blockquote>
<p>在合适的位置换行，如果文字一行排放不完的话。wbr换行，让文本没那么割裂。</p>
</blockquote>
<p>14.<code>base </code></p>
<blockquote>
<p>是要设置在 heade标签里面了。规定了所有的超链接，该如何跳转。<br>当前页还是新开一个页面。</p>
</blockquote>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html lang=&quot;zh&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;刘超的demo&lt;/title&gt;</span><br><span class="line">    &lt;!--设置base target 来保证所有的超链接都该怎么样跳转--&gt;</span><br><span class="line">    &lt;base target=&quot;_blank&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/index.css&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.w3school.com.cn&quot; &gt;W3School&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;./js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="15">
<li><code>blockquote</code></li>
</ol>
<blockquote>
<p>标记长的引用。比如一个段落。</p>
</blockquote>
<ol start="16">
<li><code>datalist</code></li>
</ol>
<blockquote>
<p>datalist，input的可能选项列表。来定义input可能出现的值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;myCar&quot; list=&quot;cars&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;cars&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;BMW&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Ford&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;Volvo&quot;&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="17">
<li><code> &lt;optgroup&gt; &lt;/optgroup&gt;</code></li>
</ol>
<blockquote>
<p>把select一些相关的选项组合在一起</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;optgroup label=&quot;Swedish Cars&quot;&gt;</span><br><span class="line">    &lt;option value =&quot;volvo&quot;&gt;Volvo&lt;/option&gt;</span><br><span class="line">    &lt;option value =&quot;saab&quot;&gt;Saab&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt;</span><br><span class="line"></span><br><span class="line">  &lt;optgroup label=&quot;German Cars&quot;&gt;</span><br><span class="line">    &lt;option value =&quot;mercedes&quot;&gt;Mercedes&lt;/option&gt;</span><br><span class="line">    &lt;option value =&quot;audi&quot;&gt;Audi&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="18">
<li><code>&lt;picture&gt;&lt;/picture&gt;</code></li>
</ol>
<blockquote>
<p>picture标签 不同的尺寸下展示不同的图片。</p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年8月13日日报</title>
    <url>/blogs/2021/08/13/2021%E5%B9%B48%E6%9C%8813%E6%97%A5%E6%97%A5%E6%8A%A5/</url>
    <content><![CDATA[<h5 id="已完成的事情"><a href="#已完成的事情" class="headerlink" title="已完成的事情"></a>已完成的事情</h5><ol>
<li>智喔喔调试bug。</li>
<li>部署nuxt打包。</li>
<li>指定番茄钟。</li>
<li>扫了一眼rust。</li>
<li>三元表达式里面使用匿名函数。</li>
</ol>
<h5 id="未完成的事情"><a href="#未完成的事情" class="headerlink" title="未完成的事情"></a>未完成的事情</h5><ol>
<li>智喔喔安卓调试</li>
<li>商城等待开工</li>
<li>uniapp文章待看</li>
</ol>
<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1.nuxt打包问题。</p>
<p>nuxt的打包模式分为 build，和generate。<br>其中build里面打包，需要后端配置node，并且，但是需不需要做转发不得而知。</p>
<p>好像generate打包的是静态文件。但是却也可以使用。为了准确尽快出活。我没有细究。</p>
<p>2.跨域问题</p>
<p>我总感觉，nuxt就好像不需要跨域一样。待测试。</p>
<p>3.三元表达式-结合匿名函数一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var state = true;</span><br><span class="line">state ? (()=&gt;&#123;alert(11)&#125;)():(function b()&#123;alert(22)&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写完匿名函数之后，咱们需要多加个括号，表示是一个代码块。后面跟一个括号。</p>
<p>4.看春鹏的代码，了解了一些关于代码的规范。</p>
<p>比如，这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * description：刘超的代码</span><br><span class="line"> * author：刘超</span><br><span class="line"> * signa：只争朝夕</span><br><span class="line"> * timer：20点42分</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.nuxt更改布局页面。<br>nuxt在layouts，指定了多种布局方式，包括报错页面。与我们的视图。可以互相配合。互不干扰。</p>
<p>比如我不需要login加载导航栏。那就专门针对login。加载一个布局方式。</p>
<p>6.我们只需要在 vue文件下面layout:’指定的布局’</p>
<p>7.rust，具体印象，前端中后端语言，速度比c，c++快。</p>
<h5 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h5><ol>
<li>指定优秀的学习计划。</li>
<li>多看一些东西。</li>
<li>多像春鹏学习</li>
<li>nuxt的打包。</li>
</ol>
<h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><ol>
<li>少说话</li>
<li>三思而行</li>
</ol>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue路由组件传参</title>
    <url>/blogs/2021/07/10/vue%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<h3 id="关于vue-router组件的传参"><a href="#关于vue-router组件的传参" class="headerlink" title="关于vue router组件的传参"></a>关于vue router组件的传参</h3><h5 id="提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？"><a href="#提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？" class="headerlink" title="提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？"></a>提到，使用router进行传参，你会想到什么。从A页面，到B页面。只使用router，都有那些方式？</h5><ol>
<li> 比如vue 动态路由参数匹配？</li>
<li> 还是使用vue params，传参，比如通过router上的name，才能跳转，刷新一下参数就掉。</li>
<li> 还是比如query，参数拼接到字符串上？</li>
</ol>
<p>我们假设一个场景，我们在A页面到B页面，要传递一个object。是的，你一定要json一下，<br>在B页面接收都要做那些步骤。</p>
<ol>
<li>先写上一段，this.$route.query.object ….（我不说你也得觉得很长）</li>
<li>把拿到的参数josn化。</li>
<li>要把参数赋值到data，然后data再去使用。</li>
</ol>
<h5 id="发现的问题"><a href="#发现的问题" class="headerlink" title="发现的问题"></a>发现的问题</h5><h6 id="1-你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。"><a href="#1-你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。" class="headerlink" title="1. 你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。"></a>1. 你是知道的，A页面想去B页面。那么如果C也想去B页面，并且不打算传参你该如何解决。</h6><p>解决方案也简单，写个判断语句嘛。if，三元表达式，或者query，传递不同的标识符。这样页面C跳转B也没啥问题了。</p>
<h6 id="2-this-router-query-object-真的是一种很舒服的传参方式嘛，这么长。"><a href="#2-this-router-query-object-真的是一种很舒服的传参方式嘛，这么长。" class="headerlink" title="2. this.$router.query.object,真的是一种很舒服的传参方式嘛，这么长。"></a>2. this.$router.query.object,真的是一种很舒服的传参方式嘛，这么长。</h6><p>不是。</p>
<p>这就是我要讲vue router 组件传参的意义。</p>
<p>路由传参有三种模式</p>
<h6 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h6><p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//router部分</span><br><span class="line">  &#123;</span><br><span class="line">    name:&#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props: true //直接开启布尔模式</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  //跳转</span><br><span class="line">&lt;router-link :to=&quot;&#123;name: &#x27;user&#x27;,params: &#123;name: &#x27;word&#x27;,  age: &#x27;11&#x27;&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">//页面取参数</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;name&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/div&gt;&lt;!--参数是word11--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: [&#x27;params&#x27;,&#x27;name&#x27;,&#x27;age&#x27;],</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>布尔模式下，props：true的情况下，params的参数会被设置为组件的props。</p>
<h6 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h6><p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  router部分</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    name: &#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props: &#123;</span><br><span class="line">      name: &#x27;11&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">//跳转</span><br><span class="line">  &lt;router-link :to=&quot;&#123;name: &#x27;user&#x27;, params:&#123;name:&#x27;word&#x27;,age:&#x27;11&#x27;,&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  页面</span><br><span class="line">  </span><br><span class="line">    &lt;template&gt;</span><br><span class="line">         &lt;div&gt;user&#123;&#123; name &#125;&#125;&#123;&#123; age &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [ &quot;name&quot;, &quot;age&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对象模式只适合给静态类型的数据。。routerlink 传递进去的数据 拿不到。</p>
<p>函数模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//router</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    name: &#x27;user&#x27;,</span><br><span class="line">    path: &#x27;/user&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    props:route=&gt;(&#123;//函数模式，把route的参数给解构了。</span><br><span class="line">      name:route.query.name,</span><br><span class="line">      age:route.query.age,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  //跳转</span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&#x27;/user&#x27;,query:&#123;name:&#x27;word&#x27;,age:&#x27;11&#x27;&#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br><span class="line">  </span><br><span class="line">//user页面接收参数</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;user&#123;&#123; name &#125;&#125;&#123;&#123; age &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;!--参数是word11--&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;query&#x27;, &quot;name&quot;, &quot;age&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>


<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><table>
<thead>
<tr>
<th>模式</th>
<th>特性</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值模式</td>
<td>props，属性为true，route.params，自动绑定为属性</td>
<td>不支持query</td>
</tr>
<tr>
<td>对象模式</td>
<td>适合静态类型</td>
<td>不支持动态类型</td>
</tr>
<tr>
<td>函数模式</td>
<td>支持params，query</td>
<td>没啥毛病</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的router</title>
    <url>/blogs/2021/07/10/vue%E7%9A%84router/</url>
    <content><![CDATA[<h5 id="vue-动态路由"><a href="#vue-动态路由" class="headerlink" title="vue 动态路由"></a>vue 动态路由</h5><p>很多时候,向url上传参都是使用的，query传参，因为params很多时候，视图你需要靠name来找。</p>
<p>但是 动态路由，可以让我们在路由的url上面去定义一个参数。跳转的时候把参数传入过去就能匹配到该页面。</p>
<p>比如我们有个查询接口，id来查找非常好用。</p>
<p>代码例子如下。</p>
<p>我的router</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/about/:id&#x27;,</span><br><span class="line">    name: &#x27;About&#x27;,</span><br><span class="line">    // route level code-splitting</span><br><span class="line">    // this generates a separate chunk (about.[hash].js) for this route</span><br><span class="line">    // which is lazy-loaded when the route is visited.</span><br><span class="line">    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跳转既可以使用 <routerlink>标签，也可以使用this.$router.push({path:”/url/params”})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/about/111&quot;&gt;动态路由&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p>在路由的匹配页面上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$route.params.id,我们就能拿到。</span><br></pre></td></tr></table></figure>


<h5 id="关于匹配模式"><a href="#关于匹配模式" class="headerlink" title="关于匹配模式"></a>关于匹配模式</h5><p>常规的匹配模式，vue router 只匹配/分割开来的片段字符。如果想匹配任何路径，就需要使用通配符 </p>
<p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path:&#x27;/user-*&#x27;</span><br></pre></td></tr></table></figure>
<p>那么 ，/user /user-love,/user-test，<br>*字通配符都能匹配得到。</p>
<p>不过我们一般会用 *号来匹配 ，查找不到的路径。<br>比如 404.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/404&#x27;,</span><br><span class="line">  name: &#x27;404&#x27;,</span><br><span class="line">  component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/404.vue&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  // 会匹配所有路径</span><br><span class="line">  path: &#x27;*&#x27;,</span><br><span class="line">  redirect:&#x27;/404&#x27;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只要匹配不到的路径 都会去 404</p>
<p>其他的匹配规则，暂时先不去看。我感觉有会用到他的一天，但是不是现在。</p>
<h5 id="vue-router-路由的嵌套"><a href="#vue-router-路由的嵌套" class="headerlink" title="vue router 路由的嵌套"></a>vue router 路由的嵌套</h5><p>//首先我们要给 /about 添加几个要嵌套的视图。</p>
<ol>
<li>children里面添加我们想要嵌套的视图。</li>
<li>子视图path 不带 “/”</li>
<li>父视图里面添加routerview</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/about&#x27;,</span><br><span class="line">  name: &#x27;About&#x27;,</span><br><span class="line">  component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;),</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;user&#x27;,</span><br><span class="line">      component:()=&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;info&#x27;,</span><br><span class="line">      component:()=&gt; import(&#x27;../views/info.vue&#x27;),</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>视图嵌套出现的小问题。<br>我们需要 访问 /user/info 如果 不访问 /info 就只跳转到 /user页面的话。很尴尬。</p>
<p>所以我们要对 如果他直接访问我们user的情况下进行重定向。</p>
<p>访问 user的情况下 直接重定向到 /user/xxxxx页面。</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/about&#x27;,</span><br><span class="line">  redirect:&#x27;/about/user&#x27;,//我们在这里重定向</span><br><span class="line">  name: &#x27;About&#x27;,</span><br><span class="line">  component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;),</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;user&#x27;,</span><br><span class="line">      component:()=&gt; import(&#x27;../views/user.vue&#x27;),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;info&#x27;,</span><br><span class="line">      component:()=&gt; import(&#x27;../views/info.vue&#x27;),</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>命名路由的，可以直接 this.$router.push({name:’user’})</p>
<p>但是我不需要这样写。略….</p>
<h5 id="命名视图与嵌套视图。"><a href="#命名视图与嵌套视图。" class="headerlink" title="命名视图与嵌套视图。"></a>命名视图与嵌套视图。</h5><p>vue router 的命名视图，我大概是明白怎么使用了。但是不知道怎么样更好的去使用他。</p>
<p>例子如下。</p>
<p>1，命名视图的组件是使用components的。不是component。<br>2.设置默认的视图名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/&#x27;,</span><br><span class="line">  name: &#x27;Home&#x27;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    default:Home,</span><br><span class="line">    user:()=&gt; import(&#x27;../views/user&#x27;),</span><br><span class="line">    info:()=&gt; import(&#x27;../views/info&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在app.vue里面使用多个routerview</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view name=&quot;user&quot; /&gt;</span><br><span class="line">    &lt;router-view name=&quot;info&quot; /&gt;</span><br><span class="line">    &lt;router-view  /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="vue编程式导航"><a href="#vue编程式导航" class="headerlink" title="vue编程式导航"></a>vue编程式导航</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&#x27;...&#x27;&gt;&lt;/router-link&gt;</span><br><span class="line">等于我们调用的this.$router.push(),方式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>router</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>router.push()</td>
<td>往浏览器的history有记录</td>
</tr>
<tr>
<td>router.replace()</td>
<td>跳转美誉history记录</td>
</tr>
<tr>
<td>router.go()</td>
<td>向前向后跳转history记录</td>
</tr>
</tbody></table>
<h5 id="vue-router的重定向与别名"><a href="#vue-router的重定向与别名" class="headerlink" title="vue router的重定向与别名"></a>vue router的重定向与别名</h5><p>关于重定向。比如我们要访问一个/home的路径。可以通过redirect，来让我们跳到其他页面。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加载到首页，通过redirect 跳到了404页面。</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    redirect:&#x27;/404&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      default:Home,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们也可以一个方法动态返回要重定向的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法接收目标参数 return返回参数。</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    redirect:to=&gt;&#123;</span><br><span class="line">      return &#x27;/404&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      default:Home,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>router 别名的概念。</p>
<p>别名的是意思是，例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们访问 / 可以去跳转到首页。/home也能跳转到首页。虽然url是/home，但是匹配的规则还是/。</span><br><span class="line"></span><br><span class="line">就像小名与大名一样。</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    alias:&#x27;/home&#x27;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      default:Home,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名字</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>redirect</td>
<td>访问/a,重定向访问/b，</td>
</tr>
<tr>
<td>alias</td>
<td>别名访问和匹配规则，与你正常访问的url匹配到一起。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue数组对象赋值问题</title>
    <url>/blogs/2021/06/25/vue%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h5 id="数组的更新监测"><a href="#数组的更新监测" class="headerlink" title="数组的更新监测"></a>数组的更新监测</h5><p>vue是一个响应式的框架。data里面的数据的改动，会随时随地的传到view视图里面。</p>
<p>但是，对于data里面的object类型的数据，并不是这样的。</p>
<p>数组的更新监测，只有一下这些方法才能触发视图的更新。</p>
<table>
<thead>
<tr>
<th>触发视图更新的方法</th>
</tr>
</thead>
<tbody><tr>
<td>push()</td>
</tr>
<tr>
<td>pop()</td>
</tr>
<tr>
<td>shift()</td>
</tr>
<tr>
<td>unshift()</td>
</tr>
<tr>
<td>splice()</td>
</tr>
<tr>
<td>sort()</td>
</tr>
<tr>
<td>reverse()</td>
</tr>
</tbody></table>
<h5 id="遇到的问题。"><a href="#遇到的问题。" class="headerlink" title="遇到的问题。"></a>遇到的问题。</h5><p>1，我想对一个数组的1号位进行赋值。而且我不想使用数组方法。splie(),什么什么的。但是视图不会更新。</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for=&quot;(item,index) in arr&quot; :key=&#x27;index&#x27;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">    //页面渲染出来的是 1 3 3 4</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;11&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      arr:[1,2,3,4],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    test() &#123;</span><br><span class="line">      this.arr[0] = 11;</span><br><span class="line">      console.log(this.arr);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created()&#123;</span><br><span class="line">    this.arr[1] = 3;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.arr[2] = 12;</span><br><span class="line">    // console.log(this.arr); [1,3,12,4]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么会这样，因为 data里面检测不到 对数组的改动。created的赋值，为什么被视图监测到了？</p>
<p>尤大大的文档： </p>
<blockquote>
<p>当你把一个普通的 JavaScript 对象传入 ==Vue 实例==作为 data 选项，Vue 将==遍历==此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 ==getter/setter==。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
</blockquote>
<blockquote>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面</p>
</blockquote>
<p>通俗语言解释下</p>
<p>vue创建实例的时候，会把我们data里面的所有数据，全部转为getter 与 setter。</p>
<p>所以created 正是创建vue实例的时候。所以 isok。</p>
<p>但是 如果我们在 mounted生命周期函数里面操作的话，如果我们写个事件对data里面的数组赋值的话。</p>
<p>就必须要使用 this.$set方法。来进行。</p>
<h5 id="使用-this-set-方法。"><a href="#使用-this-set-方法。" class="headerlink" title="使用 $this.set()方法。"></a>使用 $this.set()方法。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-for=&quot;(item,index) in arr&quot; :key=&#x27;index&#x27;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;11&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      arr:[1,2,3,4],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    test() &#123;</span><br><span class="line">      this.$set(this.arr,1,12);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created()&#123;</span><br><span class="line">    this.$set(this.arr,0,2);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // console.log(this.arr)</span><br><span class="line">    this.arr[1] = 3;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Vue.set( target, propertyName/index, value )</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件基础</title>
    <url>/blogs/2021/06/25/vue%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="vue的组件基础"><a href="#vue的组件基础" class="headerlink" title="vue的组件基础"></a>vue的组件基础</h4><p>创建一个组件</p>
<p>1，我们在src文件夹下面的components文件下，创建了一个组件。代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#x27;cell&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            count:0,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>和平常写的vue组件没啥两样。</p>
<h5 id="关于组件的复用"><a href="#关于组件的复用" class="headerlink" title="关于组件的复用"></a>关于组件的复用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;My-cell&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;My-cell&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;My-cell&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;My-cell&gt;&lt;/My-cell&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个组件都是独立的。里面的值不会出现窜。</p>
<p>组件的data必须必须必须是一个函数。<br>所以每个组件实例都会都可以维护一个返回实例的拷贝。</p>
<h5 id="关于组件中的prop。"><a href="#关于组件中的prop。" class="headerlink" title="关于组件中的prop。"></a>关于组件中的prop。</h5><p>1,prop是一个单向数据流，数据从组件外，自然而然的流向组件内。<br>2，组件内顶柜的prop来接收，组件外的指定参数。<br>3，prop可以校验数据的格式。</p>
<p>组件添加props</p>
<p>props我们可以指定数据类型与格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#x27;我想静静&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    content:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#x27;假装我是一篇文章....&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    number:&#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        default:0,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell :content=&quot;content&quot; :title=&quot;title&quot;&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content:&#x27;你好阿，小老弟&#x27;,</span><br><span class="line">      title:&#x27;你好aaaa    &#x27;,</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h5><p>使用emit(),抛出事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;click()&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;cell&quot;,</span><br><span class="line">  props:&#123;</span><br><span class="line">      title:&#123;</span><br><span class="line">          type:String,</span><br><span class="line">          default:&#x27;我想静静&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      content:&#123;</span><br><span class="line">          type:String,</span><br><span class="line">          default:&#x27;假装我是一篇文章....&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      number:&#123;</span><br><span class="line">          type:Number,</span><br><span class="line">          default:0,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click() &#123;</span><br><span class="line">        this.$emit(&#x27;getdata&#x27;,this.number);//0</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>getdata 拿到事件抛出的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell :content=&quot;content&quot; :title=&quot;title&quot; @getdata=&#x27;getdata&#x27;&gt;&lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content:&#x27;你好阿，小老弟&#x27;,</span><br><span class="line">      title:&#x27;你好aaaa    &#x27;,</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata(e)&#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="组件的插槽，可以命名。让组件更加灵活。"><a href="#组件的插槽，可以命名。让组件更加灵活。" class="headerlink" title="组件的插槽，可以命名。让组件更加灵活。"></a>组件的插槽，可以命名。让组件更加灵活。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用组件的 slot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell&gt;</span><br><span class="line">      &lt;div slot=&quot;header&quot;&gt;11&lt;/div&gt;</span><br><span class="line">       &lt;div slot=&quot;main&quot;&gt;22&lt;/div&gt;</span><br><span class="line">        &lt;div slot=&quot;footer&quot;&gt;33&lt;/div&gt;</span><br><span class="line">    &lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content:&#x27;你好阿，小老弟&#x27;,</span><br><span class="line">      title:&#x27;你好aaaa    &#x27;,</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata(e)&#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5><p>插槽可以命名，也可以绑定数据。但是必须要使用template 元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot; :user=&#x27;obj&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;cell&quot;,</span><br><span class="line">  data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">          obj:&#123;</span><br><span class="line">              name:&#x27;里斯哦&#x27;,</span><br><span class="line">              age:11,</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<p>我们可以使用 scope.user.name,来访问数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell&gt;</span><br><span class="line">      &lt;template v-slot:header=&#x27;scope&#x27;&gt;&#123;&#123;scope.user.name&#125;&#125;&lt;/template&gt;</span><br><span class="line">       &lt;div slot=&quot;main&quot;&gt;22&lt;/div&gt;</span><br><span class="line">        &lt;div slot=&quot;footer&quot;&gt;33&lt;/div&gt;</span><br><span class="line">    &lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj:&#123;</span><br><span class="line">        name:11,</span><br><span class="line">        age:&#x27;111&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata(e)&#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h5 id="组件的动态切换插槽。"><a href="#组件的动态切换插槽。" class="headerlink" title="组件的动态切换插槽。"></a>组件的动态切换插槽。</h5><p>v-slot:[参数]</p>
<p>例子如下，组件我们2个插槽都会给上不同的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;zz&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot; :usr=&#x27;obj&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;main&quot; :username=&#x27;obj.name&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot; :age=&#x27;obj.age&#x27;&gt;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;cell&quot;,</span><br><span class="line">  data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">          obj:&#123;</span><br><span class="line">              name:&#x27;里斯哦&#x27;,</span><br><span class="line">              age:11,</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;My-cell&gt;</span><br><span class="line">      &lt;template v-slot:header=&quot;scope&quot;&gt;&#123;&#123; scope.usr.name &#125;&#125;&lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:[name]=&quot;scope&quot;&gt;&#123;&#123;scope&#125;&#125;&lt;/template&gt;</span><br><span class="line">    &lt;/My-cell&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import cell from &quot;../components/cell/index.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      obj: &#123;</span><br><span class="line">        name: 11,</span><br><span class="line">        age: &quot;111&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      name: &quot;footer&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &quot;My-cell&quot;: cell,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getdata(e) &#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>插槽可以缩写 用#来表示 v-slot:header=’scope’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;My-cell&gt;</span><br><span class="line">  &lt;template #header=&#x27;scope&#x27;&gt;&#123;&#123; scope.usr.name &#125;&#125;&lt;/template&gt;</span><br><span class="line">  &lt;template #[name]=&quot;scope&quot;&gt;&#123;&#123;scope&#125;&#125;&lt;/template&gt;</span><br><span class="line">&lt;/My-cell&gt;</span><br></pre></td></tr></table></figure>



<p>总结</p>
<table>
<thead>
<tr>
<th>组件属性</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>$emit()</td>
<td>子组件抛出去一个自定义事件，传一个参数。</td>
</tr>
<tr>
<td>props</td>
<td>单向数据流，父传子，监测数据类型，默认值。</td>
</tr>
<tr>
<td>slot</td>
<td>带一个插槽，可以指定名字，也可以成为作用域插槽，#表示缩写。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中class与style绑定</title>
    <url>/blogs/2021/06/23/vue%E4%B8%AD%E7%9A%84class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h5 id="class的绑定"><a href="#class的绑定" class="headerlink" title="class的绑定"></a>class的绑定</h5><p>1.通过v-bind：对象语法绑定class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; class=&quot;b-b-w-1&quot; :class=&quot;&#123;active:isactive,error:isactive&#125;&quot; value=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>class中的 active 的绑定完全依赖于 isactive的布尔值。<br>class 绑定的静态类型与v-bind绑定动态类型，class最终还是会汇聚到一起。也就是这个样子。</p>
<p>class=’b-b-w-1 active error’;</p>
<p>绑定class的对象不一定非要在，模板里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; class=&quot;b-b-w-1&quot; :class=&quot;objclass&quot; value=&quot;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">   data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">	    objclass:&#123;</span><br><span class="line">		active:true,</span><br><span class="line">		error:true,</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class=’b-b-w-1 active error’;</p>
<p>2.给class绑定一个数组，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; class=&quot;b-b-w-1&quot; :class=&quot;[&#x27;active&#x27;,&#x27;isactive&#x27;]&quot; value=&quot;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>甚至我们还能使用三元运算符 来绑定class。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; value=&quot;&quot; v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, &#x27;errorClass&#x27;]&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; value=&quot;&quot; :class=&quot;activeClass == isActive ? &#x27;&#x27;:&#x27;errorClass&#x27;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.给组件绑定class</p>
<p>class会将被添加到组件的根元素上。</p>
<p>简单写个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;myElement class=&#x27;test test1&#x27; &gt;&lt;/myElement&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果组件添加一个class，组件上本身就已经有一个class了。那么就不会覆盖。而是，共存。</p>
<p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;myElement class=&#x27;test test&#x27; &gt;&lt;/myElement&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>4.v-bind绑定 内联样式，强烈不推荐内联的写法。<br>但是必要的时候还是离不开，因为只有pc有hover效果，移动端需要active来模拟。</p>
<p>so，<br>看例子把。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&quot; :style=&quot;&#123;color:&#x27;red&#x27;,backgroundColor:size&#125;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写样式最好使用 驼峰命名，第二个单词首字母大写。</p>
<p>内联样式绑定对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;&quot; :style=&quot;objStyle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">objStyle:&#123;</span><br><span class="line">	backgroundColor:&#x27;red&#x27;,</span><br><span class="line">	color:&#x27;#ffffff&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内联样式 同样也可以绑定，数组语法。数组里面的对象是样式的集合。但是却没有class名。</p>
<p>优点就是我们省下来一个class名，确定就是权重贼高。</p>
<p>数组语法和对象语法，阅读起来更舒服。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   &lt;input type=&quot;text&quot; value=&quot;&quot; :style=&quot;[objStyle,objStyle1]&quot; /&gt;</span><br><span class="line"></span><br><span class="line">   objStyle: &#123;</span><br><span class="line">	backgroundColor: &#x27;red&#x27;,</span><br><span class="line">	color: &#x27;#ffffff&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">objStyle1: &#123;</span><br><span class="line">	color: &#x27;#ffffff&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue计算属性与侦听器</title>
    <url>/blogs/2021/06/23/vue%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h4 id="vue的计算属性与侦听器"><a href="#vue的计算属性与侦听器" class="headerlink" title="vue的计算属性与侦听器"></a>vue的计算属性与侦听器</h4><p>computed的特性</p>
<ol>
<li>computed会观察data里面的所有数据的变化。</li>
<li>computed，观察改变的数据，你有使用才会执行。</li>
<li>computed数据会有缓存，计算的是默认值，你有你值改变了才会再次计算。</li>
</ol>
<h5 id="computed的-getter函数，与setter函数。"><a href="#computed的-getter函数，与setter函数。" class="headerlink" title="computed的 getter函数，与setter函数。"></a>computed的 getter函数，与setter函数。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上代码</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class=&quot;content&quot;&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; v-model=&quot;value  &quot; /&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; v-model=&quot;value1&quot; /&gt;</span><br><span class="line">		&#123;&#123;example&#125;&#125;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				value: 1,</span><br><span class="line">				value1: 11,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		computed: &#123;</span><br><span class="line">			// 计算属性的 getter</span><br><span class="line">			example: &#123;</span><br><span class="line">				get(e) &#123;</span><br><span class="line">					console.log(e)</span><br><span class="line">					return e.value * 2;</span><br><span class="line">				&#125;,</span><br><span class="line">				set(value) &#123;</span><br><span class="line">					this.value = value;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		onLoad() &#123;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">		onShow() &#123;</span><br><span class="line">		    //调用setter函数赋值。</span><br><span class="line">			this.example = 122;</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="computed与watch的区别。"><a href="#computed与watch的区别。" class="headerlink" title="computed与watch的区别。"></a>computed与watch的区别。</h5><p>computed更适合，针对一个数据的变化而进行变化。比如商品的价格等于，件数*价格-优惠券-折扣卡。这样的值，更适合computed来去做。<br>因为computed需要依赖其他数据。</p>
<p>watch的改变。更多程度上，更适用于，一个数据发生变化后做一些事情。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue模板语法的查漏补缺</title>
    <url>/blogs/2021/06/22/vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%E7%9A%84%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<h4 id="一直以来，都没有认真的看过vue的文档。所以把一些细节性的东西给过一遍。查漏补缺。"><a href="#一直以来，都没有认真的看过vue的文档。所以把一些细节性的东西给过一遍。查漏补缺。" class="headerlink" title="一直以来，都没有认真的看过vue的文档。所以把一些细节性的东西给过一遍。查漏补缺。"></a>一直以来，都没有认真的看过vue的文档。所以把一些细节性的东西给过一遍。查漏补缺。</h4><h5 id="1-关于vue的模板语法，表达式。我使用的很少很少。"><a href="#1-关于vue的模板语法，表达式。我使用的很少很少。" class="headerlink" title="1.关于vue的模板语法，表达式。我使用的很少很少。"></a>1.关于vue的模板语法，表达式。我使用的很少很少。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status是0</span><br><span class="line">&lt;view class=&quot;&quot;&gt;</span><br><span class="line">    &#123;&#123;status ? &#x27;是&#x27;:&#x27;否&#x27;&#125;&#125;//否</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;&quot;&gt;</span><br><span class="line">    &#123;&#123;status ? &#x27;已激活&#x27;:&#x27;已冻结&#x27;&#125;&#125;//已冻结</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">在模板里面使用 三元表达式，我们可以省下一个过滤器。</span><br></pre></td></tr></table></figure>

<h5 id="1-1-关于使用，我们都知道-vue的v-bind可以绑定参数。如果他是一个动态参数呢？"><a href="#1-1-关于使用，我们都知道-vue的v-bind可以绑定参数。如果他是一个动态参数呢？" class="headerlink" title="1.1 关于使用，我们都知道 vue的v-bind可以绑定参数。如果他是一个动态参数呢？"></a>1.1 关于使用，我们都知道 vue的v-bind可以绑定参数。如果他是一个动态参数呢？</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a :[type]=&quot;url&quot;&gt;百度&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		url:&#x27;https://www.baidu.com/&#x27;,</span><br><span class="line">		type:&#x27;href&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="1-2-v-on的修饰符。"><a href="#1-2-v-on的修饰符。" class="headerlink" title="1.2 v-on的修饰符。"></a>1.2 v-on的修饰符。</h5><p>v-on是用来 给vue的元素，绑定事件的。</p>
<p>例子如下，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们绑定了一个touch的事件。</span><br><span class="line">&lt;button type=&quot;default&quot; v-on:tap=&quot;touch()&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>但是，如果碰到了问题呢，比如我一个元素上面绑定了2个事件，大家都知道事件冒泡，和事件捕获。这个时候，v-on绑定事件的时候的的修饰符，就非常有必要了。</p>
<p>v-on的修饰符，用.来表示。</p>
<p>再看一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view type=&quot;default&quot; v-on:tap=&quot;touch()&quot;&gt;</span><br><span class="line">	&lt;text @tap=&quot;test()&quot;&gt;你好&lt;/text&gt;</span><br><span class="line">	&lt;text&gt;世界&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">		</span><br><span class="line">touch()&#123;</span><br><span class="line">	console.log(&#x27;11&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">test()&#123;</span><br><span class="line">	console.log(&#x27;22&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">//触发test（）,打印结果，11，22</span><br><span class="line">		</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先有2点，v-on：绑定事件的时候 可以简写为@。其次我们遇到了事件冒泡问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view type=&quot;default&quot; v-on:tap=&quot;touch()&quot;&gt;</span><br><span class="line">	&lt;text @tap.stop=&quot;test()&quot;&gt;你好&lt;/text&gt;</span><br><span class="line">	&lt;text&gt;世界&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">		</span><br><span class="line">touch()&#123;</span><br><span class="line">	console.log(&#x27;11&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">test()&#123;</span><br><span class="line">	console.log(&#x27;22&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">//v-on.stop修饰符 替我们阻止了事件的冒泡。</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>v-on的修饰符还有很多。</p>
<table>
<thead>
<tr>
<th>v-on的修饰符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>stop</td>
<td>阻止事件冒泡</td>
</tr>
<tr>
<td>once</td>
<td>事件只执行一次</td>
</tr>
<tr>
<td>prevent</td>
<td>阻止默认事件</td>
</tr>
<tr>
<td>capture</td>
<td>事件捕获</td>
</tr>
<tr>
<td>:keyup.enter</td>
<td>键盘事件，enter是回车</td>
</tr>
</tbody></table>
<hr>
<h4 id="总结知识点"><a href="#总结知识点" class="headerlink" title="总结知识点"></a>总结知识点</h4><ul>
<li>模板的三元表达式</li>
<li>指令的动态参数。[type]=’text’;</li>
<li>v-on绑定事件的修饰符。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件的双向绑定</title>
    <url>/blogs/2021/06/22/vue%E7%9A%84%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h4 id="vue组件的双向绑定。"><a href="#vue组件的双向绑定。" class="headerlink" title="vue组件的双向绑定。"></a>vue组件的双向绑定。</h4><p>一直以来vue自定义组件，都有个问题困惑我。prop，好像是一个单向数据流，父组件的数据可以传向子组件，可是子组件。无法修改父组件的值。</p>
<p>输入框的v-model也只是一个语法糖，实际上。还是把要传进来的值接受到之后再去通过$emit<br>自定义事件和值给抛了出去。</p>
<p>例子如下，我使用的是 uniapp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&#x27;updata&#x27; /&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &quot;inputfield&quot;,</span><br><span class="line">		props: &#123;</span><br><span class="line">			value: &#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">		    //输入框输入触发，input事件的时候，我们使用emit()，把值给抛出去。value得到了更新。</span><br><span class="line">			updata(e)&#123;</span><br><span class="line">				this.$emit(&#x27;input&#x27;,e.detail.value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="sync是vue的修饰符，可以帮助props，实现双向绑定。"><a href="#sync是vue的修饰符，可以帮助props，实现双向绑定。" class="headerlink" title=".sync是vue的修饰符，可以帮助props，实现双向绑定。"></a>.sync是vue的修饰符，可以帮助props，实现双向绑定。</h5><p>例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//sync绑定了value，</span><br><span class="line">&lt;inputfield :value.sync=&quot;value&quot; /&gt;</span><br><span class="line">&#123;&#123;value&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们看看组件内部是如何实现的</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view&gt;</span><br><span class="line">		&lt;view class=&quot;&quot;&gt;</span><br><span class="line">			&#123;&#123;value&#125;&#125;</span><br><span class="line">			&lt;button type=&quot;default&quot; @tap=&#x27;run&#x27;&gt;run&lt;/button&gt;</span><br><span class="line">		&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &quot;inputfield&quot;,</span><br><span class="line">		props: &#123;</span><br><span class="line">			value: &#123;</span><br><span class="line">				type: Boolean,</span><br><span class="line">				default: false,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			run() &#123;</span><br><span class="line">				//使用 emit触发一个update事件，然后:value，是我们子组件要改变的属性。</span><br><span class="line">				if (this.value) &#123;</span><br><span class="line">					this.$emit(&#x27;update:value&#x27;, false);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					this.$emit(&#x27;update:value&#x27;, true);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局复习</title>
    <url>/blogs/2021/06/21/flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="flex给项目排序"><a href="#flex给项目排序" class="headerlink" title="flex给项目排序"></a>flex给项目排序</h3><h5 id="例子如下"><a href="#例子如下" class="headerlink" title="例子如下"></a>例子如下</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    color: #fff;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    border: 1px solid #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    order: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">    order: 2;</span><br><span class="line">&#125;</span><br><span class="line">.box3&#123;</span><br><span class="line">    order: 3;</span><br><span class="line">&#125;</span><br><span class="line">.box4&#123;</span><br><span class="line">    order: 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>flex布局下面的item，根据order的大小来进行排序，数值越小越靠前。</p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>分配flex下面的item成员的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box div&#123;</span><br><span class="line">    color: #fff;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    border: 1px solid #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    flex-grow: 2;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box3&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box4&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box5&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box6&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box7&#123;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="flex-shrink属性。"><a href="#flex-shrink属性。" class="headerlink" title="flex-shrink属性。"></a>flex-shrink属性。</h4><p>当flex布局下面的item成员的宽度超过了，flex盒子的空间不足，flex-shrink，可以给他们全部等比缩小。默认为1，一个item成员flex-shrink为0，其他为1，那么前面的盒子不缩小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box div&#123;</span><br><span class="line">    color: #fff;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    border: 1px solid #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    flex-shrink: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box3&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box4&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box5&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box6&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box7&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="flex的-align-self属性"><a href="#flex的-align-self属性" class="headerlink" title="flex的 align-self属性"></a>flex的 align-self属性</h4><p>在flex父级盒子 对item下的成员使用，align-items center还是什么的时候，align-self，可以覆盖align-items的属性，只对items成员有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    height: 300;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.box div&#123;</span><br><span class="line">    color: #fff;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">    border: 1px solid #fff;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    flex-shrink: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box3&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box4&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    align-self: baseline;</span><br><span class="line">&#125;</span><br><span class="line">.box5&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box6&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box7&#123;</span><br><span class="line">    flex-shrink: 1;</span><br><span class="line">    align-self: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>使用css做一个九宫格</title>
    <url>/blogs/2021/06/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8css%E5%AE%9E%E7%8E%B0%E4%B9%9D%E5%AE%AB%E6%A0%BC/</url>
    <content><![CDATA[<h4 id="css中的，九宫格的实现。"><a href="#css中的，九宫格的实现。" class="headerlink" title="css中的，九宫格的实现。"></a>css中的，九宫格的实现。</h4><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1，2个商品排列在一起，我很难处理其中的间距。因为如果左右各设10px,他俩之间有20px的间距。<br>2，那么我们如果只给一边间距的话，那么最左边以及最右边，总会多出来。还需要我们去清理。</p>
<p>解决方案如下。</p>
<p>1，flex布局。我们需要计算长度。非常非常准确的长度。css的calc()函数准确的满足了我的需要。比如，一个盒子是100%，我们一行三列。margin-right 是10px。实际上我们需要的只是，20px的marin值就够了。</p>
<p>那么就是 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width:calc((100%-20px)/3);</span><br></pre></td></tr></table></figure>
<p>2,通过width:calc((100%-20px)/3);，我们至少拿到了，确切的宽度。剩下的是要清除。盒子，marin-right第三个，要清除10px。再写一个类，去清除是一个非常麻烦，且死板的事情。</p>
<h5 id="nth-of-type选择器，"><a href="#nth-of-type选择器，" class="headerlink" title="nth-of-type选择器，"></a>nth-of-type选择器，</h5><p>1,文档：，:nth-of-type(n) 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素.<br>可以匹配父元素下面的每一子元素，并且带着规则。比如偶数，奇数，或者倍数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">    width: calc((100% - 20px) / 3);</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-of-type(3n)&#123;</span><br><span class="line">    margin-right: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>nth-of-type(3n)，清楚了第三个，第六个，第九个的盒子。边距。</p>
<h5 id="nth-last-child选择器"><a href="#nth-last-child选择器" class="headerlink" title=":nth-last-child选择器"></a>:nth-last-child选择器</h5><p>匹配父元素下面的子元素的，从最后开始算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1:nth-last-child(3)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(2)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(1)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    width: 92%;</span><br><span class="line">    padding: 10px 4%;</span><br><span class="line">    height: 900px;</span><br><span class="line">    background-color: #f7f7f7;</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    width: calc((100% - 20px) / 3);</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-of-type(3n)&#123;</span><br><span class="line">    margin-right: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(3)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(2)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.box1:nth-last-child(1)</span><br><span class="line">&#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>九宫格</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中，class的使用</title>
    <url>/blogs/2021/06/21/Es6%E4%B8%ADclass%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="ES6中的Class"><a href="#ES6中的Class" class="headerlink" title="ES6中的Class"></a>ES6中的Class</h3><h4 id="1-首先我们可以回归一下ES5之前的类是如何实现的。"><a href="#1-首先我们可以回归一下ES5之前的类是如何实现的。" class="headerlink" title="1.首先我们可以回归一下ES5之前的类是如何实现的。"></a>1.首先我们可以回归一下ES5之前的类是如何实现的。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一个类</span><br><span class="line">function Tool(name)&#123;</span><br><span class="line">    this.name=&#x27;张三&#x27;;</span><br><span class="line">    this.run = function()&#123;</span><br><span class="line">        alert(`$&#123;this.name&#125;,在奔跑`);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//实例化</span><br><span class="line">var tool = new Tool(&#x27;李四&#x27;);</span><br><span class="line">tool.run();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用create创建类</span><br><span class="line">var Dog = &#123;</span><br><span class="line">    name:&#x27;大黄&#x27;,</span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(&#x27;我是大黄&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">Dog.prototype.name = &#x27;王五&#x27;;</span><br><span class="line">var dog = Object.create(Dog);</span><br><span class="line"></span><br><span class="line">//使用  Object.create 创建的类 没有 静态类型 ，prototype</span><br><span class="line">dog.run();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-ES6的class"><a href="#2-ES6的class" class="headerlink" title="2.ES6的class"></a>2.ES6的class</h4><p>1.es6的class更想是一个语法糖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//es6的类</span><br><span class="line">class Prson &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(&#x27;你好啊&#x27;+this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var prson = new Prson(&#x27;弟弟&#x27;);</span><br><span class="line">prson.run();//你好啊 弟弟</span><br><span class="line">console.log(prson)</span><br><span class="line">console.log(Prson === Prson.prototype.constructor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Prson的原型链的构造器指向了Prson函数。所以 es6的构造函数也有prototype</span><br></pre></td></tr></table></figure>

<h4 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h4><p>constructor是类的默认方法，只要new实例化的时候，就会调用。即使我们写，也会添加···</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sayName();</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name);//小明</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const person = new Person(&#x27;小明&#x27;,11);</span><br><span class="line">//关于 constructor 类的默认方法。new实例化后会默认调用。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-class的特性"><a href="#4-class的特性" class="headerlink" title="4.class的特性"></a>4.class的特性</h4><p>1.class的方法除非你定义在实例化的对象上，否则都是定义在prototype上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sayName();</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const person = new Person(&#x27;小明&#x27;,11);</span><br><span class="line">//类的方法只要不是定义在实例化后的对象上，就只能定义在prototype上面。</span><br><span class="line">person.love = ()=&gt;&#123;</span><br><span class="line">   console.log(11);</span><br><span class="line">&#125;</span><br><span class="line">person.love();</span><br><span class="line">console.log(Person.prototype.love)//undefined</span><br><span class="line">//关于 constructor 类的默认方法。new实例化后会默认调用。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.类只能先声明，后实例化。没有变量提升。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// error index.js:13 Uncaught ReferenceError: Cannot access &#x27;Person&#x27; before initialization</span><br><span class="line">const person = new Person(&#x27;小明&#x27;,11);</span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sayName();</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="class的静态方法。"><a href="#class的静态方法。" class="headerlink" title="class的静态方法。"></a>class的静态方法。</h4><p>1.静态方法只能在class上面调用。实例无法使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//class的静态方法 只能在类上调用，实例无法使用。</span><br><span class="line"></span><br><span class="line">class Dog&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    static run(name)&#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">var dog = new Dog(&#x27;大黄&#x27;);</span><br><span class="line">Dog.run(&#x27;李四&#x27;);</span><br><span class="line">dog.run(&#x27;胖虎&#x27;);// dog.run is not a function</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>2.如果静态方法包含this，那么这个this指向class，而不是实例。（class的静态方法只能调用静态方法，不能调用实例方法。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line"></span><br><span class="line">//class的静态方法 只能在类上调用，实例无法使用。</span><br><span class="line"></span><br><span class="line">class Dog&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    static run(name)&#123;</span><br><span class="line">        this.pay();</span><br><span class="line">    &#125;;</span><br><span class="line">    pay()&#123;</span><br><span class="line">        console.log(&#x27;狗狗去付账&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">    static pay()&#123;</span><br><span class="line">        console.log(&#x27;狗狗去福州&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Dog.pay();//index.js:16 狗狗去福州</span><br><span class="line">var dog = new Dog(&#x27;大黄&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从这里我们能得出 class的静态方法与实例方法可以重名。</p>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>1.class里面加入 static 的属性就是静态属性，实例无法使用。只能给class使用。<br>2.和静态方法一样，静态属性与实例属性可以重名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//class的静态属性。</span><br><span class="line"></span><br><span class="line">class Dog &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    static name = 11;</span><br><span class="line">&#125;;</span><br><span class="line">var dog = new Dog(&#x27;大黄&#x27;);</span><br><span class="line">console.log(Dog.name,dog.name)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="关于class的extends，实现继承。"><a href="#关于class的extends，实现继承。" class="headerlink" title="关于class的extends，实现继承。"></a>关于class的extends，实现继承。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// class继承</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">    run(name)&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//cat 继承了 Animalclass</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">var cat = new Cat();</span><br><span class="line">cat.run(&#x27;李四&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="class-super关键字"><a href="#class-super关键字" class="headerlink" title="class super关键字"></a>class super关键字</h4><p>1.super可以作为函数，也可以作为对象。<br>2.子类继承父类之前，没有super函数，是不能使用this的。<br>3.super在子类的构造函数里面代表了父类的构造器。<br>4.super作为对象，调用父类的实例方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// class继承</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;;</span><br><span class="line">     run()&#123;</span><br><span class="line">        console.log(&#x27;111&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//cat 继承了 Animalclass</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    constructor(name,age,color)&#123;</span><br><span class="line">        //super代表父类的构造函数。</span><br><span class="line">        super(name,age,color);</span><br><span class="line">        console.log(this.name,this.age)</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        //super指向父类的实例方法。</span><br><span class="line">        super.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var cat = new Cat(&#x27;李四&#x27;,11,&#x27;red&#x27;);</span><br><span class="line">cat.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.class是一个语法糖，本身还是基于prototype来做的继承。<br>2.静态类型static，只能在这个class访问。实例化的对象无法访问。<br>3.静态方法也只能给这个类去用。实例化后的对象无法使用。<br>4.子类继承父类，super必须要在构造器中作为函数使用。<br>5.super既可以当作函数也可以当作对象。作为函数，在子类构造器中代表了父类构造函数<br>作为对象代表了父类实例方法，在静态类型的方法中，指向父类。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>我的想法</title>
    <url>/blogs/2021/06/11/hello-world/</url>
    <content><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><h2 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1 自我介绍"></a>1 自我介绍</h2><p>1.我是一个比较热爱技术，沉默寡言的我。学历不高，受教育程度有限，使我在选择这门活计的时候犹豫了很久，最后抱着试试看的心态做的。<br>2.怕什么真理无穷，进一寸有一寸的欢喜</p>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>自我表达</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的async与await</title>
    <url>/blogs/2021/06/05/JavaScript%E4%B8%AD%E7%9A%84async/</url>
    <content><![CDATA[<h4 id="在JavaScript中，async与await的使用"><a href="#在JavaScript中，async与await的使用" class="headerlink" title="在JavaScript中，async与await的使用"></a>在JavaScript中，async与await的使用</h4><h5 id="1-async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。"><a href="#1-async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。" class="headerlink" title="1.async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。"></a>1.async函数中的，async代表一个关键字。和await是一块用的。await只能在async函数里面使用。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义一个异步函数。</span><br><span class="line">function one()&#123;  </span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        console.log(&#x27;11&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">定义一个async函数</span><br><span class="line">async function test()&#123;</span><br><span class="line">    await one();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(test());--Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">打印出来的async函数是一个promise对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">既然async函数内置了 promise对象，那么就可以使用then来调用。</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;success&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="2-async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。"><a href="#2-async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。" class="headerlink" title="2.async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。"></a>2.async函数是一个异步函数。我们亲眼看到async里面内置了promise对象，但是我想从执行顺序，时间上告诉你。它真的是异步。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function timer() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    console.log(11);</span><br><span class="line">    await timer().then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;2000之后执行&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">demo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-那么为什么使用async而不是-直接去用promise呢？"><a href="#3-那么为什么使用async而不是-直接去用promise呢？" class="headerlink" title="3.那么为什么使用async而不是 直接去用promise呢？"></a>3.那么为什么使用async而不是 直接去用promise呢？</h5><p>原因很简单，因为，我们假设一个情况，promise A方法成功之后去调，Promise B方法，以此类推。是的promise其实已经很好了，但是。then多了 恐怕你不会觉得它优雅。<br>其次，我有八个异步方法，我需要等他们执行完毕后，一起告诉我结果。到底是成功和失败。async函数 更好一些。</p>
<p>请看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    await timer(1000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步A&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(2000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步B&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(5000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步C&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return Promise.resolve();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//控制台打印结果</span><br><span class="line">/*</span><br><span class="line">异步A</span><br><span class="line">index.js:157 异步B</span><br><span class="line">index.js:160 异步C</span><br><span class="line">index.js:166 异步执行完毕</span><br><span class="line">*/</span><br><span class="line">demo().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;异步执行完毕&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于async函数的理解，就像一辆校车。必须要等所有的同学都上车了才能发车。await函数全部执行完毕了，才能拿到成功还是失败。</p>
<h5 id="async函数执行，我们必须要把promise的结果给-return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。"><a href="#async函数执行，我们必须要把promise的结果给-return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。" class="headerlink" title="async函数执行，我们必须要把promise的结果给 return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。"></a>async函数执行，我们必须要把promise的结果给 return出去，如果我们不return的话，与promise不同，async函数的promise对象的状态始终就是reslove。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个异步函数。</span><br><span class="line">async function demo() &#123;</span><br><span class="line">    await timer(1000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步A&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(2000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步B&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    await timer(5000).then(res=&gt;&#123;</span><br><span class="line">        console.log(&#x27;异步C&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    return Promise.resolve();//所以我们在这里把 promise的状态 return出去。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//控制台打印结果</span><br><span class="line">/*</span><br><span class="line">异步A</span><br><span class="line">index.js:157 异步B</span><br><span class="line">index.js:160 异步C</span><br><span class="line">index.js:166 异步执行完毕</span><br><span class="line">*/</span><br><span class="line">demo().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;异步执行完毕&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="谈谈await的理解。"><a href="#谈谈await的理解。" class="headerlink" title="谈谈await的理解。"></a>谈谈await的理解。</h5><p>1.await必须要在async函数里面使用。否则报错。<br>2.await函数表示一个等待，它返回的不是promise对象，而是promise的结果。<br>3，await函数，会阻止async函数的执行。JavaScript是一个从上往下执行的语言。但是，await可以跳出async函数，继续往后面执行。</p>
<h5 id="关于await的执行顺序。"><a href="#关于await的执行顺序。" class="headerlink" title="关于await的执行顺序。"></a>关于await的执行顺序。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function timer(timer) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            return resolve(timer + 1000);</span><br><span class="line">        &#125;, timer);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">function one(num) &#123;</span><br><span class="line">    console.log(&#x27;第一次不延迟&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">function two(num) &#123;</span><br><span class="line">    console.log(&#x27;第二次延迟&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">function three(num) &#123;</span><br><span class="line">    console.log(&#x27;第三次延迟+&#x27; + num);</span><br><span class="line">    return timer(num);</span><br><span class="line">&#125;;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    let time = 1000;</span><br><span class="line">    const timer1 = await one(time);</span><br><span class="line">    const timer2 = await two(timer1);</span><br><span class="line">    const timer3 = await three(timer2);</span><br><span class="line">    console.log(&#x27;第四次延迟&#x27;,timer3);</span><br><span class="line">    return Promise.resolve();</span><br><span class="line">&#125;;</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;end&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">timer(1000).then(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;11&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">控制台打印</span><br><span class="line">1.第一次不延迟1000，因为test函数的变量值，传了进去，执行了one方法。  </span><br><span class="line">因为跳出async函数后，执行了timer也是异步方法。</span><br><span class="line">2.第二次延迟2000，所以继续执行two，还是遇到了await，跳出去。</span><br><span class="line">3.11，跳出来执行，timer异步任务结束。</span><br><span class="line">4.第三次延迟，3000，拿到了two函数的返回值。await跳出async函数，可惜async函数外部没有可执行的函数了。</span><br><span class="line">5.第四次，延迟，three函数的返回值出来了。</span><br><span class="line">6.11，await函数执行完毕，promise给结果。</span><br></pre></td></tr></table></figure>
<h5 id="async函数异常不好捕捉。try-catch-配合使用。"><a href="#async函数异常不好捕捉。try-catch-配合使用。" class="headerlink" title="async函数异常不好捕捉。try catch 配合使用。"></a>async函数异常不好捕捉。try catch 配合使用。</h5><p>反面案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//async函数异常不好捕捉，一个异常，后续方法都不会执行了。</span><br><span class="line">function run(value)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        if(value)&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">async function test()&#123;</span><br><span class="line">    await run(true);</span><br><span class="line">    await run(false);</span><br><span class="line">&#125;;</span><br><span class="line">test().then(res=&gt;&#123;</span><br><span class="line">    console.log(&#x27;成功了&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">//控制台Uncaught (in promise) undefined</span><br></pre></td></tr></table></figure>

<p>正确方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用try catch配合。</span><br><span class="line">function run(value) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (value) &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await run(false);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.log(&#x27;run(false)报错&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        await run(true);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.log(&#x27;run(true)报错&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">test().then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;成功了&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">//控制台run(false)报错，成功了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1.async是语法糖，也是一个关键字。<br>2.async函数，内置promise。<br>3.async函数默认，resolve。必须return才能改变。<br>4.async函数，必须等所有的await函数都有结果了，promise才会有结果。<br>5.async函数，只要有一个await异步任务异常就会停止。<br>6.async函数建议配合try，catch。抛出异常，继续执行下个异步任务。</p>
<p>1.await代表一个异步任务。<br>2.await必须要在async里面用。<br>3.await函数，里面同步的方法还是会执行的。遇到promise，跳出async，等待。<br>4.await返回的不是promise对象，只是promise的结果。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
